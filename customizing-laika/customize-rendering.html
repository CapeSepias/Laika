<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using the Library API</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li class="active"><a href="#">Customizing Renderers</a></li>
          <li><a href="tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1>Customizing Renderers</h1>
        </div>
        <p>In some cases you might want to override the output of a renderer for a few types
        of document tree nodes only, while keeping the default for the rest. Both the
        Transform and Render APIs offer a hook to easily do that without modifying
        or extending the existing renderer. </p>
        <p>This is the signature of a custom renderer hook:</p>
        <pre>PartialFunction[(Formatter, Element), String]
</pre>
        <p><code>Formatter</code> is a generic type representing the formatting API which is different for each 
        output format. For HTML it is <code>HTMLFormatterr</code>, for XSL-FO it is <code>FOFormatter</code>. 
        This way renderers can offer the most convenient API for a specific output format.
        It provides a helper API for rendering tags, adds the current indentation level after
        line breaks and knows how to render child elements. </p>
        <p><code>Element</code> is the base type of the document AST and represent the AST node to render, <code>String</code>
        is the render result in the expected target format.</p>
        
        <h2 id="defining-a-render-function" class="section">Defining a Render Function</h2>
        <p>This section explains how a render function is implemented and the subsequent sections
        show the three different ways to register such a function.</p>
        <p>In the following example only the HTML output for emphasized text will be modified,
        adding a specific style class:</p>
        <pre>val renderer: PartialFunction[(HTMLFormatter, Element), String] = {
  case (fmt, Emphasized(content, opt)) =&gt; 
    fmt.element(&quot;em&quot;, opt, content, &quot;class&quot; -&gt; &quot;big&quot;) 
}</pre>
        <p>For all node types where the partial function is not defined, the default renderer
        will be used.</p>
        <p>Multiple custom renderers can be specified for the same transformation, they will be 
        tried in the order you added them, falling back to the default in case none is defined 
        for a specific node.</p>
        <p>The <code>content</code> value above is of type <code>Seq[Span]</code>. A renderer should only ever render
        a single node and delegate to the formatter for rendering children. Only the formatter
        has a list of all installed render extensions as well as the base renderer and will
        delegate to those function where the partial function is defined for the child element. </p>
        
        <h2 id="registering-a-render-function" class="section">Registering a Render Function</h2>
        <p>The mechanism is slightly different, depending on whether you are using the sbt
        plugin or Laika as a library in an application. In the latter case you have two
        choices, one for performing a full transformation, the other for a separate
        render operation. All three options are described below.</p>
        
        <h3 id="using-the-sbt-plugin" class="section">Using the sbt Plugin</h3>
        <p>In <code>build.sbt</code>:</p>
        <pre>import laika.ast._

laikaSiteRenderers += laikaSiteRenderer {
  case (fmt, Emphasized(content, opt)) =&gt; 
    fmt.element(&quot;em&quot;, opt, content, &quot;class&quot; -&gt; &quot;big&quot;)
}</pre>
        
        <h3 id="using-the-transformer-api" class="section">Using the Transformer API</h3>
        <pre>val transformer = Transformer
  .from(Markdown)
  .to(HTML)
  .rendering {
    case (fmt, Emphasized(content, opt)) =&gt; 
      fmt.element(&quot;em&quot;, opt, content, &quot;class&quot; -&gt; &quot;big&quot;)
  }.build</pre>
        
        <h3 id="using-the-renderer-api" class="section">Using the Renderer API</h3>
        <pre>val doc: Document = ...

val renderer = Renderer
  .of(HTML)
  .rendering { 
    case (fmt, Emphasized(content, opt)) =&gt; 
      fmt.element(&quot;em&quot;, opt, content, &quot;class&quot; -&gt; &quot;big&quot;)
  }.build</pre>
        
        <h2 id="the-formatter-apis" class="section">The Formatter APIs</h2>
        <p>Each formatter provides functionality that is specific to the target format.
        On top of that all formatters manage the indentation level after line breaks and 
        know how to delegate to the relevant renderers for child elements.</p>
        
        <h3 id="textformatter" class="section">TextFormatter</h3>
        <p>This is the base API supported by both the <code>XSL-FO</code> and <code>HTML</code> renderer,
        both of them adding several methods with rendering logic specific to that format.</p>
        <ul>
          <li>
            <p><code>newLine</code> renders a newline character followed by whitespace for the current level of indentation</p>
          </li>
          <li>
            <p><code>child</code> render a single child element.</p>
          </li>
          <li>
            <p><code>childPerLine</code> renders a list of child elements, each on a separate line, 
            with the current level of indentation</p>
          </li>
          <li>
            <p><code>indentedChildren</code> renders a list of child elements, each on a separate line, 
            indented one level to the right from the current indentation level</p>
          </li>
        </ul>
        
        <h3 id="htmlformatter" class="section">HTMLFormatter</h3>
        <p>This formatter supports all methods of the <code>TextFormatter</code> API shown above, and adds
        the following methods:</p>
        <ul>
          <li>
            <p><code>element</code> renders a tag where the specified list of child elements will be used to render the content of the tag</p>
          </li>
          <li>
            <p><code>indentedElement</code> is similar to <code>element</code>, but renders the child elements one per line and indented to the right</p>
          </li>
          <li>
            <p><code>textElement</code> renders an element with text content with special characters replaced by entities</p>
          </li>
          <li>
            <p><code>emptyElement</code> renders an empty tag</p>
          </li>
        </ul>
        
        <h3 id="themes" class="section">Themes</h3>
        <p>A theme is a collection of customized renderers as shown in the previous sections,
        plus optionally default templates and/or static files to be copied to the output
        directory.</p>
        <p>This is the signature of the <code>Theme</code> case class:</p>
        <pre>case class Theme (customRenderer: PartialFunction[(Formatter, Element), String],
                  defaultTemplate: Option[TemplateRoot],
                  defaultStyles: StyleDeclarationSet)</pre>
        <ul>
          <li>
            <p>The <code>customRenderer</code> is a renderer function that overrides the built-in renderers
            for one or more nodes, see the sections above for details on how to write such a function.</p>
          </li>
          <li>
            <p>The <code>defaultTemplate</code> is the AST for the template to embed the render result in, 
            overriding the default template of the library. You can create the AST programmatically
            or use Laika&#39;s templating syntax and parse it from a file or the resource directory if
            you bundle your theme in a jar:</p>
            <p>DefaultTemplateParser.parse(Input.fromClasspath(
                &quot;/templates/default.template.html&quot;, Root / &quot;default.template.html&quot;
              )) </p>
          </li>
          <li>
            <p>The <code>defaultStyles</code> allow you to customize the default CSS for a format. This
            is currently only processed for PDF, as it is the only format where Laika processes
            the CSS and applies it to the render result. If you want to add CSS for HTML or EPUB, 
            add them as static files instead, as Laika will just copy them over without processing them.</p>
          </li>
        </ul>
        <p>A theme can be installed as part of an extension bundle:</p>
        <pre>object MyExtensions extends ExtensionBundle {

  override val themes = Seq(HTML.Theme(...), PDF.Theme(...))
    
}

val transformer = Transformer.from(Markdown).to(HTML).using(MyExtensions)</pre>
        <p>A theme is specific to a particular output format, separate instances need to be 
        provided if you want to install themes for several formats like HTML, PDF or EPUB.</p>      

      </div>
    </div>

  </div>

</body></html>
