<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link rel="stylesheet" href="../icons/icofont.min.css">
    <link href="../css/container.css" rel="stylesheet">
    <link href="../css/content.css" rel="stylesheet">
    <link href="../css/nav.css" rel="stylesheet">
    <link href="../css/code.css" rel="stylesheet">

    <script src="../js/theme.js"></script>
    <script> /* for avoiding page load transitions */ </script>

  </head>

  <body>

    <nav id="sidebar">

      <a id="close-nav-icon">
        <i class="icofont-close-circled icofont-xlg"></i>
      </a>

      <ul class="nav nav-list">

        
        <li><a href="../table-of-contents.html">Table of Contents</a></li>
        <li class="nav-header">About Laika</li>
        <li><a href="../01-about-laika/01-features.html">Features</a></li>
        <li><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
        <li class="nav-header">Running Laika</li>
        <li><a href="../02-running-laika/01-sbt-plugin.html">sbt Plugin</a></li>
        <li><a href="../02-running-laika/02-library-api.html">Library API</a></li>
        <li><a href="../02-running-laika/03-configuration.html">Configuration</a></li>
        <li class="nav-header">Preparing Content</li>
        <li><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
        <li><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
        <li><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
        <li><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
        <li class="nav-header">Customizing Laika</li>
        <li class="active"><a href="#">Overview</a></li>
        <li><a href="03-creating-templates.html">Creating Templates</a></li>
        <li><a href="04-document-ast.html">The Document AST</a></li>
        <li><a href="05-ast-rewriting.html">AST Rewriting</a></li>
        <li><a href="06-overriding-renderers.html">Overriding Renderers</a></li>
        <li class="nav-header">Extending Laika</li>
        <li><a href="../05-extending-laika/01-overview.html">Overview</a></li>
        <li><a href="../05-extending-laika/03-implementing-directives.html">Implementing Directives</a></li>
        <li><a href="../05-extending-laika/04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
        <li><a href="../05-extending-laika/06-adding-syntax-highlighters.html">Adding Syntax Highlighters</a></li>
        <li><a href="../05-extending-laika/07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
        <li class="nav-header">Sub-Modules</li>
        <li><a href="../06-sub-modules/02-laikas-parser-combinators.html">Laika&#39;s Parser Combinators</a></li>
        <li><a href="../06-sub-modules/03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
        <li class="nav-header">Reference</li>
        <li><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
        <li><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
        <li><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
        <li><a href="../07-reference/06-release-notes.html">Release Notes</a></li>
        <li><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
        
        <li class="nav-header">Project Links</li>
        <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
        <li><a href="../api/laika/api/">API Documentation</a></li>
        <li><a href="http://planet42.org/">Demo App</a></li>
        
      </ul>

    </nav>

    <div id="container">

      <a id="open-nav-icon">
        <i class="icofont-navigation-menu icofont-xlg"></i>
      </a>

      <main class="content">

        <div class="page-header">
        <h1 id="overview" class="title">Overview</h1>
        </div>
        <p>Laika&#39;s Documentation comes with separate sections for &quot;Customizing&quot; and &quot;Extending&quot; Laika.
        While the line between the two is naturally quite blurry, 
        the distinction is mostly meant to be between these two scenarios:</p>
        <ul>
          <li>
            <p>Customizing Laika refers to the things you most likely want to tweak and adjust for a specific project.</p>
          </li>
          <li>
            <p>Extending Laika refers to the kind of re-usable extensions you might want to write as an in-house
            library or a 3rd-party open source extension.</p>
          </li>
        </ul>
        <p>This section deals with the former scenario.</p>
        
        <h2 id="transformation-phases" class="section">Transformation Phases</h2>
        <p>In cases where you just want to tweak some minor details about how your site or e-book renders, 
        you can use one of Laika&#39;s hooks into the various phases of a transformation.</p>
        <p>For a better understanding of the customization options it is good to a have a rough idea about how
        a transformation in Laika is performed. It can be divided into 4 phases:</p>
        <p>1) The parsing step. Text markup and template documents get parsed and translated into an internal AST.
           The AST is a generic abstraction of the document&#39;s structure and is not tied to any specific semantics
           of a particular input or output format.</p>
        <p>2) The AST transformation. The original AST is only what each parser for the corresponding block or inline
           element can process locally, without access to other nodes or even other documents. 
           One of the advantages of this design, apart from separation of concerns, is that parsers can run in parallel.
           As a consequence nodes like internal references or auto-numbered footnotes require further processing with access to
           a <code>DocumentCursor</code> that allows to access content from anywhere in the input tree.</p>
        <p>3) Applying templates to markup documents. 
           Since both are just AST structures, this step is merely a second AST transformation.
           The AST representing the markup document will be inserted into the node of the template AST that holds
           a reference to the content.</p>
        <p>4) Rendering. As the last step the final AST obtained from the two previous transformation steps will get rendered
           to one or more output format. 
           This is the only step specific to a particular output format, meaning the same AST structure obtained in 3) will
           get used as the input for the renderers of all formats.</p>
        
        <h2 id="customization-options" class="section">Customization Options</h2>
        <p>The hooks that are the most likely candidates of helping you with smaller tweaks to a transformation are the
        following:</p>
        <ul>
          <li>
            <p><a href="03-creating-templates.html#creating-templates">Creating Templates</a>: Hooks into phase 3 described above. 
            A template lets you specify where the content from text markup documents gets inserted
            and allows to add additional dynamic elements like navigation bars. </p>
          </li>
          <li>
            <p><a href="05-ast-rewriting.html#ast-rewriting">AST Rewriting</a>: Hooks into phase 2 described above.
            The advantage of using this hook over tweaking renderers is that changes made to the AST are always
            reflected in all rendered output formats. 
            So if your custom logic is not specific to the output format, you should prefer this option.
            Writing a custom rewrite rule requires pattern matching on the AST node you are interested in,
            therefore, you may also want to read about <a href="04-document-ast.html#the-document-ast">The Document AST</a>.</p>
          </li>
          <li>
            <p><a href="06-overriding-renderers.html#overriding-renderers">Overriding Renderers</a>: Hooks into phase 4 described above.
            It allows you to override the default renderer for one or more specific AST node types, 
            while falling back to the built-in renderers for all others.
            Overriding renderers also requires pattern matching on the AST node you are interested in,
            therefore, you may also want to read about <a href="04-document-ast.html#the-document-ast">The Document AST</a>.</p>
          </li>
        </ul>
        
      </main>
      
    </div>

  </body>
</html>
