<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="introduction/intro.html">Overview</a></li>
          <li><a href="introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="using-laika/embedded.html">Using the Library API</a></li>
          <li><a href="using-laika/markup.html">Supported Markup</a></li>
          <li><a href="using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="using-laika/structure.html">Document Structure</a></li>
          <li><a href="using-laika/templates.html">Templates</a></li>
          <li><a href="using-laika/syntax.html">Syntax Highlighting</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="extending-laika/directive.html">Directives</a></li>
          <li><a href="extending-laika/parser.html">Parsers</a></li>
          <li><a href="extending-laika/renderer.html">Renderers</a></li>
          <li><a href="extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1>Migration Guide for Version 0.12</h1>
        </div>
        <p>The 0.12 release contains the most significant number of breaking changes
        of any release since the 0.1 version in 2012.</p>
        <p><strong>Using Laika&#39;s sbt plugin</strong></p>
        <ul>
          <li>If you do not use any of the customization hooks you can safely skip this guide.</li>
          <li>If you define custom rewrite rules, render functions or directives, 
          please see the corresponding sections below.</li>
        </ul>
        <p><strong>Using Laika&#39;s Library API</strong></p>
        <ul>
          <li>It&#39;s probably safest you read all the sections of this guide as even the 
          high level APIs had changed.</li>
          <li>You can of course simply skip features you do not use.</li>
        </ul>
        <p>This guide is written for users of the 0.9, 0.10 and 0.11 releases which had been compatible
        with each other. </p>
        <p>If you migrate from an even earlier version, please start with the release
        notes for 0.9 first <a href="https://github.com/planet42/Laika/releases/tag/0.9.0">https://github.com/planet42/Laika/releases/tag/0.9.0</a> </p>
        
        <h2 id="motivation" class="section">Motivation</h2>
        <p>The following design goals led to the partial rewrite:</p>
        <ul>
          <li>Make the library a good citizen in a pure FP setup</li>
          <li>Stop throwing any exceptions in public APIs</li>
          <li>Stop hiding the side-effecting nature of some operations in blocking, synchronous APIs</li>
          <li>Build on top of cats-effect so that users get the familiar Bring-Your-Own Effect setup</li>
          <li>Avoid any kind of runtime reflection</li>
          <li>Make the feature set which had grown organically over the years more consistent and convenient
          to use</li>
          <li>Do many changes in one big, breaking release so that the road towards
          a final 1.0 release will be less bumpy from now on</li>
        </ul>
        
        <h2 id="new-separate-laika-io-module" class="section">New Separate laika-io Module</h2>
        <p>A subset of the existing <code>laika-core</code> module has been extracted into its own module,
        <code>laika-io</code>. You need to add this new dependency if you use:</p>
        <ul>
          <li>File/Stream IO</li>
          <li>EPUB output</li>
          <li>Parallel transformations</li>
        </ul>
        <p>The existing PDF support already had its own, separate artifact <code>laika-pdf</code> which
        is also still available.</p>
        <p>If you mostly do in-memory transformations from Markdown or reStructuredText to HTML
        you can continue using the <code>laika-core</code> module.</p>
        <p>The reasons for the split were:</p>
        <ul>
          <li>Keep features that depend on cats-effect separate so that the core module
          does not need this dependency</li>
          <li>Narrow the feature set of the core module to a point where it can realistically
          be fully supported for Scala.js in a later release (most likely 0.13)</li>
        </ul>
        
        <h2 id="referential-transparency" class="section">Referential Transparency</h2>
        <p>Laika is now supposed to be a good citizen in a pure FP setup when using its
        library API. The following changes had been implemented for this purpose:</p>
        <ul>
          <li>No method in the public API throws any Exceptions anymore.</li>
          <li>The result of pure operations is provided by instances of <code>Either</code>.</li>
          <li>The result of side-effecting operations is provided by a return type of <code>F[A]</code>
          where <code>F[_]</code> is the standard Bring-Your-Own-Effect pattern, so that
          Laika can be used with cats-IO, Monix or Zio.</li>
          <li>The dependency on the Typesafe Config library and its impure Java API has
          been removed in favor of a new lightweight and pure HOCON parser provided
          by Laika, supporting the full spec except for file includes (for now).</li>
        </ul>
        
        <h2 id="parser-renderer-and-transformer-apis" class="section">Parser, Renderer and Transformer APIs</h2>
        <p>The changes were necessary for the following reasons:</p>
        <ul>
          <li>The reduced core module does no longer offer any IO-related functionality. </li>
          <li>The return types of many methods had to change as Laika does no longer throw any Exceptions.</li>
          <li>The new IO module has its own builder APIs for constructing instances that work with
          the cats-effect type classes.</li>
        </ul>
        <p>It&#39;s probably easiest to just show a few before/after examples below:</p>
        <p><strong>Transforming from Markdown to HTML in-memory</strong></p>
        <p>Before
        ```scala
        val input = &quot;some <em>text</em> example&quot;</p>
        <p>val transformer = Transform
          .from(Markdown)
          .to(HTML)
          .using(GitHubFlavor)</p>
        <p>val res: String = transformer
          .fromString(input)
          .toString<br>
        ```</p>
        <p>After
        ```scala
        val input = &quot;some <em>text</em> example&quot;</p>
        <p>val transformer = Transformer
          .from(Markdown)
          .to(HTML)
          .using(GitHubFlavor)
          .build</p>
        <p>val res: Either[ParserError, String] = transformer
          .transform(input)
        ```</p>
        <p><strong>Transforming a directory of files from Markdown to HTML</strong></p>
        <p>Before
        ```scala
        val transformer = Transform
          .from(Markdown)
          .to(HTML)
          .using(GitHubFlavor)</p>
        <p>val res: Unit = transformer
          .fromDirectory(&quot;src&quot;)
          .toDirectory(&quot;target&quot;)<br>
        ```</p>
        <p>After (ensure you added the new <code>laika-io</code> dependency):
        ```scala
        import laika.io.implicits._</p>
        <p>implicit val cs: ContextShift[IO] = 
          IO.contextShift(ExecutionContext.global)</p>
        <p>val blocker = Blocker.liftExecutionContext(
          ExecutionContext.fromExecutor(Executors.newCachedThreadPool())
        )</p>
        <p>val transformer = Transformer
          .from(Markdown)
          .to(HTML)
          .using(GitHubFlavor)
          .io(blocker)
          .parallel[IO]
          .build</p>
        <p>val res: IO[Unit] = transformer
          .fromDirectory(&quot;src&quot;)
          .toDirectory(&quot;target&quot;)
          .transform
        ```</p>
        <p>Note that while the new code sample looks more verbose, it now gives you full
        control over where your effects are run.</p>
        
        <h2 id="customizing-renderers" class="section">Customizing Renderers</h2>
        <p>The renderer API had changed from a side-effecting API to a pure API.
        Renderers now take AST elements and produce a string and will be invoked
        recursively as before. This model allows for easier testing and pure code
        at a minimal performance hit over the old design (&lt; 10%).</p>
        <p>Before
        <code>`scala
val transformer = Transform
  .from(Markdown)
  .to(HTML)
  .rendering { out =&gt; 
    { case Emphasized(content, _) =&gt; 
      out &lt;&lt; &quot;&quot;&quot;&lt;em class=&quot;big&quot;&gt;&quot;&quot;&quot; &lt;&lt; content &lt;&lt; &quot;&lt;/em&gt;&quot; } 
  }</code>`</p>
        <p>After
        <code>`scala
val transformer = Transformer
  .from(Markdown)
  .to(HTML)
  .rendering {
    case (fmt, Emphasized(content, opt)) =&gt; 
      fmt.element(&quot;em&quot;, opt, content, &quot;class&quot; -&gt; &quot;big&quot;)
    }.build</code>`</p>
        <p>The engine passes the following instances to the partial function:</p>
        <ul>
          <li>The formatter (<code>fmt</code>) which has a different API for each supported output format,
          in this case it will be an <code>HTMLFormatter</code></li>
          <li>The current element of the rendered document AST which you can pattern match on<br></li>
        </ul>
        
        <h2 id="rewrite-rules" class="section">Rewrite Rules</h2>
        <p>Here most of the changes are in the implementation which had been rewritten to avoid
        any kind of runtime reflection. </p>
        <p>On the API surface, there are only two changes:</p>
        <ul>
          <li>The return type is more explicit (e.g. <code>Replace(newElement)</code> instead of <code>Some(newElement)</code>)</li>
          <li>Rules for rewriting spans and blocks get registered separately for increased
          type-safety, as it is invalid to replace a span with a block element.</li>
        </ul>
        <p>Before
        <code>`scala
val transformer = Transform
  .from(Markdown)
  .to(HTML)
  .usingRule {
    case Emphasized(content, opts) =&gt; Some(Strong(content, opts))
  }</code>`</p>
        <p>After
        <code>`scala
val transformer = Transformer
  .from(Markdown)
  .to(HTML)
  .usingSpanRule {
    case Emphasized(content, opts) =&gt; Replace(Strong(content, opts))
  }
  .build</code>`</p>
        
        <h2 id="templating" class="section">Templating</h2>
        <p>Variable substitutions now use HOCON syntax in line with the general deeper integration
        with HOCON throughout Laika&#39;s feature set. </p>
        <p>The old syntax is still supported, 
        but will be removed at some point before the 1.0 release.</p>
        <p>The old reference style <code>{{some.ref}}</code> now becomes either <code>${some.ref}</code> for a required
        reference or <code>${?some.ref}</code> for an optional one.</p>
        
        <h2 id="directives" class="section">Directives</h2>
        <p>Directives in 0.12 come with changes in both, the DSL for creating custom directives
        and the supported syntax in markup and template files.</p>
        <p>If you are not implementing your own directives, but only use the built-in ones
        provided by Laika, you can skip the section on the DSL.</p>
        
        <h3 id="directive-syntax" class="section">Directive Syntax</h3>
        <ul>
          <li>The separators for the attribute and body sections have changed</li>
          <li>HOCON syntax is now used for attributes</li>
          <li>The old syntax is still supported, but will be removed at some point before the 1.0 release</li>
        </ul>
        <p>Before
        ```laika-html
        @:if &quot;layout.showSidebar&quot;:
          &lt;div class=&quot;sidebar&quot;&gt;...&lt;/div&gt;</p>
        <p>~else:
          &lt;p&gt;Something else&lt;/p&gt;
        ```</p>
        <p>After
        ```laika-html
        @:if { layout.showSidebar }
        &lt;div class=&quot;sidebar&quot;&gt;...&lt;/div&gt;</p>
        <pre>@:else</pre>
        <p>&lt;p&gt;Something else&lt;/p&gt;</p>
        <p>@:@
        ```</p>
        
        <h3 id="directive-dsl" class="section">Directive DSL</h3>
        <p>The building blocks for creating your own directives have also changed significantly:</p>
        <ul>
          <li><code>attribute(Default)</code> is now <code>defaultAttribute</code></li>
          <li><code>body</code> is now either <code>parsedBody</code> or <code>rawBody</code></li>
          <li>Type conversions happen with the new <code>as</code> method: <code>attribute(&quot;title&quot;).as[String]</code>,
          based on the <code>ConfigDecoder</code> type class that is also used for the new Config API</li>
          <li>Named body parts have been replaced by the more flexible Separator Directives, 
          see <a href="extending-laika/directive.html#separated-body">Separated Body</a> for details</li>
          <li>The built-in helper for mapping directive parts with different arity has
          been replaced by cats <code>mapN</code></li>
        </ul>
        <p>Before
        ```scala
        import laika.ast._
        import Spans.dsl._</p>
        <p>case class Note (title: String, 
                         content: Seq[Span], 
                         options: Options = NoOpt) extends Span 
                                                   with SpanContainer[Note]</p>
        <p>val spanDirective = Spans.create(&quot;note&quot;) {
          (attribute(Default) ~ body(Default)) (Note(<em>,</em>))
        }<br>
        ```</p>
        <p>After
        ```scala
        import cats.implicits._
        import laika.ast._
        import Spans.dsl._</p>
        <p>case class Note (title: String, 
                         content: Seq[Span], 
                         options: Options = NoOpt) extends Span 
                                                   with SpanContainer[Note]</p>
        <p>val spanDirective = Spans.create(&quot;note&quot;) {
          (defaultAttribute.as[String], parsedBody).mapN(Note(<em>,</em>))
        }<br>
        ```</p>
        <p>Note the additional import of cats implicits in the new version.</p>
        
        <h2 id="config-api" class="section">Config API</h2>
        <p>Laika&#39;s support for HOCON configuration, originating either from configuration headers
        in markup or template documents or separate configuration files had previously been
        based on the Typesafe Config library and its Java API. Instances of <code>Config</code> were
        available in the <code>Document</code> and <code>DocumentTree</code> types. </p>
        <p>This type is now Laika&#39;s own Config API, based on its own lightweight HOCON parser.
        See the API docs for <a href="http://planet42.github.com/Laika/api/laika/config/Config.html">laika.config.Config</a> for details.</p>
        
        <h2 id="document-tree-model" class="section">Document Tree Model</h2>
        <p>The model had been enhanced to better cater for Laika&#39;s support for e-book generation.</p>
        <ul>
          <li>The result of a tree parsing operation is now a new type called <code>DocumentTreeRoot</code></li>
          <li>It has a <code>coverDocument</code> property and contains the recursive tree structure of the parsed content.</li>
          <li>Each <code>DocumentTree</code> in the structure now has an explicit <code>titleDocument: Option[Document]</code> property
          for more explicit content organization in e-books.</li>
          <li>Properties that previously held references to streams and other impure data had been
          removed from the pure content model (e.g. <code>DocumentTree.staticDocuments</code>).<br></li>
        </ul>      

      </div>
    </div>

  </div>

</body></html>
