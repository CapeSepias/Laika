<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li><a href="../table-of-contents.html">Table of Contents</a></li>
          <li class="nav-header">About Laika</li>
          <li><a href="../01-about-laika/01-features.html">Features</a></li>
          <li><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
          <li class="nav-header">Running Laika</li>
          <li><a href="01-sbt-plugin.html">sbt Plugin</a></li>
          <li class="active"><a href="#">Library API</a></li>
          <li><a href="03-configuration.html">Configuration</a></li>
          <li class="nav-header">Preparing Content</li>
          <li><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
          <li><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
          <li><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
          <li><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../04-customizing-laika/01-overview.html">Overview</a></li>
          <li><a href="../04-customizing-laika/03-creating-templates.html">Creating Templates</a></li>
          <li><a href="../04-customizing-laika/04-document-ast.html">The Document AST</a></li>
          <li><a href="../04-customizing-laika/05-ast-rewriting.html">AST Rewriting</a></li>
          <li><a href="../04-customizing-laika/06-overriding-renderers.html">Overriding Renderers</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../05-extending-laika/01-overview.html">Overview</a></li>
          <li><a href="../05-extending-laika/03-implementing-directives.html">Implementing Directives</a></li>
          <li><a href="../05-extending-laika/04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
          <li><a href="../05-extending-laika/06-adding-syntax-highlighters.html">Adding Syntax Highlighters</a></li>
          <li><a href="../05-extending-laika/07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
          <li class="nav-header">Sub-Modules</li>
          <li><a href="../06-sub-modules/02-laikas-parser-combinators.html">Laika&#39;s Parser Combinators</a></li>
          <li><a href="../06-sub-modules/03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
          <li class="nav-header">Reference</li>
          <li><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
          <li><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
          <li><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
          <li><a href="../07-reference/06-release-notes.html">Release Notes</a></li>
          <li><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <!--<li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>-->
          <!--<li><a href="http://planet42.org/">Demo App</a></li>-->
          <!--  
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          -->
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1 id="library-api" class="title">Library API</h1>
        </div>
        <p>Laika&#39;s API is fully referentially transparent, does not throw exceptions and
        avoids any kind of runtime reflection. Its core module is also available for Scala.js.
        The library only has a very limited number of dependencies and does not require the installation of any external tools.</p>
        <p>This chapter only covers the topics which are specific to using Laika without its sbt plugin, 
        while most other parts of the manual apply to both use cases, library and plugin.</p>
        
        <h2 id="dependencies" class="section">Dependencies</h2>
        <p>Which of the modules you need to add to the build depends on the functionality you intend to use.</p>
        <p>If you want to stick to pure transformations from string to string and don&#39;t need file or stream IO or
        any of the binary output formats like EPUB or PDF, you are fine with just using the <code>laika-core</code> module:</p>
        <pre><code class="nohighlight"><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.planet42&quot;</span><span> %% </span><span class="string-literal">&quot;laika-core&quot;</span><span> % </span><span class="string-literal">&quot;0.15.0&quot;</span><span> </span></code></pre>
        <p>This module is also 100% supported for Scala.js, so you can alternatively use the triple <code>%%%</code> syntax
        if you want to cross-build for Scala.js and the JVM:</p>
        <pre><code class="nohighlight"><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.planet42&quot;</span><span> %%% </span><span class="string-literal">&quot;laika-core&quot;</span><span> % </span><span class="string-literal">&quot;0.15.0&quot;</span><span> </span></code></pre>
        <p>If you want to add support for file and stream IO and/or output in the EPUB format, 
        you need to depend on the <code>laika-io</code> module instead:</p>
        <pre><code class="nohighlight"><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.planet42&quot;</span><span> %% </span><span class="string-literal">&quot;laika-io&quot;</span><span> % </span><span class="string-literal">&quot;0.15.0&quot;</span><span> </span></code></pre>
        <p>This depends on <code>laika-core</code> in turn, so you always only need to add one module as a dependency and will get
        the rest via transitive dependencies. No module apart from <code>laika-core</code> is available for Scala.js, so you
        are in JVM land here.</p>
        <p>Finally PDF support comes with its own module as it adds a whole range of additional dependencies:</p>
        <pre><code class="nohighlight"><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.planet42&quot;</span><span> %% </span><span class="string-literal">&quot;laika-pdf&quot;</span><span> % </span><span class="string-literal">&quot;0.15.0&quot;</span><span> </span></code></pre>
        <p>Again, this builds on top of the other modules, so adding just this one dependency is sufficient.</p>
        
        <h2 id="anatomy-of-the-api" class="section">Anatomy of the API</h2>
        <p>The library API for creating parsers, renderers or transformers, while aiming to be intuitive and simple, 
        also exposes one of the main design goals of Laika: that everything is meant to be pluggable.</p>
        <p>The following example for creating a pure transformer shows the main building blocks:</p>
        <p><img src="../img/anatomy-api.png" width="602px" alt="Anatomy of the API"></p>
        <ul>
          <li>
            <p>All inputs need to support the <code>MarkupFormat</code> contract.
            Supported by the core library are <code>Markdown</code> and <code>ReStructuredText</code>.</p>
          </li>
          <li>
            <p>Output formats implement the <code>RenderFormat[FMT]</code> trait.
            The type parameter represents the formatter API that renderer overrides for specific AST nodes can talk to,
            which is different depending on the format.
            The library supports the formats <code>HTML</code>, <code>EPUB</code>, <code>PDF</code>, <code>XSLFO</code> and <code>AST</code> out of the box.
            The latter is a debug output that renders the document AST in a formatted structure.</p>
          </li>
          <li>
            <p>Finally, the optional <code>using</code> hook in the API accepts anything that implements <code>ExtensionBundle</code>.
            This API has hooks for all phases of the transformation process, parsing, AST transformation and rendering
            and is Laika&#39;s main extension point.
            Shown above are <code>GitHubFlavor</code> and <code>SyntaxHighlighting</code>, two bundles provided by the library that can be enabled on demand. </p>
          </li>
        </ul>
        <p>If you require support for file/stream IO, templating or binary output formats, 
        the <code>laika-io</code> module expands on the core API to add this functionality:</p>
        <p><img src="../img/io-api.png" width="602px" alt="Anatomy of the IO API"></p>
        <p>The blue elements of the API are identical to the pure transformer.
        The new <code>io</code> method used above becomes available with <code>import laika.io.implicits._</code>.</p>
        <p>This API introduces a dependency on <code>cats-effect</code> which is used to model the effectful computations.
        You can use it with any effect that supports the <code>cats-effect</code> type classes, like cats-IO, Monix or Zio.</p>
        <ul>
          <li>
            <p>The blocker passed in the example gives you control over which <code>ExecutionContext</code> blocking IO is performed in.</p>
          </li>
          <li>
            <p>The call to <code>parallel[IO]</code> builds a transformer that lets you specify entire directories as input and allows to instruct
            the library which effect type to use (cats-IO in this example). There is a second variant, <code>sequential</code>, 
            that builds a transformer that accepts individual files, streams or strings as input and output.</p>
          </li>
        </ul>
        <p>Using a <code>Transformer</code> is the most convenient option when you want to go directly from the raw input format (text markup)
        to the final output format. There are also <code>Parser</code> and <code>Renderer</code> instances that only do one half of the transformation.</p>
        <p>All types, <code>Transformer</code>, <code>Parser</code> and <code>Renderer</code> come in three flavors each. 
        A simple, pure API for dealing with strings as input and output, 
        a sequential, effectful API for processing individual files and streams 
        and finally a parallel, effectful API for processing entire directories with templates and configuration files 
        in addition to the usual text markup input.</p>
        
        <h2 id="transforming-strings" class="section">Transforming Strings</h2>
        <p>Transforming in-memory input is the simplest form of transformation, and works for Markdown and reStructuredText 
        as input, and for HTML as output. EPUB and PDF both require additional modules and are described later in this chapter.</p>
        <p>For most cases where you don&#39;t use any of the customization hooks, you should be fine with just these imports:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">api</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">format</span><span>.</span><span class="identifier">_</span></code></pre>
        <p>As the next step you can then create transformer instances, which in most cases you&#39;ll want to reuse with different
        inputs to reduce the memory footprint and initialization overhead. 
        The instances are immutable and thread-safe.</p>
        <p>Example for creating a transformer for Markdown, including the GitHub-Flavor extensions:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        <p>Example for creating a transformer for reStructuredText:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">ReStructuredText</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        <p>In addition to specifying markup and output formats and extensions, there are many other customization options in the builder
        step immediately before calling <code>build</code>. They are identical for the pure and IO parser and are summarized in the <a href="#configuration">Configuration</a> section.</p>
        <p>Finally you can use the transformer with text markup as input:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">result</span><span> = </span><span class="identifier">transformer</span><span>.</span><span class="identifier">transform</span><span>(</span><span class="string-literal">&quot;hello *there*&quot;</span><span>)</span></code></pre>
        <p>The result is of type <code>Either[ParserError, String]</code>.</p>
        
        <h2 id="setup-for-effectful-transformations" class="section">Setup for Effectful Transformations</h2>
        <p>In case you want to go beyond pure string transformations, 
        you need to switch your dependency to the <code>laika-io</code> module as shown in the <a href="#dependencies">Dependencies</a> section.</p>
        <p>This module depends on cats-effect, and models all side effects in an abstract effect,
        so that you can use it with cats IO, Monix or Zio.</p>
        <p>With the dependency in place you also need to add a third import to those you used for pure transformations:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">api</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">format</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">io</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span></code></pre>
        <p>The remainder of the setup depends on whether you are <a href="#using-cats-io-monix-or-zio">Using cats.IO, Monix or Zio</a>
        or whether you build <a href="#applications-without-effect-library">Applications without Effect Library</a>.</p>
        
        <h3 id="using-cats-io-monix-or-zio" class="section">Using cats.IO, Monix or Zio</h3>
        <p>When your application is already using one of the effect libraries compatible with the cats-effect type class hierarchy,
        integrating Laika will be seamless. </p>
        <p>The exact mechanics of your Laika transformer setup will depend on which of the aforementioned libraries you are using 
        and whether you keep all of you code in an abstract <code>F[_]</code> instead of coding against a concrete effect type.</p>
        <p>The following example assumes the use case of an application written around abstract effect types and using <code>IOApp</code>
        from cats.IO for initialization:</p>
        <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">createTransformer</span><span>[</span><span class="type-name">F</span><span>[</span><span class="identifier">_</span><span>]: </span><span class="type-name">Async</span><span>: </span><span class="type-name">ContextShift</span><span>](</span><span class="identifier">blocker</span><span>: </span><span class="type-name">Blocker</span><span>): </span><span class="type-name">SequentialTransformer</span><span>[</span><span class="type-name">F</span><span>] =
  </span><span class="type-name">Transformer</span><span>
    .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
    .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
    .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
    .</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>)
    .</span><span class="identifier">sequential</span><span>[</span><span class="type-name">F</span><span>]
    .</span><span class="identifier">build</span></code></pre>
        <p>The setup method above can then be used inside <code>IOApp</code> initialization logic:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">MyApp</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">IOApp</span><span> {

  </span><span class="keyword">def</span><span> </span><span class="declaration-name">run</span><span>(</span><span class="identifier">args</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">String</span><span>]) = {
    </span><span class="type-name">Blocker</span><span>[</span><span class="type-name">IO</span><span>].</span><span class="identifier">use</span><span> { </span><span class="identifier">blocker</span><span> =&gt;
      </span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="identifier">createTransformer</span><span>[</span><span class="type-name">IO</span><span>](</span><span class="identifier">blocker</span><span>)
      </span><span class="comment">// other setup code
</span><span>    }.</span><span class="identifier">as</span><span>(</span><span class="type-name">ExitCode</span><span>.</span><span class="type-name">Success</span><span>)
  }
}</span></code></pre>
        <p>This way Laika gives full control over the <code>ExecutionContext</code> in which the blocking IO and CPU-bound operations are performed.</p>
        <p>Setup for other libraries would be similar, Monix for example comes with a <code>TaskApp</code> which is similar to <code>IOApp</code>.</p>
        
        <h3 id="applications-without-effect-library" class="section">Applications without Effect Library</h3>
        <p>When using other stacks like Akka HTTP or the Play framework, you need to bridge the gap between the worlds of
        cats-effect and the surrounding toolkit, often centering around the Future API (which, in contrast to cats-effect,
        is not referentially transparent).</p>
        <p>First, to create a transformer with the setup method created in the previous example, you need to create instances
        of <code>ContextShift</code> and <code>Blocker</code> yourself:</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">cs</span><span>: </span><span class="type-name">ContextShift</span><span>[</span><span class="type-name">IO</span><span>] = 
  </span><span class="type-name">IO</span><span>.</span><span class="identifier">contextShift</span><span>(</span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">global</span><span>)
  
</span><span class="keyword">val</span><span> </span><span class="identifier">blocker</span><span> = </span><span class="type-name">Blocker</span><span>.</span><span class="identifier">liftExecutionContext</span><span>(
  </span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">fromExecutor</span><span>(</span><span class="type-name">Executors</span><span>.</span><span class="identifier">newCachedThreadPool</span><span>())
)

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="identifier">createTransformer</span><span>(</span><span class="identifier">blocker</span><span>)</span></code></pre>
        <p>The resulting instance can then be used to describe a transformation: </p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">result</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromFile</span><span>(</span><span class="string-literal">&quot;hello.md&quot;</span><span>)
  .</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;hello.html&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        <p>The resulting <code>IO</code> instance is only a description of a program, as it starts evaluation lazily, 
        in contrast to the Scala SDK&#39;s <code>Future</code> which starts processing eagerly.</p>
        <p>For actually running the effect and producing a result,
        you have several options depending on the stack you are using.
        One common scenario is a toolkit like Akka HTTP or Play where you execute a route that is expected to return a <code>Future</code>.
        This can achieved by a simple translation:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">futureResult</span><span>: </span><span class="type-name">Future</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">result</span><span>.</span><span class="identifier">unsafeToFuture</span><span>()</span></code></pre>
        <p>Other options not involving <code>Future</code> are either blocking, synchronous execution:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">syncResult</span><span>: </span><span class="type-name">String</span><span> = </span><span class="identifier">result</span><span>.</span><span class="identifier">unsafeRunSync</span><span>()</span></code></pre>
        <p>Or asynchronous execution based on a callback:</p>
        <pre><code class="nohighlight"><span class="identifier">result</span><span>.</span><span class="identifier">unsafeRunAsync</span><span> {
  </span><span class="keyword">case</span><span> </span><span class="type-name">Left</span><span>(</span><span class="identifier">throwable</span><span>) =&gt; </span><span class="identifier">handleError</span><span>(</span><span class="identifier">throwable</span><span>)
  </span><span class="keyword">case</span><span> </span><span class="type-name">Right</span><span>(</span><span class="identifier">result</span><span>)   =&gt; </span><span class="identifier">handleResult</span><span>(</span><span class="identifier">result</span><span>)
}</span></code></pre>
        <p>Do not get too hung up on the scary sound of all these <code>unsync...</code> methods. The one kind of safety you are loosing
        when using them is referential transparency. But if you are using a <code>Future</code>-based API for example, 
        your program is not referentially transparent anyway.</p>
        
        <h2 id="file-and-stream-io" class="section">File and Stream IO</h2>
        <p>With transformer instances created by the setup shown in the previous section in place, 
        you can now transform the content of files:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">res</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromFile</span><span>(</span><span class="string-literal">&quot;hello.md&quot;</span><span>)
  .</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;hello.html&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        <p>Or use streams as input and output:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">input</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">InputStream</span><span>] = ???
</span><span class="keyword">val</span><span> </span><span class="identifier">output</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">InputStream</span><span>] = ???

</span><span class="keyword">val</span><span> </span><span class="identifier">res</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromStream</span><span>(</span><span class="identifier">input</span><span>)
  .</span><span class="identifier">toStream</span><span>(</span><span class="identifier">output</span><span>, </span><span class="identifier">autoClose</span><span> = </span><span class="boolean-literal">false</span><span>)
  .</span><span class="identifier">transform</span><span> </span></code></pre>
        <p>The API is similar to that for File IO, but the creation of the streams are treated as an effect, 
        so you have to pass an <code>F[InputStream]</code> or <code>F[OutputStream]</code>:</p>
        <p>The <code>autoClose</code> flag is <code>true</code> by default, 
        which means the stream will be closed after all input has been read or all output has been written.</p>
        <p>The previous two example both showed matching input and output types, but of course they can be freely combined.
        The last example shows an in-memory string as input and a file as output:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">res</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromString</span><span>(</span><span class="string-literal">&quot;hello *there*&quot;</span><span>)
  .</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;hello.html&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        
        <h2 id="entire-directories-as-input" class="section">Entire Directories as Input</h2>
        <p>The parallel, effectful transformer is the most powerful variant and also the one that is the basis for the sbt plugin.
        It expands the functionality beyond just processing markup files to also parsing templates and configuration files
        as well as copying static files over to the target directory.</p>
        <p>The setup is almost identical to the transformer for individual files or streams:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>)
  .</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>]
  .</span><span class="identifier">build</span></code></pre>
        <p>The only difference is switching from <code>sequential[IO]</code> to <code>parallel[IO]</code>. 
        This switch does not only cause a change in the internal execution model, 
        but also actually changes the API of the transformer. 
        The sequential API offers the <code>fromFile/toFile</code> or <code>fromStream/toStream</code> methods (amongst other options), 
        whereas the parallel API comes with the <code>fromDirectory/toDirectory</code> combination, 
        alongside other ways to transform multiple inputs in parallel.</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">res</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">RenderedTreeRoot</span><span>[</span><span class="type-name">IO</span><span>]] = </span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromDirectory</span><span>(</span><span class="string-literal">&quot;src&quot;</span><span>)
  .</span><span class="identifier">toDirectory</span><span>(</span><span class="string-literal">&quot;target&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        <p>The <code>target</code> directory is expected to exist, while any required subdirectories will be automatically created during rendering. 
        There will be one HTML file for each input file in the same directory layout.</p>
        <p>If you replace the <code>HTML</code> renderer in the example above with one of the binary formats (<code>EPUB</code> or <code>PDF</code>),
        the API will be slightly different, as the <code>toDirectory</code> option is replaced by <code>toFile</code>. 
        This is because these formats always produce a single binary result, 
        merging all content from the input directories into a single, linearized e-book:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">res</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromDirectory</span><span>(</span><span class="string-literal">&quot;src&quot;</span><span>)
  .</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;output.epub&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        
        <h3 id="merging-multiple-directories" class="section">Merging Multiple Directories</h3>
        <p>All previous examples read content from the single input directory. But you can also merge the contents of multiple directories:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">res</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">RenderedTreeRoot</span><span>[</span><span class="type-name">IO</span><span>]] = </span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromDirectories</span><span>(</span><span class="string-literal">&quot;markup&quot;</span><span>, </span><span class="string-literal">&quot;theme&quot;</span><span>)
  .</span><span class="identifier">toDirectory</span><span>(</span><span class="string-literal">&quot;target&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        <p>This adds some additional flexibility, as it allows, for example, to keep reusable styles and templates separately.
        This flexibility is possible as Laika is not tied to the file system, but instead provides a <a href="../03-preparing-content/01-directory-structure.html#virtual-tree-abstraction">Virtual Tree Abstraction</a>.</p>
        
        <h3 id="preparing-content" class="section">Preparing Content</h3>
        <p>Laika does not have any special directories and content can be nested in sub-directories down to arbitrary levels.
        For more details on how to organize content, see <a href="../03-preparing-content/01-directory-structure.html#directory-structure">Directory Structure</a>.</p>
        <p>Transformers and Parsers distinguish between the following file types:</p>
        <ul>
          <li><strong>Markup Files</strong>: Files with the extensions <code>.md</code>, <code>.markdown</code> or <code>.rst</code> (depending on the specified input format) 
          will be parsed and rendered to the target in the same directory structure and with the same file names apart from the suffix,
          which will be replaced depending on the output format (e.g. <code>.html</code>).</li>
          <li><strong>Configuration Files</strong>: Each directory can contain an optional <code>directory.conf</code> file for specifying
          things like navigation order or chapter title. See <a href="../03-preparing-content/01-directory-structure.html#configuration-files">Configuration Files</a> for details.</li>
          <li><strong>Template Files</strong>: You can provide a default template per directory with the name <code>default.template.&lt;suffix&gt;</code>
          with the suffix matching the output format (e.g. <code>.html</code>). 
          They will also be applied to sub-directories, unless overridden. 
          You can also add additional templates with the name pattern <code>*.template.&lt;suffix&gt;</code>, 
          which will only be applied when a markup document explicitly refers to them in its configuration header.
          (The upcoming 0.16 release will introduce Themes which will provide default templates out of the box. 
          Until then you need to provide at least one default template in the root directory unless you are fine with the
          very basic fallback template.)</li>
          <li><strong>Static Files</strong>: All other files, like CSS, JavaScript, images, etc., will be copied over to the 
          target in the same directory structure and with identical file names.</li>
        </ul>
        
        <h2 id="separate-parsing-and-rendering" class="section">Separate Parsing and Rendering</h2>
        <p>So far all examples in this chapter showed the use of a transformer instance, 
        which takes you all the way from a raw input file to the target format, e.g. from Markdown to HTML.</p>
        <p>But in some cases you may just want to execute one half of the process:</p>
        <ul>
          <li>
            <p>If the input is generated in-memory. In this case there is no need to generate text markup, you can directly
            produce the document AST and pass it to a <code>Renderer</code>.</p>
          </li>
          <li>
            <p>If you want to process the document AST produced by a <code>Parser</code> by other means than rendering one of the supported
            output formats.</p>
          </li>
          <li>
            <p>If you want to render the same input to multiple output formats. 
            In this case building a <code>Transformer</code> for all output formats is inefficient as each of them would parse the same input again. 
            Instead you can create a single <code>Parser</code> for the input and in addition one <code>Renderer</code> for each output format you want to generate.</p>
          </li>
        </ul>
        <p>In fact if you examine the implementations of the various pure and effectful transformer types, you&#39;ll notice that
        it is mostly trivial: delegating to the underlying <code>Parser</code> and <code>Renderer</code> and just piping the result from one to the other.</p>
        <p>The following code example demonstrates the third scenario listed above: Rendering the same input to multiple output formats.</p>
        <p>First we create a parser that reads from a directory:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="type-name">MarkupParser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>)
  .</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>]
  .</span><span class="identifier">build</span></code></pre>
        <p>Next we create the renderers for the three output formats:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">htmlRenderer</span><span> = </span><span class="type-name">Renderer</span><span>.</span><span class="identifier">of</span><span>(</span><span class="type-name">HTML</span><span>).</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>).</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>].</span><span class="identifier">build</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">epubRenderer</span><span> = </span><span class="type-name">Renderer</span><span>.</span><span class="identifier">of</span><span>(</span><span class="type-name">EPUB</span><span>).</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>).</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>].</span><span class="identifier">build</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">pdfRenderer</span><span>  = </span><span class="type-name">Renderer</span><span>.</span><span class="identifier">of</span><span>(</span><span class="type-name">PDF</span><span>).</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>).</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>].</span><span class="identifier">build</span></code></pre>
        <p>Finally we define the actual transformation by wiring the parser and the three renderers:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformOp</span><span>: </span><span class="type-name">IO</span><span>[</span><span class="type-name">Unit</span><span>] = 
  </span><span class="identifier">parser</span><span>.</span><span class="identifier">fromDirectory</span><span>(</span><span class="string-literal">&quot;source&quot;</span><span>).</span><span class="identifier">parse</span><span>.</span><span class="identifier">flatMap</span><span> { </span><span class="identifier">tree</span><span> =&gt;
    </span><span class="keyword">val</span><span> </span><span class="identifier">htmlOp</span><span> = </span><span class="identifier">htmlRenderer</span><span>.</span><span class="identifier">from</span><span>(</span><span class="identifier">tree</span><span>).</span><span class="identifier">toDirectory</span><span>(</span><span class="string-literal">&quot;target&quot;</span><span>).</span><span class="identifier">render</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">epubOp</span><span> = </span><span class="identifier">epubRenderer</span><span>.</span><span class="identifier">from</span><span>(</span><span class="identifier">tree</span><span>).</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;out.epub&quot;</span><span>).</span><span class="identifier">render</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">pdfOp</span><span> = </span><span class="identifier">pdfRenderer</span><span>.</span><span class="identifier">from</span><span>(</span><span class="identifier">tree</span><span>).</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;out.pdf&quot;</span><span>).</span><span class="identifier">render</span><span>
    (</span><span class="identifier">htmlOp</span><span>, </span><span class="identifier">epubOp</span><span>, </span><span class="identifier">pdfOp</span><span>).</span><span class="identifier">parMapN</span><span> { (</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) =&gt; () }
  }</span></code></pre>
        <p>We are using cats&#39; <code>parMapN</code> here to run the three renderers in parallel.</p>
        <p>The <code>tree</code> instance passed to all renderers is of type <code>DocumentTreeRoot</code>. 
        If necessary you can use its API to inspect or transform the tree before rendering.
        See <a href="../04-customizing-laika/04-document-ast.html#the-document-ast">The Document AST</a> for details.</p>
        <p>The sample code in this scenario showed the parallel-effectful variant of the <code>Parser</code> and <code>Renderer</code> types,
        but just as the <code>Transformer</code> they exist in the other two flavors as well: sequential-effectful and pure.</p>
        
        <h2 id="configuration" class="section">Configuration</h2>
        <p>All the examples in this chapter only scratched the surface of Laika&#39;s API, 
        focusing on the basics like specifying input and output. 
        But since Laika is designed to be fully customizable and serve as a toolkit for creating toolkits, there is whole
        range of options available for customizing and extending its built-in functionality.</p>
        <p>Most oof these configuration options are not specific to the library API use case and apply to the sbt plugin as well,
        apart from differences in the syntax/mechanics which with they are applied, which are reflected in the corresponding code examples.
        For this reason this section only gives a very brief overview while linking to the relevant sections in the other chapters.</p>
        <ul>
          <li>
            <p><a href="03-configuration.html#strict-mode">Strict mode</a>: Disables all non-standard extensions Laika adds to the supported markup formats, like directives.</p>
          </li>
          <li>
            <p><a href="03-configuration.html#raw-content">Raw Content</a>: Enables the inclusion of raw sections of the target format in markup files, 
            e.g. snippets of verbatim HTML embedded in Markdown files. By default this is disabled.</p>
          </li>
          <li>
            <p><a href="03-configuration.html#character-encoding">Character Encoding</a>: Sets the character encoding of input and output files, the default is UTF-8.</p>
          </li>
          <li>
            <p><a href="03-configuration.html#error-handling">Error Handling</a>: Specify log levels or switch to &quot;visual debugging&quot;, where recoverable errors are
            rendered in the page context where they occur instead of causing the transformation to fail.</p>
          </li>
          <li>
            <p><strong>Laika Extensions</strong>: Use the library&#39;s customization options to override renderers for specific AST nodes (<a href="../04-customizing-laika/06-overriding-renderers.html#overriding-renderers">Overriding Renderers</a>),
            transform the document AST before rendering (<a href="../04-customizing-laika/05-ast-rewriting.html#ast-rewriting">AST Rewriting</a>), install custom directives (<a href="../05-extending-laika/03-implementing-directives.html#implementing-directives">Implementing Directives</a>)
            or use some of the lower level hooks in (<a href="../05-extending-laika/01-overview.html#the-extensionbundle-api">The ExtensionBundle API</a>).</p>
          </li>
          <li>
            <p><strong>Basic Configuration Options</strong>: Setting <a href="03-configuration.html#strict-mode">Strict Mode</a>, including <a href="03-configuration.html#raw-content">Raw Content</a>, setting the <a href="03-configuration.html#character-encoding">Character Encoding</a>, 
            controlling <a href="03-configuration.html#error-handling">Error Handling</a> and specifying <a href="03-configuration.html#user-defined-variables">User-Defined Variables</a>. </p>
          </li>
          <li>
            <p><a href="01-sbt-plugin.html#inspecting-laika-s-configuration">Inspecting Laika&#39;s Configuration</a>: Run the <code>describe</code> method on the IO-based transformers, parsers and renderers 
            to get a formatted summary of the active configuration, installed extension bundles and lists of input and output files.</p>
          </li>
        </ul>

      </div>
    </div>

  </div>

</body></html>
