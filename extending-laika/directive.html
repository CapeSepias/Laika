<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using the Library API</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li><a href="../using-laika/syntax.html">Syntax Highlighting</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li class="active"><a href="#">Directives</a></li>
          <li><a href="parser.html">Parsers</a></li>
          <li><a href="renderer.html">Renderers</a></li>
          <li><a href="extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1>Directives</h1>
        </div>
        <p>Directives are Laika&#39;s extension hook for both, templates and text markup.
        They allow to add new tag-like constructs without touching the existing parsers.</p>
        <p>Each directive expects a configurable combination of attributes or body elements,
        where some of them may be required, while others may be optional. Laika takes care
        of parsing and validating these directive parts based on your declarations
        and then passes these values to your directive function (in a type-safe way)
        that produces a node element to add to the document tree result.</p>
        
        <h2 id="directive-types" class="section">Directive Types</h2>
        <p>Due to subtle differences in the node types they produce, there is a
        distinction between three directive types:</p>
        <ul>
          <li>Template directives, which produce <code>TemplateSpan</code> elements (or alternatively simple strings
          if you do not mind that your directive can only be used with one output format)</li>
          <li>Directives for block elements in markup, which produce <code>Block</code> elements</li>
          <li>Directives for inline elements in markup, which produce <code>Span</code> elements</li>
        </ul>
        <p>If you want to create a directive that can be used in all three locations
        you can usually easily reuse parts of your logic. If your directive version
        for inline elements generates a simple <code>ExternalLink</code> node for example,
        you can simply wrap that same node in a <code>Paragraph</code> node for a block-level 
        directive.</p>
        
        <h2 id="directive-syntax" class="section">Directive Syntax</h2>
        <p>A very minimal example is the <code>toc</code> directive for inserting a table of contents.
        Since all its attributes are optional, it can simply be used like this:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">toc</span></code></pre>
        <p>A directive always starts with <code>@:</code> followed by the name of the directive.</p>
        <p>A more complete example is the use of the <code>for</code> directive:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">for</span><span> { </span><span class="string-literal">some.list.of.products</span><span> }
</span><span class="tag-punctuation">&lt;</span><span class="tag-name">li</span><span class="tag-punctuation">&gt;&lt;</span><span class="tag-name">a</span><span class="tag-punctuation"> </span><span class="attribute-name">href</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;#</span><span class="substitution">${_.id}</span><span class="string-literal">&quot;</span><span class="tag-punctuation">&gt;</span><span class="substitution">${_.description}</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">a</span><span class="tag-punctuation">&gt;&lt;/</span><span class="tag-name">li</span><span class="tag-punctuation">&gt;</span><span>
</span><span class="keyword">@:@</span><span> </span></code></pre>
        <p>Here <code>for</code> is the name of the directive, <code>some.list.of.products</code> is an unnamed
        attribute (where in this case the value is interpreted as a variable reference,
        a path the user has defined in the configuration),
        and finally the body of the directive followed by the <code>@:@</code> fence. </p>
        
        <h2 id="example-implementation" class="section">Example Implementation</h2>
        <p>You can browse the source of the built-in directives here: <a href="https://github.com/planet42/Laika/blob/master/core/src/main/scala/laika/directive/StandardDirectives.scala">directive-api</a>
        But the logic required for the <code>toc</code> or <code>for</code> directives is probably much 
        more complicated than what you would usually do for a little custom
        helper tag that you need to unclutter your templates.</p>
        <p>Therefore we&#39;ll show and explain a very simple example here that
        should be sufficient to get you started.</p>
        <p>Our <code>ticket</code> directive constructs an external link to our
        bugtracker. Since the base URL is always the same, we want to
        only write:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">ticket</span><span> {</span><span class="number-literal">456</span><span>}</span></code></pre>
        <p>to get the output:</p>
        <pre><code class="nohighlight"><span class="tag-punctuation">&lt;</span><span class="tag-name">a</span><span class="tag-punctuation"> </span><span class="attribute-name">href</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;http://tickets.cloud42.com/main-project/456&quot;</span><span class="tag-punctuation">&gt;</span><span>#456</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">a</span><span class="tag-punctuation">&gt;</span></code></pre>
        <p>Or optionally specify a different project than the main one:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">ticket</span><span> {</span><span class="number-literal">456</span><span>, </span><span class="attribute-name">project</span><span>=</span><span class="string-literal">pineapple</span><span>}</span></code></pre>
        <p>to get the output:</p>
        <pre><code class="nohighlight"><span class="tag-punctuation">&lt;</span><span class="tag-name">a</span><span class="tag-punctuation"> </span><span class="attribute-name">href</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;http://tickets.cloud42.com/pineapple/456&quot;</span><span class="tag-punctuation">&gt;</span><span>#456</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">a</span><span class="tag-punctuation">&gt;</span></code></pre>
        <p>The following sections explain how to implement the tag
        and then how to add it either to the Markdown or reStructuredText
        parser or to the template parser.</p>
        
        <h3 id="directive-implementation" class="section">Directive Implementation</h3>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;ticket&quot;</span><span>) {
  </span><span class="keyword">val</span><span> </span><span class="identifier">ticketAttr</span><span> = </span><span class="identifier">defaultAttribute</span><span>.</span><span class="identifier">as</span><span>[</span><span class="type-name">String</span><span>]
  </span><span class="keyword">val</span><span> </span><span class="identifier">projectAttr</span><span> = </span><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;project&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">String</span><span>].</span><span class="identifier">optional</span><span>
  (</span><span class="identifier">ticketAttr</span><span>, </span><span class="identifier">projectAttr</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">ticketNo</span><span>, </span><span class="identifier">project</span><span>) =&gt; 
    </span><span class="keyword">val</span><span> </span><span class="identifier">base</span><span> = </span><span class="string-literal">&quot;http://tickets.cloud42.com/&quot;</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">url</span><span> = </span><span class="identifier">base</span><span> + </span><span class="identifier">project</span><span>.</span><span class="identifier">getOrElse</span><span>(</span><span class="string-literal">&quot;main-project&quot;</span><span>) + </span><span class="string-literal">&quot;/&quot;</span><span> + </span><span class="identifier">ticketNo</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">linkText</span><span> = </span><span class="type-name">Seq</span><span>(</span><span class="type-name">Text</span><span>(</span><span class="string-literal">&quot;#&quot;</span><span>+</span><span class="identifier">ticketNo</span><span>))
    </span><span class="type-name">ExternalLink</span><span>(</span><span class="identifier">linkText</span><span>, </span><span class="identifier">url</span><span>, </span><span class="identifier">options</span><span> = </span><span class="type-name">Styles</span><span>(</span><span class="string-literal">&quot;ticket&quot;</span><span>))
  }
}</span></code></pre>
        <p>Let&#39;s examine the code:</p>
        <p>With <code>Spans.create(&quot;ticket&quot;)</code> we specify the name of the directive (<code>ticket</code>)
        which is also the name we are going to use in markup files (<code>@:ticket</code>).</p>
        <p>The <code>Spans</code> object let&#39;s us create a directive for an inline element
        as that has a different node type as the final result of the directive 
        and the API is typesafe. For block level markup directives you&#39;d use
        the <code>Blocks</code> object, for template directives the <code>Templates</code> object.
        The features and APIs are identical, but there are subtle differences
        in return types.</p>
        <p>With <code>defaultAttribute.as[String]</code> we specify that we expect a default (unnamed)
        attribute which is required. When a required attribute is missing
        our directive function will never be invoked. Instead Laika inserts
        a node of type <code>InvalidSpan</code> into the document tree (which we may
        then choose to render or not).</p>
        <p>With <code>attribute(&quot;project&quot;).as[String].optional</code> we specify that we expect an
        attribute with the name <code>project</code> which is optional. In case it is 
        missing our directive function will still be invoked.</p>
        <p><code>(ticketNo, project)</code> are the parameters that the parser will pass
        to our function after parsing and validating the directive. They
        have a type corresponding to our configuration. <code>ticketNo</code> is of
        type <code>String</code> (you can also specify converters to other types, but
        that is not needed here). <code>project</code> is of type <code>Option[String]</code> since
        we declared it as optional.</p>
        <p>The rest is just plain Scala code. The result is of type <code>ExternalLink</code>
        which is one type of Laika&#39;s rich tree model. It mixes in the <code>Span</code>
        trait and thus satisfies the requirement of an inline directive.</p>
        
        <h3 id="directive-registration" class="section">Directive Registration</h3>
        <p>Finally all we need to do is register our directive before parsing.
        All the examples below refer to the <code>directive</code> variable we declared
        in the example in the previous section.</p>
        <p><strong>sbt Plugin</strong>:</p>
        <pre><code class="nohighlight"><span class="identifier">laikaSpanDirectives</span><span> += </span><span class="identifier">directive</span></code></pre>
        <p>This registers the directive for both Markdown and reStructuredText
        parsers. </p>
        <p>The directive implementation itself usually requires some
        amount of logic, so is usually best kept separately in a <code>.scala</code>
        file in the <code>project</code> directory and then referenced from your
        <code>build.sbt</code>. Reusable directives are best packaged as a library
        and then added as a dependency of your build.</p>
        <p><strong>Library API</strong>:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">MyDirectives</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">DirectiveRegistry</span><span> {
  </span><span class="keyword">val</span><span> </span><span class="identifier">spanDirectives</span><span> = </span><span class="type-name">Seq</span><span>(</span><span class="identifier">directive</span><span>)
  </span><span class="keyword">val</span><span> </span><span class="identifier">blockDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
  </span><span class="keyword">val</span><span> </span><span class="identifier">templateDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
}

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        <p>The <code>directive</code> variable refers to the instance we created above.
        We can now use our <code>ticket</code> directive in Markdown files!</p>
        <p><strong>Templates</strong>:</p>
        <p>When you also want to use the directive in templates you need to create
        a very similar declaration like the one above, just starting with <code>Templates.create</code>
        instead and wrapping the <code>ExternalLink</code> node in a <code>TemplateElement</code>. You can extract
        the rest of the logic into a shared function.</p>
        <p>Therefore the type of the variable <code>directive</code> is <code>Templates.Directive</code>, and not
        <code>Spans.Directive</code> like in the previous examples.</p>
        
        <h2 id="api-reference" class="section">API Reference</h2>
        <p>The example implementation only showed a few options for declaring the
        expected parts of your directive. Even though there is full scaladoc
        for the API, the combinators and converters are a bit scattered over
        different objects, so we assemble them here for easier reference.</p>
        
        <h3 id="default-attributes" class="section">Default Attributes</h3>
        <p>A default attribute is an attribute without a name. 
        It has to be the first attribute before any named attributes.
        It allows for more concise syntax in all the cases where usually only one
        attribute is used and its meaning is obvious.</p>
        <p>Markup example:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">name</span><span> { </span><span class="string-literal">arg</span><span> }</span></code></pre>
        <p>Combinator:</p>
        <pre><code class="nohighlight"><span class="identifier">defaultAttribute</span></code></pre>
        
        <h3 id="named-attributes" class="section">Named Attributes</h3>
        <p>A named attribute can appear after the default attribute or right
        after the directory name in case there is no default attribute.
        The order of attributes does not matter, it does not need to match
        the order you declared them in (that&#39;s why they have names after all).</p>
        <p>The syntax for attributes is HOCON and it supports the full spec except
        for file includes.</p>
        <p>Markup example:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">name</span><span> { </span><span class="attribute-name">myAttr</span><span>=</span><span class="string-literal">value</span><span> }</span></code></pre>
        <p>Combinator:</p>
        <pre><code class="nohighlight"><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;myAttr&quot;</span><span>)</span></code></pre>
        
        <h3 id="all-attributes" class="section">All Attributes</h3>
        <p>If you want the full flexibility of accepting any kind of attribute without
        knowing the expected names upfront, you can use the <code>allAttributes</code> combinator.</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;custom&quot;</span><span>) {
  (</span><span class="identifier">allAttributes</span><span>, </span><span class="identifier">body</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">attributes</span><span>, </span><span class="identifier">bodyContent</span><span>) =&gt; 
    </span><span class="keyword">val</span><span> </span><span class="identifier">path</span><span> = </span><span class="identifier">attributes</span><span>.</span><span class="identifier">getOpt</span><span>[</span><span class="type-name">Path</span><span>](</span><span class="string-literal">&quot;filePath&quot;</span><span>)
    </span><span class="keyword">val</span><span> </span><span class="identifier">index</span><span> = </span><span class="identifier">attributes</span><span>.</span><span class="identifier">getOpt</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="string-literal">&quot;index&quot;</span><span>)
    ...
  }
}</span></code></pre>
        <p>This combinator gives you an instance of <code>Config</code> as a result, Laika&#39;s configuration API, 
        and you can manually inspect the values it contains. This naturally leaves the burden
        of validation and error handling (e.g. for required values or type conversions)
        with the implementor of the directive. It should therefore only be used when
        this level of flexibility is really required.</p>
        
        <h3 id="body" class="section">Body</h3>
        <p>The body is an element containing text markup that can follow the attribute section. </p>
        <p>Markup example:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">name</span><span>

this is the content of the body 

</span><span class="keyword">@:@</span></code></pre>
        <p>Example with a custom fence:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">name</span><span> { </span><span class="attribute-name">foo</span><span>=</span><span class="string-literal">bar</span><span> } ^^^

this is the content of the body 

^^^</span></code></pre>
        <p>A custom fence is only supported for block directives and can be used for disambiguation
        in case of nesting a directive inside another. It has to consist of exactly 3 characters
        on the same line right after the directive declaration. </p>
        <p>For span and template directives this
        is not necessary as the parser can figure the nesting hierarchy on its own.</p>
        <p>The type of the result this combinator will produce depends on the type of the directive:
        In a template directive it is <code>Seq[TemplateSpan]</code>, in a block directive it is <code>Seq[Block]</code>,
        and finally, in a span directive it is <code>Seq[Span]</code>. </p>
        <p>Combinator:</p>
        <pre><code class="nohighlight"><span class="identifier">parsedBody</span></code></pre>
        <p>There is an alternative combinator if you need the raw, unparsed body as a String:</p>
        <pre><code class="nohighlight"><span class="identifier">rawBody</span><span>    </span></code></pre>
        
        <h3 id="separated-body" class="section">Separated Body</h3>
        <p>A separated body element is divided into multiple sub-sections by a special kind of directive,
        called a separator directive. It is a fairly advanced feature and probably not something you&#39;d
        need often. </p>
        <p>For an example from the built-in standard directives, let&#39;s have a look at the <code>@:if</code> directive:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">if</span><span> { </span><span class="string-literal">showSidebar</span><span> }
</span><span class="tag-punctuation">&lt;</span><span class="tag-name">div</span><span class="tag-punctuation"> </span><span class="attribute-name">class</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;sidebar&quot;</span><span class="tag-punctuation">&gt;</span><span>...</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">div</span><span class="tag-punctuation">&gt;</span><span>

</span><span class="keyword">@:</span><span class="identifier">elseIf</span><span> { </span><span class="string-literal">showInfobox</span><span> }
</span><span class="tag-punctuation">&lt;</span><span class="tag-name">div</span><span class="tag-punctuation"> </span><span class="attribute-name">class</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;infobox&quot;</span><span class="tag-punctuation">&gt;</span><span>...</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">div</span><span class="tag-punctuation">&gt;</span><span>

</span><span class="keyword">@:</span><span class="identifier">else</span><span>
</span><span class="tag-punctuation">&lt;</span><span class="tag-name">p</span><span class="tag-punctuation">&gt;</span><span>This document does not have any sections</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">p</span><span class="tag-punctuation">&gt;</span><span>

</span><span class="keyword">@:@</span></code></pre>
        <p>The root <code>@if</code> directive is the parent directive in this case, and both the <code>@:elseIf</code> and <code>@:else</code>
        directives are separator directives that partition the body. Separator directives are different
        than normal directives in that they do not need to produce an AST element (e.g. <code>Block</code> or <code>Span</code>)
        as they will be passed to the parent directive for processing which then will produce the target AST element.</p>
        <p>If you want to see a full example of such a directive, have a look at the implementation of the <code>@:if</code> directive
        in the <code>StandardDirectives</code> source.</p>
        <p>In this section we&#39;ll just show a very small, contrived example. Declaring a separator directive looks just
        like declaring a normal directive, only that you call <code>separator</code> instead of <code>create</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Child</span><span> (</span><span class="identifier">content</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">Span</span><span>])

</span><span class="keyword">val</span><span> </span><span class="identifier">sepDir</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">separator</span><span>(</span><span class="string-literal">&quot;child&quot;</span><span>, </span><span class="identifier">min</span><span> = </span><span class="number-literal">1</span><span>) { </span><span class="identifier">body</span><span> </span><span class="identifier">map</span><span> </span><span class="type-name">Foo</span><span> }   </span></code></pre>
        <p>Here you specify the name of the directive <code>@:child</code>, as well as that it has to be present in 
        the body at least once. Then you use the regular combinators to declare the expected directive
        parts, in this case only a body that you map to the <code>Child</code> type.</p>
        <p>Now you can use this directive in the parent:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;parent&quot;</span><span>) { 
  </span><span class="identifier">separatedBody</span><span>(</span><span class="type-name">Seq</span><span>(</span><span class="identifier">sepDir</span><span>)) </span><span class="identifier">map</span><span> { </span><span class="identifier">multipart</span><span> =&gt;
    </span><span class="keyword">val</span><span> </span><span class="identifier">seps</span><span> = </span><span class="identifier">multipart</span><span>.</span><span class="identifier">children</span><span>.</span><span class="identifier">flatMap</span><span> { </span><span class="identifier">sep</span><span> =&gt; 
      </span><span class="type-name">Text</span><span>(</span><span class="string-literal">&quot;Child: &quot;</span><span>) +: </span><span class="identifier">sep</span><span>.</span><span class="identifier">content</span><span> 
    }
    </span><span class="type-name">SpanSequence</span><span>(</span><span class="identifier">multipart</span><span>.</span><span class="identifier">mainBody</span><span> ++ </span><span class="identifier">seps</span><span>)
  }
}</span></code></pre>
        <p>You can use the <code>separatedBody</code> combinator where you pass all expected child directives (in this
        case only one) and then map the resulting <code>Multipart</code> instance to an AST element. The <code>Multipart</code>
        gives you access to the main body as well as all processed separator directives in <code>multipart.children</code>.</p>
        <p>This entire directive can then be used like this:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">parent</span><span>
This is the main body

</span><span class="keyword">@:</span><span class="identifier">child</span><span>
This is the body of the separator

</span><span class="keyword">@:@</span></code></pre>
        
        <h3 id="optional-elements" class="section">Optional Elements</h3>
        <p>Default and named attributes can be marked as optional.</p>
        <p>Combinator:</p>
        <pre><code class="nohighlight"><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;width&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">optional</span></code></pre>
        <p>The parameter type of your directive function changes accordingly,
        from <code>T</code> to <code>Option[T]</code> where <code>T</code> is either the type returned by
        your converter (see below) or the default type.</p>
        
        <h3 id="inherited-elements" class="section">Inherited Elements</h3>
        <p>By default directives only accept attributes defined right in the
        attribute section of the directive to avoid name clashes with attributes
        in other scopes. If you want to explicitly enable inheritance, so that
        a user can define default values for attributes either in the configuration
        header of the markup or template files or in the <code>directory.conf</code> file,
        you can set the <code>inherited</code> flag:</p>
        <p>Combinator:</p>
        <pre><code class="nohighlight"><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;width&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">inherited</span></code></pre>
        <p>With this flag set, the <code>width</code> attribute can be inherited from other scopes
        if it is not defined in the directive itself.</p>
        
        <h3 id="decoders" class="section">Decoders</h3>
        <p>You can specify a decoder for all attributes with the <code>as[T]</code>
        method:</p>
        <pre><code class="nohighlight"><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;depth&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">optional</span></code></pre>
        <p>Without a decoder the result type would be <code>ConfigValue</code>
        which is a data structure similar to those of popular JSON libraries.
        But that type is rarely the most convenient type, which is why
        Laika defines some basic decoders out of the box, for <code>String</code>,
        <code>Int</code>, <code>Double</code>, <code>Boolean</code> and <code>Path</code>.</p>
        <p>You can define your own by implementing <code>ConfigDecoder[T]</code>.</p>
        
        <h3 id="access-to-the-parser" class="section">Access to the Parser</h3>
        <p>For block elements the default is to pre-parse the content for you,
        so there is rarely a need to parse something yourself. But if you need to,
        it wouldn&#39;t be a good idea to instantiate your own parser. Because it
        would not have access to any of the directives or other configuration
        options active for this operation (unless you manually duplicate it which
        is brittle). Therefore you can request a parser for your function in 
        addition to the other values:</p>
        <pre><code class="nohighlight"><span>(</span><span class="identifier">defaultAttribute</span><span>, </span><span class="identifier">parser</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">attrValue</span><span>, </span><span class="identifier">parser</span><span>) =&gt;
  </span><span class="keyword">val</span><span> </span><span class="identifier">parsedSpans</span><span> = </span><span class="identifier">parser</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span>+</span><span class="identifier">attrValue</span><span>+</span><span class="string-literal">&quot;]&quot;</span><span>)
  </span><span class="type-name">SpanSequence</span><span>(</span><span class="identifier">parsedSpans</span><span>)
}</span></code></pre>
        <p>In this contrived example the attribute value is modified before being passed
        to the parser and then wrapped inside a sequence.</p>
        
        <h3 id="access-to-the-document-cursor" class="section">Access to the Document Cursor</h3>
        <p>Finally you can also request access to the document context. This gives
        you access to the structure, the title, sections and parent and root
        trees, in short, the full API for the AST built by the parser.</p>
        <p>It is, for example, required for a directive like the <code>toc</code> directive,
        because for building a table of contents you have to look beyond your
        particular directive node.</p>
        <pre><code class="nohighlight"><span>(</span><span class="identifier">defaultAttribute</span><span>, </span><span class="identifier">cursor</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">attrValue</span><span>, </span><span class="identifier">cursor</span><span>) =&gt;
  </span><span class="keyword">val</span><span> </span><span class="identifier">spans</span><span> = </span><span class="type-name">Text</span><span>(</span><span class="string-literal">&quot;The title is: &quot;</span><span>) +: </span><span class="identifier">cursor</span><span>.</span><span class="identifier">target</span><span>.</span><span class="identifier">title</span><span>
  </span><span class="type-name">SpanSequence</span><span>(</span><span class="identifier">spans</span><span>)
}</span></code></pre>
        
        <h3 id="differences-between-directive-types" class="section">Differences between Directive Types</h3>
        <p><a href="#directive-types">Directive Types</a> already gave a quick overview over the available types.
        The sections <a href="#directive-implementation">Directive Implementation</a> and <a href="#directive-registration">Directive Registration</a> showed
        a simple example for a span directive. Since there are three different directive
        types and different ways to register them depending on whether you use the 
        sbt plugin or Laika embedded, this section gives a final overview over the
        API differences.</p>
        
        <h3 id="span-directives" class="section">Span Directives</h3>
        <p>Use: in inline elements in text markup files</p>
        <p>Implementation:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">directive</span><span>.</span><span class="type-name">Spans</span><span>
</span><span class="keyword">import</span><span> </span><span class="type-name">Spans</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;name&quot;</span><span>) {
  </span><span class="comment">// implementation producing a `Span` element
</span><span>}    </span></code></pre>
        <p>Registration:</p>
        <pre><code class="nohighlight"><span class="comment">// for Markdown and reStructuredText with sbt plugin:
</span><span class="identifier">laikaSpanDirectives</span><span> += </span><span class="identifier">directive</span><span> </span><span class="comment">// in build.sbt
</span><span>
</span><span class="comment">// for Markdown and reStructuredText with Transformer or Parser API:
</span><span class="keyword">object</span><span> </span><span class="type-name">MyDirectives</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">DirectiveRegistry</span><span> {
  </span><span class="keyword">val</span><span> </span><span class="identifier">spanDirectives</span><span> = </span><span class="type-name">Seq</span><span>(</span><span class="identifier">directive</span><span>)
  </span><span class="keyword">val</span><span> </span><span class="identifier">blockDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
  </span><span class="keyword">val</span><span> </span><span class="identifier">templateDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
}

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="type-name">Parser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span><span>    </span></code></pre>
        
        <h3 id="block-directives" class="section">Block Directives</h3>
        <p>Use: in block elements in text markup files</p>
        <p>Implementation:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">directive</span><span>.</span><span class="type-name">Blocks</span><span>
</span><span class="keyword">import</span><span> </span><span class="type-name">Blocks</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Blocks</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;name&quot;</span><span>) {
  </span><span class="comment">// implementation producing a `Block` element
</span><span>}</span></code></pre>
        <p>Registration:</p>
        <pre><code class="nohighlight"><span class="comment">// for Markdown and reStructuredText with sbt plugin:
</span><span class="identifier">laikaBlockDirectives</span><span> += </span><span class="identifier">directive</span><span> </span><span class="comment">// in build.sbt
</span><span>
</span><span class="comment">// for Markdown and reStructuredText with Transformer or Parser API:
</span><span class="keyword">object</span><span> </span><span class="type-name">MyDirectives</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">DirectiveRegistry</span><span> {
  </span><span class="keyword">val</span><span> </span><span class="identifier">spanDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
  </span><span class="keyword">val</span><span> </span><span class="identifier">blockDirectives</span><span> = </span><span class="type-name">Seq</span><span>(</span><span class="identifier">directive</span><span>)
  </span><span class="keyword">val</span><span> </span><span class="identifier">templateDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
}

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="type-name">Parser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span><span>    </span></code></pre>
        
        <h3 id="template-directives" class="section">Template Directives</h3>
        <p>Use: in template files</p>
        <p>Implementation:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">laika</span><span>.</span><span class="identifier">directive</span><span>.</span><span class="type-name">Templates</span><span>
</span><span class="type-name">Templates</span><span> </span><span class="type-name">Blocks</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Templates</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;name&quot;</span><span>) {
  </span><span class="comment">// implementation producing a `TemplateSpan` element
</span><span>}    </span></code></pre>
        <p>Registration:</p>
        <pre><code class="nohighlight"><span class="comment">// for templates with sbt plugin:
</span><span class="identifier">laikaTemplateDirectives</span><span> += </span><span class="identifier">directive</span><span> </span><span class="comment">// in build.sbt
</span><span>
</span><span class="comment">// for Markdown and reStructuredText with Transformer or Parser API:
</span><span class="keyword">object</span><span> </span><span class="type-name">MyDirectives</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">DirectiveRegistry</span><span> {
  </span><span class="keyword">val</span><span> </span><span class="identifier">spanDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
  </span><span class="keyword">val</span><span> </span><span class="identifier">blockDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
  </span><span class="keyword">val</span><span> </span><span class="identifier">templateDirectives</span><span> = </span><span class="type-name">Seq</span><span>(</span><span class="identifier">directive</span><span>)
}

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="type-name">Parser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span><span>    </span></code></pre>      

      </div>
    </div>

  </div>

</body></html>
