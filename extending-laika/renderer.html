<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using the Library API</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="directive.html">Directives</a></li>
          <li><a href="parser.html">Parsers</a></li>
          <li class="active"><a href="#">Renderers</a></li>
          <li><a href="extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1>Implementing a Renderer</h1>
        </div>
        <p>This document describes the best practices for adding an entirely new renderer to the toolkit.
        It is only useful if you either plan to implement a renderer for an output format not
        supported by Laika, want to replace one of the existing renderers, or are just
        curious about the inner workings of the library. None of the information here is required
        for standard usage of Laika.</p>
        
        <h2 id="api-contract" class="section">API Contract</h2>
        <p>A renderer has to implement the following trait:</p>
        <pre>trait RenderFormat[FMT] {
  
  def fileSuffix: String
  
  def defaultTheme: Theme
  
  def defaultRenderer: (FMT, Element) =&gt; String
  
  def formatterFactory: RenderContext[FMT] =&gt; FMT

}</pre>
        <p>The <code>fileSuffix</code> method returns the suffix to append when writing files in this format
        (without the &quot;.&quot;).</p>
        <p>The <code>defaultTheme</code> specifies the theme to use when it is not overridden by the user.
        It allows to specify a default template and/or static files to include in the output.
        For details see the section about <a href="../customizing-laika/customize-rendering.html#themes">Themes</a>.</p>
        <p>The <code>defaultRenderer</code> represents the actual renderer. It takes both, a formatter instance
        and the element to render and returns a String in the target format.  <br></p>
        <p><code>formatterFactory</code> is the formatter instance for the target format. A new instance of this
        formatter gets created for each render operation. <code>FMT</code> is a parameterized type representing 
        the Formatter API specific to the output format. For the built-in renderers, this is <code>FOFormatter</code>
        for the <code>XSLFO</code> renderer and <code>HTMLFormatter</code> for the <code>HTML</code> renderer.</p>
        
        <h2 id="the-render-function" class="section">The Render Function</h2>
        <p>This <code>defaultRenderer</code> function should usually adhere to these rules:</p>
        <ul>
          <li>
            <p>When given an element that is a container type that contains child elements (like <code>Paragraph</code>), it should never
            render the children itself, but instead delegate to the Formatter API, so that user-defined
            render functions can kick in for individual element types.</p>
          </li>
          <li>
            <p>It should expect unknown element types. Since parsers can also be extended, the document tree
            can contain nodes which are not part of the default node types provided by Laika. <code>Element</code> is <em>not</em>
            a sealed trait. Usually the parser
            should then also install renderers that know how to handle these nodes, but if it does not your
            renderer should not blow up. Often there is a sensible default, e.g. if you see an unknown
            element that mixes in <code>SpanContainer</code> and <code>Block</code> it is obviously similar to a regular
            Paragraph and may be rendered as such. In the worst case the renderer may choose to ignore
            such an element, but it should never blow up.</p>
          </li>
        </ul>
        <p>For character output your renderer may use the <code>TextFormatter</code> or <code>HTMLFormatter</code> APIs, which are
        explained <a href="customize-rendering.html#the-formatter-apis">here</a>. Alternatively it may create its own API, but you should keep in mind
        then, that this API will also get used by users customizing specific nodes, so it should be
        convenient and straightforward to use.</p>
        <p>Finally, we&#39;ll show a minimal excerpt of the HTML render function we omitted above, just to
        give you an impression that it is often quite simple to implement:</p>
        <pre>def renderElement (fmt: HTMLFormatter, elem: Element): String = {

  elem match {
    case Paragraph(content,opt) =&gt; fmt.element(&quot;p&quot;, opt, content)
    
    case Emphasized(content,opt) =&gt; fmt.element(&quot;em&quot;, opt, content)
    
    /* [other cases ...] */
    
    /* [fallbacks for unknown elements] */
  }   
}</pre>
        <p>As you see, the function never deals with children (the <code>content</code> attribute of many node
        types) directly. Instead it passes them to the Formatter API which delegates to the composed
        render function. This way customized renderers can kick in on every step of the recursion.</p>
        <p>The various functions of the Formatter API are explained in the chapter
        on the <a href="customize-rendering.html#the-formatter-apis">Formatter API</a>.</p>      

      </div>
    </div>

  </div>

</body></html>
