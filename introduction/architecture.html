<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="intro.html">Overview</a></li>
          <li class="active"><a href="#">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="../using-laika/sbt.html">Using the sbt Plugin</a></li>
          <li><a href="../using-laika/embedded.html">Using the Library API</a></li>
          <li><a href="../using-laika/markup.html">Supported Markup</a></li>
          <li><a href="../using-laika/output.html">Supported Output Formats</a></li>
          <li><a href="../using-laika/structure.html">Document Structure</a></li>
          <li><a href="../using-laika/templates.html">Templates</a></li>
          <li><a href="../using-laika/syntax.html">Syntax Highlighting</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1 id="architecture" class="title">Architecture</h1>
        </div>
        <p>This page aims to give a very high level overview of the inner workings of Laika.</p>
        <p>Understanding the architecture of the toolkit is not required for basic usage.
        However if you intend to extend Laika, contribute to it, or if you are simply
        curious, then read on.</p>
        
        <h2 id="design-principles" class="section">Design Principles</h2>
        <ul>
          <li>
            <p>Fully decouple the aspects of input/output, parsing, rendering, templating and document tree rewriting, 
            making each of these steps pluggable.</p>
          </li>
          <li>
            <p>Provide a very convenient and simple high level API for common transformation tasks.</p>
          </li>
          <li>
            <p>Build a generic document tree model that does not reflect specifics of a particular 
            supported markup language like Markdown or reStructuredText.</p>
          </li>
          <li>
            <p>Allow for easy modification of the rendering for a particular node type only, without
            the need to sub-class or modify an existing renderer.</p>
          </li>
          <li>
            <p>Allow customization of rewrite rules for transforming the document tree before rendering
            (e.g for resolving cross-references).</p>
          </li>
          <li>
            <p>Provide concise and type-safe extension APIs for extensible markup definitions.</p>
          </li>
          <li>
            <p>Create the built-in parsers with a custom parser combinator implementation, providing efficient and
            reusable base parsers that encapsulate requirements common to all lightweight markup languages.</p>
          </li>
          <li>
            <p>Keep the library API purely functional. </p>
          </li>
          <li>
            <p>Designed for robustness: Laika has more than 1200 tests, it is protected against malicious
            or accidentally malformed input like endless recursion (a type of guard most other text markup 
            parsers do not include) and parsers like the URI parser are based on the actual relevant RFCs
            (and not just a rough approximation like in many other parsers). </p>
          </li>
        </ul>
        
        <h2 id="transformation-flow" class="section">Transformation Flow</h2>
        <p><img src="../img/architecture.png" alt="Internal Architecture"></p>
        <p>This diagram shows the major phases of a transformation with extension hooks shown as little
        red boxes:</p>
        <ul>
          <li>
            <p><code>Parse</code> represents the actual parsing step, a pluggable instance of type <code>MarkupFormat</code>.
            Supported out of the box are Markdown and reStructuredText. Other parsers can easily be added
            to the system based on Laika&#39;s parser combinators. 
            Parsers can be extended with custom tags called Directives that allow to add new
            constructs to markup without extending the parser.</p>
          </li>
          <li>
            <p><code>Rewrite</code> is a customizable step for transforming the document tree model before rendering.
            There is always a default rewrite step involved, that looks for nodes in the model that need
            to be resolved, like link references, footnote references, etc. But custom rules can be added
            based on a partial function that deals with specific node types only.</p>
          </li>
          <li>
            <p>The <code>Merge</code> step finally combines the rewritten document tree originating from text markup
            with the document tree from the template, based on the directives used in the template.
            It is basically just a merge of two trees consisting of case classes. The use of templates
            is optional, so this step may get skipped.</p>
          </li>
          <li>
            <p><code>Render</code> is the final render step. Supported out of the box are HTML, EPUB, PDF, XSL-FO and AST,
            the latter visualizing the document AST for debugging purposes. Like with the rewrite step, 
            the entire renderer can be replaced by a custom one, or an existing one can customized based 
            on a partial function that deals with specific node types only.</p>
          </li>
        </ul>      

      </div>
    </div>

  </div>

</body></html>
