<div>
  <!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
  <li class="nav-header">Introduction</li>
  <li><a href="../introduction/intro.html">Overview</a></li>
  <li><a href="../introduction/architecture.html">Architecture</a></li>
  <li class="nav-header">Using Laika</li>
  <li class="active"><a href="#">Transformation Basics</a></li>
  <li><a href="markup.html">Supported Markup</a></li>
  <li><a href="structure.html">Document Structure</a></li>
  <li><a href="templates.html">Templates</a></li>
  <li class="nav-header">Customizing Laika</li>
  <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
  <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
  <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
  <li class="nav-header">Extending Laika</li>
  <li><a href="../extending-laika/directive.html">Directives</a></li>
  <li><a href="../extending-laika/parser.html">Parsers</a></li>
  <li><a href="../extending-laika/renderer.html">Renderers</a></li>
  <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
    <h1>Transformation Basics</h1>
  </div>
  <p>The main and most commonly used operation of Laika is a full transformation
  from input text written in a lightweight markup language like Markdown to 
  output formats like HTML.</p>
  <p>Alternatively the parse and render operations can be executed
  separately, which is described in the chapter
  <a href="../customizing-laika/parsing-rendering.html#separate-parsing-and-rendering">Separate Parsing and Rendering</a>.</p>
  <p>The following sections describe the options for full transformations
  from text markup to output format.</p>
  
  <h2 id="transforming-a-single-document" class="section">Transforming a Single Document</h2>
  <p>Converting from Markdown to HTML using files as input and output:</p>
  <pre>Transform from Markdown to HTML fromFile &quot;hello.md&quot; toFile &quot;hello.html&quot;</pre>
  <p>Converting using Strings as input and output</p>
  <pre>val input = &quot;some *text* example&quot;

val result = Transform from Markdown to HTML fromString input toString</pre>
  <p>Other options are using <code>java.io.Reader/Writer</code> or streams. Of course they
  can be combined in any way, like going from file as input to String as output.</p>
  
  <h3 id="character-encoding" class="section">Character Encoding</h3>
  <p>Laika uses the same platform-dependent defaults for file encodings as the
  IO classes in the Scala SDK. The most convenient way to specify an encoding
  is via an implicit:</p>
  <pre>implicit val codec:Codec = Codec.UTF8</pre>
  <p>This codec will then be used by the <code>fromFile</code> and <code>toFile</code> methods shown
  in the examples above.</p>
  
  <h3 id="reusing-transformer-instances" class="section">Reusing Transformer Instances</h3>
  <p>You can also keep the created transformer instance to reuse it with different
  inputs and outputs:</p>
  <pre>val transform = Transform from ReStructuredText to HTML

transform fromFile &quot;hello.rst&quot; toFile &quot;hello.html&quot;

val result = transform fromString &quot;some *text* example&quot; toString</pre>
  
  <h3 id="reusing-a-parsed-document" class="section">Reusing a Parsed Document</h3>
  <p>All objects created by the API are reusable and immutable. For example,
  using the same input for two different types of output could be coded like this:</p>
  <pre>val doc = Transform from ReStructuredText to HTML fromFile &quot;hello.rst&quot;

doc toFile &quot;hello.html&quot;

val res = doc toString
</pre>
  
  <h3 id="pretty-print-output" class="section">Pretty Print Output</h3>
  <p>Laika also supports a PrettyPrint renderer which can be useful for debugging.
  It visualizes the document tree model while shortening longer text spans
  into one line:</p>
  <pre>val input = &quot;some *text* example&quot;

Transform from Markdown to PrettyPrint fromString input toString

res0: java.lang.String = Document - Blocks: 1
. Paragraph - Spans: 3
. . Text - &#39;some &#39;
. . Emphasized - Spans: 1
. . . Text - &#39;text&#39;
. . Text - &#39; example&#39;</pre>
  
  <h2 id="transforming-an-entire-directory" class="section">Transforming an Entire Directory</h2>
  <p>For transforming a directory you can specify the source and target 
  directories separately:</p>
  <pre>Transform from Markdown to 
  HTML fromDirectory &quot;source&quot; toDirectory &quot;target&quot;</pre>
  <p>The parser will pick up any document with a recognized suffix (<code>.md</code> or <code>.markdown</code>
  for Markdown, <code>.rst</code> for reStructuredText).</p>
  
  <h3 id="html-templates" class="section">HTML Templates</h3>
  <p>The directories that contain the markup documents can optionally contain
  templates that get applied to the parsed documents. A very basic template
  may look like this:</p>
  <pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{document.title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
      {{document.content}}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
  <p>The two placeholders enclosed in double curly braces will be replaced with the
  title and content of the parsed markup document. Everything else will be copied
  to the final document unchanged.</p>
  <p>Every directory can contain a file with the name <code>default.template.html</code> that
  automatically gets applied to all documents in that directory and its subdirectories,
  unless overridden in a subdirectory. There are also ways to manually declare a
  template for a specific markup document only. </p>
  <p>For more details on the template engine, see the chapter <a href="templates.html#templates">Templates</a>.</p>
  <p>For features like titles, sections, autonumbering and tables of content, see
  the chapter <a href="structure.html#document-structure">Document Structure</a>.</p>
  
  <h3 id="directory-layout-conventions" class="section">Directory Layout Conventions</h3>
  <p>When you organize your input and output directories under a common root
  directory, with the directory containing the markup documents named
  <code>source</code> and the output directory named <code>target</code>, you do not have
  to specify input and output directories separately:</p>
  <pre>Transform from ReStructuredText to HTML withRootDirectory &quot;myDocs&quot;</pre>
  
  <h3 id="parallel-execution" class="section">Parallel Execution</h3>
  <p>When transforming a large number of files you may want to run the operations
  in parallel: </p>
  <pre>(Transform from Markdown to 
  HTML fromDirectory &quot;source&quot;).inParallel toDirectory &quot;target&quot;</pre>
  <p>Note that we have to introduce parenthesis here, as <code>inParallel</code> is
  a no-arg method breaking the pattern of the fluent API.</p>
  <p>The actual transformation is a three phase process, the first (parsing) and
  third (rendering) can run in parallel. For the second phase this is not possible,
  as this is the document tree model rewrite step where things like cross references or
  table of contents get processed that need access to more than just the current
  document. But the rewrite phase is also the least expensive phase so that you
  should still benefit from parallel execution. <br></p>
  
  <h3 id="character-encoding-1" class="section">Character Encoding</h3>
  <p>The mechanism is the same as for specifying an encoding for a single file.</p>
  <p>Laika uses the same platform-dependent defaults for file encodings as the
  IO classes in the Scala SDK. The most convenient way to specify an encoding
  is via an implicit:</p>
  <pre>implicit val codec:Codec = Codec.UTF8</pre>
  <p>This codec will then be used by the <code>fromDirectory</code>, <code>toDirectory</code> and
  <code>withRootDirectory</code> methods shown in the examples above.</p>
  
  <h3 id="reusing-transformer-instances-1" class="section">Reusing Transformer Instances</h3>
  <p>Like with single file transformation you can (and usually should) keep 
  the created transformer instance to reuse it with different
  directories:</p>
  <pre>val transform = Transform from ReStructuredText to HTML

transform fromDirectory &quot;source-1&quot; toDirectory &quot;target-2&quot;

transform fromDirectory &quot;source-1&quot; toDirectory &quot;target-2&quot;</pre>      

      </div>
    </div>

  </div>


    <!-- javascript
    ================================================== -->
    <script src="../js/jquery-1.8.3.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>


</body></html>
</div>