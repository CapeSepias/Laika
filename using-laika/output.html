<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="sbt.html">Using the sbt Plugin</a></li>
          <li><a href="embedded.html">Using the Library API</a></li>
          <li><a href="markup.html">Supported Markup</a></li>
          <li class="active"><a href="#">Supported Output Formats</a></li>
          <li><a href="structure.html">Document Structure</a></li>
          <li><a href="templates.html">Templates</a></li>
          <li><a href="syntax.html">Syntax Highlighting</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1 id="supported-output-formats" class="title">Supported Output Formats</h1>
        </div>
        <p>The current release supports HTML, EPUB, PDF, XSL-FO and AST.
        Rendering happens from a generic document tree model shared between all parsers,
        so that no renderer implementation has to understand specifics about a concrete
        markup syntax like Markdown or reStructuredText.</p>
        <p>Customization of the output is possible on two levels, first most formats (except
        for AST) can be styled with CSS. Secondly the rendering of specific nodes
        can be overridden with a simple partial function as described in 
        <a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a>.</p>
        <p>Finally you can develop an entirely new renderer for a format not supported by Laika
        out of the box. See chapter <a href="../extending-laika/renderer.html">Implementing a Renderer</a> for details.</p>
        
        <h2 id="html" class="section">HTML</h2>
        <p>The HTML renderer can be used with the <code>Transform</code> or <code>Render</code> APIs:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">html</span><span>: </span><span class="type-name">String</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">transform</span><span>(</span><span class="string-literal">&quot;hello *there*&quot;</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">doc</span><span>: </span><span class="type-name">Document</span><span> = </span><span class="type-name">Parser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;hello *there*&quot;</span><span>)
  
</span><span class="keyword">val</span><span> </span><span class="identifier">html</span><span>: </span><span class="type-name">String</span><span> = </span><span class="type-name">Renderer</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">render</span><span>(</span><span class="identifier">doc</span><span>)</span></code></pre>
        <p>See <a href="embedded.html">Using the Library API</a> for more details on these APIs.</p>
        <p>If you are using the sbt plugin you can use several of its task for generating
        HTML output:</p>
        <ul>
          <li><code>laikaHTML</code> for transforming a directory of input files to HTML</li>
          <li><code>laikaGenerate html &lt;other formats&gt;</code> for transforming a directory of input files to HTML
          and other output formats with a single parse operation</li>
          <li><code>laikaSite</code> for generating a site optionally containing API documentation (scaladoc) and
          PDF files.</li>
        </ul>
        <p>See <a href="sbt.html#using-the-sbt-plugin">Using the sbt Plugin</a> for more details.</p>
        
        <h3 id="templating" class="section">Templating</h3>
        <p>Laika supports Templating for most output formats. The following example
        uses variable references to include the title and content of the input
        document, as well as a directive called <code>@toc</code> to inset a table of contents:</p>
        <pre><code class="nohighlight"><span class="tag-punctuation">&lt;</span><span class="tag-name">html</span><span class="tag-punctuation">&gt;</span><span>
  </span><span class="tag-punctuation">&lt;</span><span class="tag-name">head</span><span class="tag-punctuation">&gt;</span><span>
    </span><span class="tag-punctuation">&lt;</span><span class="tag-name">title</span><span class="tag-punctuation">&gt;</span><span class="substitution">${document.title}</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">title</span><span class="tag-punctuation">&gt;</span><span>
  </span><span class="tag-punctuation">&lt;/</span><span class="tag-name">head</span><span class="tag-punctuation">&gt;</span><span>
  </span><span class="tag-punctuation">&lt;</span><span class="tag-name">body</span><span class="tag-punctuation">&gt;</span><span>
    </span><span class="keyword">@:</span><span class="identifier">toc</span><span>
    </span><span class="tag-punctuation">&lt;</span><span class="tag-name">div</span><span class="tag-punctuation"> </span><span class="attribute-name">class</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;content&quot;</span><span class="tag-punctuation">&gt;</span><span>
      </span><span class="substitution">${document.content}</span><span>
    </span><span class="tag-punctuation">&lt;/</span><span class="tag-name">div</span><span class="tag-punctuation">&gt;</span><span>
  </span><span class="tag-punctuation">&lt;/</span><span class="tag-name">body</span><span class="tag-punctuation">&gt;</span><span>
</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">html</span><span class="tag-punctuation">&gt;</span></code></pre>
        <p>If you save such a template in a file called <code>default.template.html</code> in the
        root directory of your input sources it will get applied to all markup documents
        in those directories. You can optionally override the template for an individual
        sub-directory simply by including a different template named <code>default.template.html</code>
        in that sub-directory.</p>
        <p>See <a href="templates.html">Templates</a> for more details.</p>
        
        <h3 id="html-renderer-properties" class="section">HTML Renderer Properties</h3>
        <p>The <code>unformatted</code> property tells the renderer to omit any formatting (line breaks or indentation) 
        around tags. Useful when storing the output in a database for example:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">unformatted</span><span> 
  .</span><span class="identifier">build</span></code></pre>
        <p>The <code>withMessageLevel</code> property instructs the renderer to include system messages in the
        generated HTML. Messages may get inserted into the document tree for problems during
        parsing or reference resolution, e.g. an internal link to a destination that does not
        exist. By default these messages are not included in the output. They are mostly useful
        for testing and debugging, or for providing feedback to application users producing 
        markup input:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">withMessageLevel</span><span>(</span><span class="type-name">Warning</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        
        <h3 id="css-javascript-and-other-files" class="section">CSS, JavaScript and other Files</h3>
        <p>The generated HTML can be styled with CSS like any other static HTML files.
        If you transform an entire directory Laika will copy all static files like CSS
        and JavaScript files over to the target directory alongside the generated HTML.
        It does that recursively including sub-directories.</p>
        
        <h3 id="customizing-the-html-renderer" class="section">Customizing the HTML Renderer</h3>
        <p>Finally you can adjust the rendered output for one or more node types
        of the document tree programmatically with a simple partial function:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">rendering</span><span> {
    </span><span class="keyword">case</span><span> (</span><span class="identifier">fmt</span><span>, </span><span class="type-name">Emphasized</span><span>(</span><span class="identifier">content</span><span>, </span><span class="identifier">opt</span><span>)) =&gt; 
      </span><span class="identifier">fmt</span><span>.</span><span class="identifier">element</span><span>(</span><span class="string-literal">&quot;em&quot;</span><span>, </span><span class="identifier">opt</span><span>, </span><span class="identifier">content</span><span>, </span><span class="string-literal">&quot;class&quot;</span><span> -&gt; </span><span class="string-literal">&quot;big&quot;</span><span>)  
  }
  .</span><span class="identifier">build</span></code></pre>
        <p>Note that in some cases the simpler way to achieve the same result may be
        styling with CSS.</p>
        <p>See <a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a> for more details.</p>
        
        <h2 id="epub" class="section">EPUB</h2>
        <p>Since version 0.11.0 Laika support the generation of e-books in the EPUB format.
        Similar to the PDF export, it allows you to transform an entire directory with
        text markup, CSS, image and font files into a single EPUB container.</p>
        <p>If you are using the sbt plugin you can use several of its task for generating
        EPUB files:</p>
        <ul>
          <li><code>laikaEPUB</code> for transforming a directory of input files to a single PDF file</li>
          <li><code>laikaGenerate epub &lt;other formats&gt;</code> for transforming a directory of input files to PDF
          and other output formats with a single parse operation</li>
          <li><code>laikaSite</code> for generating a site optionally containing API documentation (scaladoc) and
          PDF and/or EPUB files.</li>
        </ul>
        <p>See <a href="sbt.html#using-the-sbt-plugin">Using the sbt Plugin</a> for more details.</p>
        <p>If you want to produce EPUB files with the library API,
        the <code>laika-io</code> module is required for the binary output:</p>
        <pre><code class="nohighlight"><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.planet42&quot;</span><span> %% </span><span class="string-literal">&quot;laika-io&quot;</span><span> % </span><span class="string-literal">&quot;0.13.0&quot;</span></code></pre>
        <p>The EPUB renderer can be used with the <code>Transform</code> or <code>Render</code> APIs:</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">cs</span><span>: </span><span class="type-name">ContextShift</span><span>[</span><span class="type-name">IO</span><span>] = 
  </span><span class="type-name">IO</span><span>.</span><span class="identifier">contextShift</span><span>(</span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">global</span><span>)
  
</span><span class="keyword">val</span><span> </span><span class="identifier">blocker</span><span> = </span><span class="type-name">Blocker</span><span>.</span><span class="identifier">liftExecutionContext</span><span>(
  </span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">fromExecutor</span><span>(</span><span class="type-name">Executors</span><span>.</span><span class="identifier">newCachedThreadPool</span><span>())
)

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">EPUB</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>)
  .</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>]
  .</span><span class="identifier">build</span><span>

</span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromDirectory</span><span>(</span><span class="string-literal">&quot;src&quot;</span><span>)
  .</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;hello.epub&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        <p>See <a href="embedded.html#using-the-library-api">Using the Library API</a> for more details on these APIs.</p>
        
        <h3 id="epub-directory-structure" class="section">EPUB Directory Structure</h3>
        <p>The structure of the generated EPUB file will exactly mirror the structure of the
        input directory, apart from the additional metadata files it needs to generate.
        This means that the file size of the resulting HTML documents inside the EPUB container
        will roughly correspond to the size of the text markup documents used as input.
        For that reason it is recommended to split the input into multiple files to avoid
        large files which might slow down the experience in the e-book reader.</p>
        <p>Laika supports a directory structure with sub-directories of any depth. Since EPUB
        requires a linear spine to be defined for its navigation order, the transformer
        will produce a spine that corresponds to a depth-first traversal of you input directories.</p>
        
        <h3 id="css-for-epub" class="section">CSS for EPUB</h3>
        <p>Since content files for EPUB are standard XHMTL files (apart from optional EPUB-specific attributes), you
        can style your e-books with standard CSS. It is sufficient to simply place all CSS into the input directory,
        alongside the text markup and other file types. References to these CSS files will be automatically added
        to the header section of all generated HTML files. When referencing images or fonts from your CSS files,
        you can use relative paths, as the directory layout will be retained inside the EPUB container.</p>
        
        <h3 id="images-fonts-and-other-file-types" class="section">Images, Fonts and other File Types</h3>
        <p>You can also place images, fonts and other supported file types into the input directory.
        Laika will add these files to the generated EPUB container and metadata files.</p>
        <p>The supported file types / suffixes are:</p>
        <ul>
          <li>Images: <code>jpg</code>, <code>jpeg</code>, <code>gif</code>, <code>png</code>, <code>svg</code></li>
          <li>Audio: <code>mp3</code>, <code>mp4</code></li>
          <li>HTML: <code>html</code>, <code>xhtml</code></li>
          <li>JavaScript: <code>js</code></li>
          <li>CSS: <code>css</code> <br></li>
          <li>Fonts: <code>woff2</code>, <code>woff</code>, <code>ttf</code>, <code>otf</code> </li>
        </ul>
        
        <h3 id="epub-xhtml-templates" class="section">EPUB XHTML Templates</h3>
        <p>Like the HTML renderer, the EPUB renderer supports templating. EPUB requires XHTML as the output
        format and also may contain custom attributes specific to EPUB. Therefore they are handled separately
        from regular HTML templates and are recognised by the suffix <code>.epub.xhtml</code>. </p>
        <p>You can have a look at the <a href="https://github.com/planet42/Laika/blob/master/core/src/main/resources/templates/default.template.epub.xhtml">default EPUB XHTML template</a> used 
        by the EPUB renderer for reference.</p>
        <p>You can override it if required by saving a custom template in a file called 
        <code>default.template.epub.xhtml</code> in the root directory of your input sources.</p>
        
        <h3 id="configuration" class="section">Configuration</h3>
        <p>There are several configuration options for EPUB generation that can be set
        in the file <code>directory.conf</code> in the root directory of your input sources:</p>
        <pre><code class="nohighlight"><span class="attribute-name">epub</span><span> {
  </span><span class="attribute-name">toc.depth</span><span> = </span><span class="number-literal">3</span><span>
  </span><span class="attribute-name">toc.title</span><span> = </span><span class="string-literal">&quot;Contents&quot;</span><span>
  </span><span class="attribute-name">coverImage</span><span> = </span><span class="string-literal">&quot;cover.png&quot;</span><span>
}  
</span><span class="attribute-name">metadata</span><span> {
  </span><span class="attribute-name">identifier</span><span> = </span><span class="string-literal">&quot;urn:isbn:978-3-16-148410-0&quot;</span><span>
  </span><span class="attribute-name">date</span><span> = </span><span class="string-literal">&quot;2018-01-01T12:00:00Z&quot;</span><span>
  </span><span class="attribute-name">language</span><span> = </span><span class="string-literal">&quot;en:GB&quot;</span><span>
  </span><span class="attribute-name">author</span><span> = </span><span class="string-literal">&quot;Mia Miller&quot;</span><span>
}</span></code></pre>
        <p>These properties control the following aspects of the rendering:</p>
        <ul>
          <li><code>toc.depth</code> the number of levels to generate a table of contents for. 
          Every level of the tree hierarchy will be considered for an entry in the table 
          of contents: directories, files and sections within files.
          The default value is <code>Int.MaxValue</code>.</li>
          <li><code>toc.title</code> specifies the title for the table of contents. The default value is <code>Contents</code>.</li>
          <li><code>coverImage</code> specifies the cover image for the book</li>
          <li><code>metadata</code> specifies document metadata to be added to the container configuration. Three of the 
          properties are mandatory, but Laika will use sensible defaults if they are not set explicitly
          (a random UUID for the identifier, the current time and the language of the Locale of the JVM process)</li>
        </ul>
        <p>For more details on these features see <a href="structure.html#document-structure">Document Structure</a>.</p>
        
        <h2 id="pdf" class="section">PDF</h2>
        <p>The PDF support in Laika does not require installation of external tools as it
        is not based on LaTeX like many other PDF renderers. To follow Laika&#39;s general
        principle to allow for embedded use without further installations, it is based
        on XSL-FO as an interim format and uses <a href="https://xmlgraphics.apache.org/fop/">Apache FOP</a> for transforming the XSL-FO
        generated by Laika to the binary PDF file. Therefore several characteristics
        like performance and memory consumption depend entirely on Apache FOP. If you
        plan to use Laika&#39;s PDF support embedded in live application it is recommended
        to first do performance and load testing.</p>
        <p>If you are using the sbt plugin you can use several of its task for generating
        PDF files:</p>
        <ul>
          <li><code>laikaPDF</code> for transforming a directory of input files to a single PDF file</li>
          <li><code>laikaGenerate pdf &lt;other formats&gt;</code> for transforming a directory of input files to PDF
          and other output formats with a single parse operation</li>
          <li><code>laikaSite</code> for generating a site optionally containing API documentation (scaladoc) and
          PDF files.</li>
        </ul>
        <p>See <a href="sbt.html#using-the-sbt-plugin">Using the sbt Plugin</a> for more details.</p>
        <p>If you want to produce PDF files with the library API,
        you need to add the <code>laika-pdf</code> module to your build:</p>
        <pre><code class="nohighlight"><span class="identifier">libraryDependencies</span><span> += </span><span class="string-literal">&quot;org.planet42&quot;</span><span> %% </span><span class="string-literal">&quot;laika-pdf&quot;</span><span> % </span><span class="string-literal">&quot;0.13.0&quot;</span></code></pre>
        <p>The PDF renderer can be used with the <code>Transform</code> or <code>Render</code> APIs:</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">cs</span><span>: </span><span class="type-name">ContextShift</span><span>[</span><span class="type-name">IO</span><span>] = 
  </span><span class="type-name">IO</span><span>.</span><span class="identifier">contextShift</span><span>(</span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">global</span><span>)
  
</span><span class="keyword">val</span><span> </span><span class="identifier">blocker</span><span> = </span><span class="type-name">Blocker</span><span>.</span><span class="identifier">liftExecutionContext</span><span>(
  </span><span class="type-name">ExecutionContext</span><span>.</span><span class="identifier">fromExecutor</span><span>(</span><span class="type-name">Executors</span><span>.</span><span class="identifier">newCachedThreadPool</span><span>())
)

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">PDF</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">io</span><span>(</span><span class="identifier">blocker</span><span>)
  .</span><span class="identifier">parallel</span><span>[</span><span class="type-name">IO</span><span>]
  .</span><span class="identifier">build</span><span>

</span><span class="identifier">transformer</span><span>
  .</span><span class="identifier">fromDirectory</span><span>(</span><span class="string-literal">&quot;src&quot;</span><span>)
  .</span><span class="identifier">toFile</span><span>(</span><span class="string-literal">&quot;hello.pdf&quot;</span><span>)
  .</span><span class="identifier">transform</span></code></pre>
        <p>See <a href="embedded.html#using-the-library-api">Using the Library API</a> for more details on these APIs.</p>
        
        <h3 id="css-for-pdf" class="section">CSS for PDF</h3>
        <p>Laika offers the unusual, but convenient and probably unique feature of CSS styling for PDF.
        It allows for customization in a syntax familiar to most users. However, the set of available 
        attributes is quite different from what you know from web CSS, as PDF is a page-based format 
        that requires features like page breaks or footnotes that are not available in the context
        of a web page.</p>
        <p>The following example shows the style for headers from Laika&#39;s default CSS:</p>
        <pre><code class="nohighlight"><span class="identifier">Header</span><span> {
  </span><span class="attribute-name">font-family</span><span>: </span><span class="identifier">sans-serif</span><span>;
  </span><span class="attribute-name">font-weight</span><span>: </span><span class="identifier">bold</span><span>;
  </span><span class="attribute-name">font-size</span><span>: </span><span class="number-literal">12</span><span class="identifier">pt</span><span>;
}</span></code></pre>
        <p>The font-related attributes in this case are identical to the ones you know from web CSS,
        but the type selector does not refer to an HTML tag, but instead to a class name from the
        hierarchy of case classes forming the document tree of a parsed input source.</p>
        <p>The CSS files need to be placed into the root directory of your sources with a name
        in the format <code>&lt;name&gt;.fo.css</code>. Like with template files you can place alternative CSS
        files into subdirectories of your input tree for styles that should only be applied to 
        that directory.</p>
        <p>For an overview over the available attributes you can refer to the <a href="http://www.w3.org/TR/xsl11/#pr-section">Formatting Properties</a> chapter
        in the XSL-FO specification.</p>
        <p>For an overview over supported type selectors see the sections following below.</p>
        
        <h4 id="type-selectors" class="section">Type Selectors</h4>
        <p>A type selector in the context of Laika&#39;s PDF support does not refer to the name of an HTML tag,
        but instead to a class name from the hierarchy of case classes forming the document tree of a 
        parsed input source. See <a href="../api/laika/ast/">Elements Scaladoc</a> for an overview of all node types.</p>
        <p>Example:</p>
        <pre><code class="nohighlight"><span class="identifier">Paragraph</span><span> {
  </span><span class="attribute-name">font-size</span><span>: </span><span class="number-literal">12</span><span class="identifier">pt</span><span>;
}</span></code></pre>
        
        <h4 id="class-selectors" class="section">Class Selectors</h4>
        <p>A class selector refers to a style attribute of a node in the document tree, similar to the
        class attributes of HTML tags. Only a subset of Laika&#39;s nodes get rendered with style attributes.
        Some exceptions are:</p>
        <ul>
          <li>Headers get rendered with a level style (<code>level1</code> to <code>levelN</code>)</li>
          <li>Titles get rendered with a <code>title</code> style</li>
          <li>An entry in the table of contents has a <code>toc</code> style</li>
          <li>Text nodes can have <code>.subscript</code> or <code>.superscript</code> styles</li>
          <li>Figures come with <code>caption</code> and <code>legion</code> styles</li>
        </ul>
        <p>If you customize the renderer you can also add custom styles to any Laika node.</p>
        <p>Example for using the <code>title</code> style:</p>
        <pre><code class="nohighlight"><span>.</span><span class="identifier">title</span><span> {
  </span><span class="attribute-name">font-size</span><span>: </span><span class="number-literal">18</span><span class="identifier">pt</span><span>;
}</span></code></pre>
        
        <h4 id="id-selectors" class="section">Id Selectors</h4>
        <p>An id selector refers to the unique id of a node in the document tree, similar to the id
        of an HTML tag. Out of the box only a subset of nodes get rendered with an id: those that
        internal links refer to, like headers, footnotes or citations.</p>
        <p>Example:</p>
        <pre><code class="nohighlight"><span class="identifier">#my-header</span><span> {
  </span><span class="attribute-name">font-size</span><span>: </span><span class="number-literal">18</span><span class="identifier">pt</span><span>;
}</span></code></pre>
        
        <h4 id="selector-combinations" class="section">Selector Combinations</h4>
        <p>Like web CSS Laika supports combinations of selectors to refer to child elements
        or define styles for multiple selectors at once:</p>
        <ul>
          <li>Combining type and style selectors: <code>Header.level1</code> refers to a <code>Header</code> node with a <code>level1</code> style</li>
          <li>Combining type and id selectors: <code>Header#my-title</code> refers to a <code>Header</code> node with the id <code>my-title</code></li>
          <li>Referring to child elements: <code>Header .section-num</code> refers to a node with a style <code>section-num</code> as a child of a <code>Header</code> node</li>
          <li>Referring to immediate child elements: <code>Header &gt; .section-num</code> refers to a node with a style <code>section-num</code> as an immediate child of a <code>Header</code> node</li>
          <li>Referring to multiple selectors: <code>Title, Header</code> refers to both, all Title and all Header nodes</li>
        </ul>
        
        <h4 id="unsupported-selectors" class="section">Unsupported Selectors</h4>
        <p>Some selector types of the CSS specification are not supported as most of them do not add much value
        in the context of a Laika document tree:</p>
        <ul>
          <li>Pseudo-classes like <code>:hover</code></li>
          <li>Attibute selectors like <code>[attribute~=value]</code> (since Laika nodes do not have many properties)</li>
          <li><code>Element1+Element2</code> or <code>Element1~Element2</code> for selecting based on sibling elements</li>
        </ul>
        
        <h3 id="configuration-1" class="section">Configuration</h3>
        <p>There are several configuration options for PDF rendering that can be set
        either in the file <code>directory.conf</code> in the root directory of your input sources
        or programmatically on the <code>PDF</code> renderer.</p>
        <p>In <code>directory.conf</code> you can set the following options:</p>
        <pre><code class="nohighlight"><span class="attribute-name">pdf</span><span> {
  </span><span class="attribute-name">bookmarks.depth</span><span> = </span><span class="number-literal">3</span><span>
  </span><span class="attribute-name">toc.depth</span><span> = </span><span class="number-literal">3</span><span>
  </span><span class="attribute-name">toc.title</span><span> = </span><span class="string-literal">&quot;Contents&quot;</span><span>
  </span><span class="attribute-name">coverImage</span><span> = </span><span class="string-literal">&quot;cover.png&quot;</span><span>
}</span></code></pre>
        <p>The same options are available programmatically through the <code>withConfig</code> method on the <code>PDF</code> renderer:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">config</span><span> = </span><span class="type-name">PDFConfig</span><span>(
  </span><span class="identifier">bookmarkDepth</span><span> = </span><span class="number-literal">3</span><span>,
  </span><span class="identifier">tocDepth</span><span> = </span><span class="number-literal">3</span><span>,
  </span><span class="identifier">tocTitle</span><span> = </span><span class="type-name">Some</span><span>(</span><span class="string-literal">&quot;Contents&quot;</span><span>)
)

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">PDF</span><span>.</span><span class="identifier">withConfig</span><span>(</span><span class="identifier">config</span><span>))
  .</span><span class="identifier">build</span></code></pre>
        <p>These properties control the following aspects of the rendering:</p>
        <ul>
          <li><code>bookmarkDepth</code> the number of levels bookmarks should be generated for, 
          you can use 0 to switch off bookmark generation entirely. Every level of the tree hierarchy will
          be considered for a bookmark entry: directories, files and sections within files.
          The default value is <code>Int.MaxValue</code>.</li>
          <li><code>toc.depth</code> the number of levels to generate a table of contents for, 
          you can use 0 to switch off toc generation entirely. Every level of the tree hierarchy will
          be considered for an entry in the table of contents: directories, files and sections within files.
          The default value is <code>Int.MaxValue</code>.</li>
          <li><code>toc.title</code> specifies the title for the table of contents. The default value is <code>None</code>.</li>
          <li><code>coverImage</code> specifies the cover image for the book</li>
        </ul>
        <p>For more details on these features see <a href="structure.html#document-structure">Document Structure</a>.</p>
        
        <h4 id="customizing-apache-fop" class="section">Customizing Apache FOP</h4>
        <p>Rendering a PDF file is (roughly) a 3-step process:</p>
        <ol class="arabic">
          <li>Parsing all markup files and producing an in-memory document tree representation</li>
          <li>Applying templates and CSS to the document tree and render it as XSL-FO</li>
          <li>Produce the final PDF file from the resulting XSL-FO</li>
        </ol>
        <p>While step 1 and 2 are entirely managed by Laika, without any dependencies to external
        libraries or tools, step 3 is almost solely taken care of by Apache FOP. </p>
        <p>Therefore, any customization for this step is best left for the configuration hooks of FOP itself.
        They allow you to define aspects like the target resolution, custom fonts, custom stemmers and
        a lot more.
        The available options are described in the <a href="https://xmlgraphics.apache.org/fop/2.1/configuration.html">Apache FOP documentation</a>.</p>
        <p>When you are using the sbt plugin, you can specify an Apache FOP configuration file with
        the <code>fopConfig</code> setting:</p>
        <pre><code class="nohighlight"><span class="identifier">fopConfig</span><span> := </span><span class="type-name">Some</span><span>(</span><span class="identifier">baseDirectory</span><span>.</span><span class="identifier">value</span><span> / </span><span class="string-literal">&quot;customFop.xconf&quot;</span><span>)</span></code></pre>
        <p>Note that the default is <code>None</code> as FOPs default configuration is often sufficient.</p>
        <p>When you are using Laika embedded, the PDF renderer has a hook to specify a custom
        <code>FopFactory</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">configFile</span><span> = </span><span class="string-literal">&quot;/path/to/customFop.xconf&quot;</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">factory</span><span> = </span><span class="type-name">FopFactory</span><span>.</span><span class="identifier">newInstance</span><span>(</span><span class="keyword">new</span><span> </span><span class="type-name">File</span><span>(</span><span class="identifier">configFile</span><span>))

</span><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">PDF</span><span>.</span><span class="identifier">withFopFactory</span><span>(</span><span class="identifier">factory</span><span>))
  .</span><span class="identifier">build</span></code></pre>
        <p>Note that a <code>FopFactory</code> is a fairly heavy-weight object, so make sure that you reuse
        either the <code>FopFactory</code> instance itself or the resulting <code>PDF</code> renderer.
        In case you do not specify a custom factory, Laika ensures that the default
        factory is reused between renderers.</p>
        
        <h3 id="xsl-fo-templates" class="section">XSL-FO Templates</h3>
        <p>Like the HTML renderer, the PDF renderer supports templating. However, there should be
        significantly less scenarios where you&#39;d need to use them, as most of the visual aspects
        of the rendering can be controlled by Laika&#39;s CSS for PDF feature. Since the PDF renderer
        uses XSL-FO as its interim format, the templating is based on this format.</p>
        <p>You can have a look at the <a href="https://github.com/planet42/Laika/blob/master/core/src/main/resources/templates/default.template.fo">default XSL-FO template</a> used 
        by the PDF renderer for reference.</p>
        <p>You can override it if required by saving a custom template in a file called 
        <code>default.template.fo</code> in the root directory of your input sources.</p>
        
        <h3 id="customizing-the-xsl-fo-renderer" class="section">Customizing the XSL-FO Renderer</h3>
        <p>Finally you can adjust the <code>fo</code> tags rendered for one or more node types
        of the document tree programmatically with a simple partial function:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">PDF</span><span>)
  .</span><span class="identifier">rendering</span><span> {
    </span><span class="keyword">case</span><span> (</span><span class="identifier">fmt</span><span>, </span><span class="identifier">elem</span><span> @ </span><span class="type-name">Emphasized</span><span>(</span><span class="identifier">content</span><span>, </span><span class="identifier">_</span><span>)) =&gt; 
      </span><span class="identifier">fmt</span><span>.</span><span class="identifier">inline</span><span>(</span><span class="identifier">elem</span><span>.</span><span class="identifier">copy</span><span>(</span><span class="identifier">options</span><span> = </span><span class="type-name">Style</span><span>(</span><span class="string-literal">&quot;myStyle&quot;</span><span>)), </span><span class="identifier">content</span><span>)   
  }
  .</span><span class="identifier">build</span></code></pre>
        <p>Note that in most cases the simpler way to achieve the same result will be
        styling with CSS.</p>
        <p>See <a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a> for more details.</p>
        
        <h2 id="xsl-fo" class="section">XSL-FO</h2>
        <p>XSL-FO is primarily intended as an interim format for producing PDF output, but you
        can alternatively use it as the final output format and then post-process it with other
        tools.</p>
        <p>The XSL-FO renderer can be used with the <code>Transformer</code> or <code>Renderer</code> APIs:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">result</span><span>: </span><span class="type-name">String</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">XSLFO</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">transform</span><span>(&quot;</span><span class="identifier">hello</span><span> *</span><span class="identifier">there</span><span>*)

</span><span class="keyword">val</span><span> </span><span class="identifier">doc</span><span>: </span><span class="type-name">Document</span><span> = </span><span class="type-name">Parser</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;hello *there*&quot;</span><span>)
  
</span><span class="keyword">val</span><span> </span><span class="identifier">html</span><span>: </span><span class="type-name">String</span><span> = </span><span class="type-name">Renderer</span><span>
  .</span><span class="identifier">of</span><span>(</span><span class="type-name">XSLFO</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">render</span><span>(</span><span class="identifier">doc</span><span>)</span></code></pre>
        <p>See <a href="embedded.html#using-the-library-api">Using the Library API</a> for more details on these APIs.</p>
        <p>If you are using the sbt plugin you can use several of its task for generating
        XSL-FO output:</p>
        <ul>
          <li><code>laikaXSLFO</code> for transforming a directory of input files to XSL-FO</li>
          <li><code>laikaGenerate xslfo &lt;other formats&gt;</code> for transforming a directory of input files to XSL-FO
          and other output formats with a single parse operation</li>
        </ul>
        <p>See <a href="sbt.html#using-the-sbt-plugin">Using the sbt Plugin</a> for more details. </p>
        <p>For customizing XSL-FO rendering the same approach applies as for PDF rendering
        as the latter uses XSL-FO as an interim format. See the sections above on 
        <a href="#css-for-pdf">CSS for PDF</a>, <a href="#xsl-fo-templates">XSL-FO Templates</a> and <a href="#customizing-the-xsl-fo-renderer">Customizing the XSL-FO Renderer</a> for more 
        details.</p>
        <p>The <code>XLSFO</code> renderer instance also has similar properties as the <code>HTML</code> renderer:
        <code>withMessageLevel</code> and <code>unformatted</code> for controlling aspect of the output as 
        described in <a href="#html-renderer-properties">HTML Renderer Properties</a> and finally <code>withStyles</code> to programmatically
        apply a custom CSS declarations.</p>
        
        <h2 id="formatted-ast" class="section">Formatted AST</h2>
        <p>A renderer that visualizes the document tree structure, essentially a formatted
        <code>toString</code> for a tree of case classes, mainly useful for testing and debugging
        purposes.</p>
        <p>You can use this renderer with the Transformer API:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">input</span><span> = </span><span class="string-literal">&quot;some *text* example&quot;</span><span>

</span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">AST</span><span>)
  .</span><span class="identifier">build</span><span>
  .</span><span class="identifier">transform</span><span>(</span><span class="identifier">input</span><span>)

</span><span class="comment">/*
res0: java.lang.String = Document - Blocks: 1
. Paragraph - Spans: 3
. . Text - &#39;some &#39;
. . Emphasized - Spans: 1
. . . Text - &#39;text&#39;
. . Text - &#39; example&#39;
*/</span></code></pre>
        <p>Alternatively you can use the Render API to render an existing document:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">input</span><span> = </span><span class="string-literal">&quot;some *text* example&quot;</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">doc</span><span> = </span><span class="type-name">Parser</span><span>.</span><span class="identifier">of</span><span>(</span><span class="type-name">Markdown</span><span>).</span><span class="identifier">build</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="identifier">input</span><span>)

</span><span class="type-name">Renderer</span><span>.</span><span class="identifier">of</span><span>(</span><span class="type-name">AST</span><span>).</span><span class="identifier">build</span><span>.</span><span class="identifier">render</span><span>(</span><span class="identifier">doc</span><span>)</span></code></pre>
        <p>The above will yield the same result as the previous example.</p>
        <p>Finally, if you are using the sbt plugin you can use the <code>laikaAST</code> task.</p>      

      </div>
    </div>

  </div>

</body></html>
