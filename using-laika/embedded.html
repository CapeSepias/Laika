<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="sbt.html">Using the sbt Plugin</a></li>
          <li class="active"><a href="#">Using Laika Embedded</a></li>
          <li><a href="markup.html">Supported Markup</a></li>
          <li><a href="output.html">Supported Output Formats</a></li>
          <li><a href="structure.html">Document Structure</a></li>
          <li><a href="templates.html">Templates</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
          <h1>Using Laika Embedded</h1>
        </div>
        <p>Apart from using Laika within sbt, you can alternatively embed it into 
        Scala applications. Laika is very lightweight, it does not
        require the installation of any external tools and the core artifact
        has only very few library dependencies.</p>
        <p>The main and most commonly used operation is a full transformation
        from input text written in a lightweight markup language like Markdown to 
        output formats like HTML.</p>
        <p>Alternatively the parse and render operations can be executed
        separately, which is described in the chapter
        <a href="../customizing-laika/parsing-rendering.html#separate-parsing-and-rendering">Separate Parsing and Rendering</a>.</p>
        <p>The following sections describe the options for full transformations
        from text markup to output format.</p>
        
        <h2 id="transforming-a-single-document" class="section">Transforming a Single Document</h2>
        <p>Converting from Markdown to HTML using files as input and output:</p>
        <pre>Transform from Markdown to HTML fromFile &quot;hello.md&quot; toFile &quot;hello.html&quot;
</pre>
        <p>Converting from ReStructuredText to PDF using files as input and output:</p>
        <pre>Transform from ReStructuredText to 
  PDF fromFile &quot;hello.md&quot; toFile &quot;hello.pdf&quot;</pre>
        <p>Converting using Strings as input and output</p>
        <pre>val input = &quot;some *text* example&quot;

val result = Transform from Markdown to HTML fromString input toString</pre>
        <p>Other options are using <code>java.io.Reader/Writer</code> or streams. Of course they
        can be combined in any way, like going from file as input to String as output.</p>
        
        <h3 id="character-encoding" class="section">Character Encoding</h3>
        <p>Laika uses the same platform-dependent defaults for file encodings as the
        IO classes in the Scala SDK. The most convenient way to specify an encoding
        is via an implicit:</p>
        <pre>implicit val codec:Codec = Codec.UTF8</pre>
        <p>This codec will then be used by the <code>fromFile</code> and <code>toFile</code> methods shown
        in the examples above.</p>
        
        <h3 id="reusing-transformer-instances" class="section">Reusing Transformer Instances</h3>
        <p>You can also keep the created transformer instance to reuse it with different
        inputs and outputs:</p>
        <pre>val transform = Transform from ReStructuredText to HTML

transform fromFile &quot;hello.rst&quot; toFile &quot;hello.html&quot;

val result = transform fromString &quot;some *text* example&quot; toString</pre>
        
        <h3 id="reusing-a-parsed-document" class="section">Reusing a Parsed Document</h3>
        <p>All objects created by the API are reusable and immutable. For example,
        using the same input for two different types of output could be coded like this:</p>
        <pre>val doc = Transform from ReStructuredText to HTML fromFile &quot;hello.rst&quot;

doc toFile &quot;hello.html&quot;

val res = doc toString
</pre>
        
        <h3 id="formatted-ast-output" class="section">Formatted AST Output</h3>
        <p>Laika also supports a AST renderer which can be useful for debugging.
        It visualizes the document tree model while shortening longer text spans
        into one line:</p>
        <pre>val input = &quot;some *text* example&quot;

Transform from Markdown to AST fromString input toString

res0: java.lang.String = Document - Blocks: 1
. Paragraph - Spans: 3
. . Text - &#39;some &#39;
. . Emphasized - Spans: 1
. . . Text - &#39;text&#39;
. . Text - &#39; example&#39;</pre>
        
        <h2 id="transforming-an-entire-directory" class="section">Transforming an Entire Directory</h2>
        <p>For transforming a directory you can specify the source and target 
        directories separately:</p>
        <pre>Transform from Markdown to 
  HTML fromDirectory &quot;source&quot; toDirectory &quot;target&quot;</pre>
        <p>The parser will pick up any document with a recognized suffix (<code>.md</code> or <code>.markdown</code>
        for Markdown, <code>.rst</code> for reStructuredText).</p>
        <p>When transforming to EPUB or PDF, a directory of input files will get merged 
        into a single document:</p>
        <pre>Transform from Markdown to 
  EPUB fromDirectory &quot;source&quot; toFile &quot;target.epub&quot;</pre>
        
        <h3 id="templates" class="section">Templates</h3>
        <p>The directories that contain the markup documents can optionally contain
        templates that get applied to the parsed documents. A very basic template
        for HTML output may look like this:</p>
        <pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{document.title}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
      {{document.content}}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
        <p>The two placeholders enclosed in double curly braces will be replaced with the
        title and content of the parsed markup document. Everything else will be copied
        to the final document unchanged.</p>
        <p>Every directory can contain a file with the name <code>default.template.&lt;suffix&gt;</code> that
        automatically gets applied to all documents in that directory and its subdirectories,
        unless overridden in a subdirectory. There are also ways to manually declare a
        template for a specific markup document only. </p>
        <p>The suffix must match the output format of the transformation, e.g. <code>.html</code> for HTML,
        <code>.fo</code> for PDF (as it renders via XSL-FO) and <code>.epub.xhtml</code> for EPUB.</p>
        <p>For more details on the template engine, see the chapter <a href="#templates">Templates</a>.</p>
        <p>For features like titles, sections, cross-linking, auto-numbering 
        and tables of content, see the chapter <a href="structure.html#document-structure">Document Structure</a>.</p>
        
        <h3 id="merging-multiple-input-directories" class="section">Merging Multiple Input Directories</h3>
        <p>Laika allows to merge multiple directories into a tree structure with 
        a single root. This allows to keep reusable styles and templates separately,
        a feature often called &quot;themes&quot; by other tools, but the support in Laika
        is fully generic and the purpose of the merge can be very different from
        classic themes.</p>
        <p>When the merged directories contain subfolders with the same name, those
        will be merged recursively. Only files with the same name in the same folder
        are treated as errors.</p>
        <p>Use the <code>fromDirectories</code> method to specify the directories to merge:</p>
        <pre>Transform from Markdown to 
  HTML fromDirectories (&quot;source&quot;,&quot;styles&quot;) toDirectory &quot;target&quot;</pre>
        
        <h3 id="mixing-markdown-and-restructuredtext" class="section">Mixing Markdown and reStructuredText</h3>
        <p>Both text markup formats can be used within the same directory structure,
        including cross-linking between the two formats. The parser to be used
        is then determined by the file extension of each of the input files.
        <code>.md</code> and <code>.markdown</code> files get parsed by the Markdown parser, <code>.rst</code>
        files by the reStructuredText parser.</p>
        <p>All you have to do is pass both parsers to the API:</p>
        <pre>Transform.from(Markdown).or(ReStructuredText).to(PDF)
  .fromDirectory(&quot;source&quot;).toFile(&quot;target.pdf&quot;)</pre>
        
        <h3 id="parallel-execution" class="section">Parallel Execution</h3>
        <p>When transforming a large number of files you may want to run the operations
        in parallel: </p>
        <pre>Transform.from(Markdown).to(HTML).inParallel
  .fromDirectory(&quot;source&quot;).toDirectory(&quot;target&quot;)</pre>
        <p>Note that we show this in standard dot-notation here, as the fluent
        dot-less API we use in other examples does not work well with parameter-less
        methods like <code>inParallel</code>.</p>
        <p>The actual transformation is a three phase process, the first (parsing) and
        third (rendering) can run in parallel. For the second phase this is not possible,
        as this is the document tree model rewrite step where things like cross references or
        table of contents get processed that need access to more than just the current
        document. But the rewrite phase is also the least expensive phase so that you
        should still benefit from parallel execution. <br></p>
        
        <h3 id="character-encoding-1" class="section">Character Encoding</h3>
        <p>The mechanism is the same as for specifying an encoding for a single file.</p>
        <p>Laika uses the same platform-dependent defaults for file encodings as the
        IO classes in the Scala SDK. The most convenient way to specify an encoding
        is via an implicit:</p>
        <pre>implicit val codec:Codec = Codec.UTF8</pre>
        <p>This codec will then be used by the <code>fromDirectory</code>, <code>toDirectory</code> and
        <code>withRootDirectory</code> methods shown in the examples above.</p>
        
        <h3 id="reusing-transformer-instances-1" class="section">Reusing Transformer Instances</h3>
        <p>Like with single file transformation you can (and usually should) keep 
        the created transformer instance to reuse it with different
        directories:</p>
        <pre>val transform = Transform from ReStructuredText to HTML

transform fromDirectory &quot;source-1&quot; toDirectory &quot;target-1&quot;

transform fromDirectory &quot;source-2&quot; toDirectory &quot;target-2&quot;</pre>
        
        <h3 id="error-reporting" class="section">Error Reporting</h3>
        <p>Text markup parsers are usually very resilient. For any input they cannot
        make sense of they fall back to rendering it back as raw text. Therefore
        transformations rarely fail, but the output may not be exactly what you 
        expected.</p>
        <p>For some errors like unresolved link references or illegal directive
        attributes, Laika inserts system message nodes into the tree. By default
        these are ignored by all renderers, but you can explicitly enable
        the rendering of message nodes for a specific message level.</p>
        <p>In the HTML renderer messages are rendered as a span with the class
        <code>system-message</code> and a second class for the level (<code>warning</code>, <code>error</code>, etc.),
        so you can add CSS to easily identify these nodes in the page. This can be
        useful for your own debugging purposes, but also for applications that allow
        users to edit text with markup, giving them visual feedback for their mistakes.</p>
        <p>The following example renders all message with the level <code>Warning</code> or higher:</p>
        <pre>Transform.from(Markdown).to(HTML).withMessageLevel(Warning)
  .fromDirectory(&quot;source&quot;).toDirectory(&quot;target&quot;)</pre>      

      </div>
    </div>

  </div>

</body></html>
