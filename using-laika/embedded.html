<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href="../css/bootstrap.css" rel="stylesheet">
    <link href="../css/docs.css" rel="stylesheet">

    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  </head>

  <body data-spy="scroll" data-target=".toc" data-offset="200">


  <div class="container">

    <!-- Docs nav
    ================================================== -->
    <div class="row">
      <div class="span4 toc" >
        
        <ul class="nav nav-list affix">
          <div class="nav-top"><img src="../img/laika-top.png"/></div>
          
          
          <li class="nav-header">Introduction</li>
          <li><a href="../introduction/intro.html">Overview</a></li>
          <li><a href="../introduction/architecture.html">Architecture</a></li>
          <li class="nav-header">Using Laika</li>
          <li><a href="sbt.html">Using the sbt Plugin</a></li>
          <li class="active"><a href="#">Using the Library API</a></li>
          <li><a href="markup.html">Supported Markup</a></li>
          <li><a href="output.html">Supported Output Formats</a></li>
          <li><a href="structure.html">Document Structure</a></li>
          <li><a href="templates.html">Templates</a></li>
          <li class="nav-header">Customizing Laika</li>
          <li><a href="../customizing-laika/customize-rendering.html">Customizing Renderers</a></li>
          <li><a href="../customizing-laika/tree-rewriting.html">Document Tree Rewriting</a></li>
          <li><a href="../customizing-laika/parsing-rendering.html">Separate Parsing and Rendering</a></li>
          <li class="nav-header">Extending Laika</li>
          <li><a href="../extending-laika/directive.html">Directives</a></li>
          <li><a href="../extending-laika/parser.html">Parsers</a></li>
          <li><a href="../extending-laika/renderer.html">Renderers</a></li>
          <li><a href="../extending-laika/extending-rst.html">Extending reStructuredText</a></li>
          
          <li class="nav-header">Project Links</li>
          <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
          <li><a href="../api/laika/api/">API Documentation</a></li>
          <li><a href="http://github.com/planet42/Laika/issues">Issue Tracker</a></li>
          <li><a href="http://planet42.org/">Transformer Web Tool</a></li>
          <li class="follow"><a href="https://twitter.com/_planet42" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false" data-dnt="true">Follow @_planet42</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></li>
          
          <div class="nav-bottom"><img src="../img/laika-bottom.png" border="1"/></div>
        </ul>
        
      </div>
      
      <div class="span8" id="top">

        <div class="page-header">
        <h1>Using the Library API</h1>
        </div>
        <p>Apart from using Laika via its sbt plugin, you can alternatively use its library API
        in your own applications (or libraries). Laika is very lightweight, it does not
        require the installation of any external tools and the core artifact
        has no dependencies.</p>
        <p>The main and most commonly used operation is a full transformation
        from input text written in a lightweight markup language like Markdown to 
        output formats like HTML.</p>
        <p>Alternatively the parse and render operations can be executed
        separately, which is described in the chapter
        <a href="../customizing-laika/parsing-rendering.html#separate-parsing-and-rendering">Separate Parsing and Rendering</a>.</p>
        <p>The following sections describe the options for full transformations
        from text markup to output format.</p>
        
        <h2 id="transforming-strings" class="section">Transforming Strings</h2>
        <p>Transforming in-memory input is the simplest form of transformation, and works for Markdown and reStructuredText 
        as input, and for HTML as output. EPUB and PDF both require additional modules and are described later in this chapter.</p>
        
        <h3 id="setup" class="section">Setup</h3>
        <p>First add the dependency to your build:</p>
        <pre>libraryDependencies += &quot;org.planet42&quot; %% &quot;laika-core&quot; % &quot;0.12.1&quot; </pre>
        <p>For most cases where you don&#39;t use any of the customization hooks, you should be fine with just these imports:</p>
        <pre>import laika.api._
import laika.format._</pre>
        
        <h3 id="running-a-transformation" class="section">Running a Transformation</h3>
        <p>Converting a string from Markdown to HTML:</p>
        <pre>Transformer
  .from(Markdown)
  .to(HTML)
  .build
  .transform(&quot;hello *there*&quot;)</pre>
        <p>From reStructuredText to HTML:</p>
        <pre>Transformer
  .from(ReStructuredText)
  .to(HTML)
  .build
  .transform(&quot;hello *there*&quot;)</pre>
        
        <h3 id="reusing-transformer-instances" class="section">Reusing Transformer Instances</h3>
        <p>You would normally keep the transformer instance for reuse with different
        inputs and outputs to reduce the memory footprint and initialization overhead:</p>
        <pre>val transformer = Transformer.from(Markdown).to(HTML).build

val res1 = transformer.transform(&quot;example *1*)
val res2 = transformer.transform(&quot;example *2*)</pre>
        
        <h3 id="adding-extensions" class="section">Adding Extensions</h3>
        <p>The most likely bundle you would use in everyday scenarios is probably GitHub-Flavored Markdown,
        which is not installed by default:</p>
        <pre>val transformer = Transformer
  .from(Markdown)
  .to(HTML)
  .using(GitHubFlavor)
  .build</pre>
        <p>The <code>GitHubFlavor</code> object is an instance of <code>ExtensionBundle</code> an API that application
        or library authors can use themselves for bundling their own customizations. It has hooks
        for all phases of the transformation process, parsing, AST transformation and rendering.</p>
        
        <h3 id="debugging-with-ast-output" class="section">Debugging with AST Output</h3>
        <p>If you are investigating an unexpected result, it might help to get
        an insight into how Laika has interpreted the input and display the entire
        AST structure. It truncates longer strings, so it should normally be convenient
        to browse the entire tree structure:</p>
        <pre>val input = &quot;some *text* example&quot;

Transformer
  .from(Markdown)
  .to(AST)
  .build
  .transform(input)

res0: java.lang.String = Document - Blocks: 1
. Paragraph - Spans: 3
. . Text - &#39;some &#39;
. . Emphasized - Spans: 1
. . . Text - &#39;text&#39;
. . Text - &#39; example&#39;</pre>
        
        <h2 id="file-stream-io-and-binary-formats" class="section">File/Stream IO and Binary Formats</h2>
        <p>In case you want to transform from files or directories, or use one of the binary formats
        like EPUB or PDF, you need to add another dependency to your build:</p>
        <pre>libraryDependencies += &quot;org.planet42&quot; %% &quot;laika-io&quot; % &quot;0.12.1&quot; </pre>
        <p>This module depends on cats-effect, and models all side effects in an abstract effect,
        so that you can use it with cats IO, Monix or Zio.</p>
        <p>The type class constraints of the Library API are <code>Async</code>, <code>ContextShift</code> 
        and for some use cases a <code>Parallel</code> instance.</p>
        
        <h3 id="providing-contextshifts-for-blocking-io" class="section">Providing ContextShifts for Blocking IO</h3>
        <p>Laika gives full control over the <code>ExecutionContext</code> in which the blocking IO operations
        are performed. All the examples below will assume a setup like this:</p>
        <pre>implicit val cs: ContextShift[IO] = 
  IO.contextShift(ExecutionContext.global)
  
val blocker = Blocker.liftExecutionContext(
  ExecutionContext.fromExecutor(Executors.newCachedThreadPool())
)</pre>
        
        <h3 id="transforming-a-single-file" class="section">Transforming a Single File</h3>
        <p>You can use the sequential builder to transform single files or streams:</p>
        <pre>val transformer = Transformer
  .from(Markdown)
  .to(HTML)
  .io(blocker)
  .sequential[IO]
  .build

val res: IO[Unit] = transformer
  .fromFile(&quot;hello.md&quot;)
  .toFile(&quot;hello.html&quot;)
  .transform</pre>
        <p>Note that the first line builds a transformer in the same way as the examples
        for in-memory transformations. The IO module only wraps additional features
        around a transformer.</p>
        <p>The result of the above transformation is an <code>IO[Unit]</code>. If you build applications
        using a stack from the cats-effect ecosystem, like fs2 or http4s, you are good to go.</p>
        <p>If you run in a different stack, like Akka HTTP, you can convert the <code>IO</code> to a <code>Future</code>:</p>
        <pre>val res: Future[Unit] = transformer
  .fromFile(&quot;hello.md&quot;)
  .toFile(&quot;hello.html&quot;)
  .transform
  .unsafeToFuture()</pre>
        
        <h3 id="using-streams" class="section">Using Streams</h3>
        <p>The API is similar to that for File IO, but the creation of the streams are treated
        as an effect, so you have to pass an <code>F[InputStream]</code> or <code>F[OutputStream]</code>:</p>
        <pre>val input: IO[InputStream] = ???
val output: IO[InputStream] = ???

val res: IO[Unit] = transformer
  .fromStream(input)
  .toStream(output, autoClose = false)
  .transform </pre>
        <p>The <code>autoClose</code> flag is <code>true</code> by default, which means the stream will be closed
        after all input has been read or all output has been written.</p>
        
        <h3 id="transforming-an-entire-directory" class="section">Transforming an Entire Directory</h3>
        <p>You can use the parallel builder to transform an entire directory of files:</p>
        <pre>val transformer = Transformer
  .from(Markdown)
  .to(HTML)
  .using(GitHubFlavor)
  .io(blocker)
  .parallel[IO]
  .build
      
val res: IO[Unit] = transformer
  .fromDirectory(&quot;src&quot;)
  .toDirectory(&quot;target&quot;)
  .transform</pre>
        <p>The parser will pick up any document with a recognized suffix (<code>.md</code> or <code>.markdown</code>
        for Markdown, <code>.rst</code> for reStructuredText).</p>
        <p>The target may be a sub-directory of the source, the library will recognize this setup
        and not process the output files as input.</p>
        
        <h3 id="merging-multiple-input-directories" class="section">Merging Multiple Input Directories</h3>
        <p>Laika allows to merge multiple directories into a tree structure with 
        a single root. This allows to keep reusable styles and templates separately,
        or any other kind of flexible setup. </p>
        <p>This flexibility is possible as all directory input gets translated to a virtual
        tree independent of the file system. In theory you could also mix file input
        and in-memory input in the same transformation, although this would probably
        be more of an edge case. </p>
        <p>When the merged directories contain sub-folders with the same name, those
        will be merged recursively. Only files with the same name in the same folder
        are treated as errors.</p>
        <p>Use the <code>fromDirectories</code> method to specify the directories to merge:</p>
        <pre>val res: IO[Unit] = transformer
  .fromDirectories(&quot;markup&quot;, &quot;theme&quot;)
  .toDirectory(&quot;target&quot;)
  .transform
  </pre>
        
        <h3 id="templates" class="section">Templates</h3>
        <p>The directories that contain the markup documents can optionally contain
        templates that get applied to the parsed documents. A very basic template
        for HTML output may look like this:</p>
        <pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;${document.title}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;content&quot;&gt;
      ${document.content}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
        <p>The two placeholders enclosed in double curly braces will be replaced with the
        title and content of the parsed markup document. Everything else will be copied
        to the final document unchanged.</p>
        <p>Every directory can contain a file with the name <code>default.template.&lt;suffix&gt;</code> that
        automatically gets applied to all documents in that directory and its subdirectories,
        unless overridden in a subdirectory. There are also ways to manually declare a
        template for a specific markup document only. </p>
        <p>The suffix must match the output format of the transformation, e.g. <code>.html</code> for HTML,
        <code>.fo</code> for PDF (as it renders via XSL-FO) and <code>.epub.xhtml</code> for EPUB.</p>
        <p>For more details on the template engine, see the chapter <a href="#templates">Templates</a>.</p>
        <p>For features like titles, sections, cross-linking, auto-numbering 
        and tables of content, see the chapter <a href="structure.html#document-structure">Document Structure</a>.</p>
        
        <h3 id="rendering-epub-and-pdf" class="section">Rendering EPUB and PDF</h3>
        <p>These binary formats also rely on the laika-io module, and they always produce a single
        output file, even if the input is an entire directory:</p>
        <pre>val transformer = Transformer
  .from(Markdown)
  .to(EPUB)
  .using(GitHubFlavor)
  .io(blocker)
  .parallel[IO]
  .build
      
val res: IO[Unit] = transformer
  .fromDirectories(&quot;markup&quot;, &quot;theme&quot;)
  .toFile(&quot;output.epub&quot;)
  .transform</pre>
        <p>Note that the API recognizes the kind of transformer passed in and adjusts automatically 
        in which methods it offers. 
        Where it offered the <code>toDirectory</code> method for HTML output for example, 
        it now only offers <code>toStream</code> or <code>toFile</code> in case of EPUB output.</p>
        
        <h3 id="parallel-execution" class="section">Parallel Execution</h3>
        <p>The actual transformation is a three phase process, the first (parsing) and
        third (rendering) can run in parallel. For the second phase this is not possible,
        as this is the rewrite step for the document tree model where things like cross references or
        table of contents get processed that need access to more than just the current
        document. But the rewrite phase is also the least expensive phase so that you
        should still benefit from parallel execution.</p>
        
        <h3 id="character-encoding" class="section">Character Encoding</h3>
        <p>Laika uses the same platform-dependent defaults for file encodings as the
        IO classes in the Scala SDK. The most convenient way to specify an encoding
        is via an implicit:</p>
        <pre>implicit val codec:Codec = Codec.UTF8</pre>
        <p>This codec will then be used by the <code>fromDirectory</code> and <code>toDirectory</code> methods shown
        in the examples above.</p>
        
        <h3 id="error-reporting" class="section">Error Reporting</h3>
        <p>Text markup parsers are usually very resilient. For any input they cannot
        make sense of they fall back to rendering it back as raw text. Therefore
        transformations rarely fail, but the output may not exactly be what you 
        expected.</p>
        <p>For some errors like unresolved link references or illegal directive
        attributes, Laika inserts system message nodes into the tree. By default
        these are ignored by all renderers, but you can explicitly enable
        the rendering of message nodes for a specific message level.</p>
        <p>In the HTML renderer messages are rendered as a span with the class
        <code>system-message</code> and a second class for the level (<code>warning</code>, <code>error</code>, etc.),
        so you can add CSS to easily identify these nodes in the page. This can be
        useful for your own debugging purposes, but also for applications that allow
        users to edit text with markup, giving them visual feedback for their mistakes.</p>
        <p>The following example renders all message with the level <code>Warning</code> or higher:</p>
        <pre>val transformer = Transform
  .from(Markdown)
  .to(HTML)
  .withMessageLevel(Warning)
  .build</pre>      

      </div>
    </div>

  </div>

</body></html>
