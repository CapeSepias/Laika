<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>DirectiveParsers - laika.directive.DirectiveParsers</title>
          <meta name="description" content="DirectiveParsers - laika.directive.DirectiveParsers" />
          <meta name="keywords" content="DirectiveParsers laika.directive.DirectiveParsers" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../index.html';
            var hash = 'laika.directive.DirectiveParsers';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <a href="DirectiveParsers$.html" title="Go to companion"><img src="../../lib/trait_to_object_big.png" /></a>
        <p id="owner"><a href="../package.html" class="extype" name="laika">laika</a>.<a href="package.html" class="extype" name="laika.directive">directive</a></p>
        <h1><a href="DirectiveParsers$.html" title="Go to companion">DirectiveParsers</a></h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">DirectiveParsers</span><span class="result"> extends <a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Parsers for all types of custom directives that can be used
 in templates or as inline or block elements in markup documents.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a>, <a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a>, <a href="../parse/BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a>, <span class="extype" name="scala.util.parsing.combinator.RegexParsers">RegexParsers</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers">Parsers</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a href="DirectiveParsers$$BlockDirectives.html" class="extype" name="laika.directive.DirectiveParsers.BlockDirectives">BlockDirectives</a>, <a href="../template/TemplateParsers$$MarkupBlocks.html" class="extype" name="laika.template.TemplateParsers.MarkupBlocks">MarkupBlocks</a>, <a href="../template/TemplateParsers$$MarkupSpans.html" class="extype" name="laika.template.TemplateParsers.MarkupSpans">MarkupSpans</a>, <a href="DirectiveParsers$$SpanDirectives.html" class="extype" name="laika.directive.DirectiveParsers.SpanDirectives">SpanDirectives</a>, <a href="DirectiveParsers$$TemplateDirectives.html" class="extype" name="laika.directive.DirectiveParsers.TemplateDirectives">TemplateDirectives</a>, <a href="../template/TemplateParsers$$Templates.html" class="extype" name="laika.template.TemplateParsers.Templates">Templates</a></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="laika.directive.DirectiveParsers"><span>DirectiveParsers</span></li><li class="in" name="laika.parse.InlineParsers"><span>InlineParsers</span></li><li class="in" name="laika.parse.MarkupParsers"><span>MarkupParsers</span></li><li class="in" name="laika.parse.BaseParsers"><span>BaseParsers</span></li><li class="in" name="scala.util.parsing.combinator.RegexParsers"><span>RegexParsers</span></li><li class="in" name="scala.util.parsing.combinator.Parsers"><span>Parsers</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="laika.directive.DirectiveParsers.DirectiveContextBase" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="DirectiveContextBaseextendsAnyRef"></a>
      <a id="DirectiveContextBase:DirectiveContextBase"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="DirectiveParsers$DirectiveContextBase.html"><span class="name">DirectiveContextBase</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      
    </li><li name="scala.util.parsing.combinator.RegexParsers.Elem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Elem=Char"></a>
      <a id="Elem:Elem"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Elem</span><span class="result"> = <span class="extype" name="scala.Char">Char</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers â†’ Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.Error" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ErrorextendsParsers.this.NoSuccesswithProductwithSerializable"></a>
      <a id="Error:Error"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">Error</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.NoSuccess">NoSuccess</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.Failure" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FailureextendsParsers.this.NoSuccesswithProductwithSerializable"></a>
      <a id="Failure:Failure"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">Failure</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.NoSuccess">NoSuccess</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.Input" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Input=scala.util.parsing.input.Reader[Parsers.this.Elem]"></a>
      <a id="Input:Input"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Input</span><span class="result"> = <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers.MarkupParserException" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="MarkupParserExceptionextendsRuntimeException"></a>
      <a id="MarkupParserException:MarkupParserException"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../parse/MarkupParsers$MarkupParserException.html"><span class="name">MarkupParserException</span></a><span class="result"> extends <span class="extype" name="scala.RuntimeException">RuntimeException</span></span>
      </span>
      </h4>
      <p class="comment cmt">Exception thrown when parsing a text markup document or fragment fails.</p>
    </li><li name="scala.util.parsing.combinator.Parsers.NoSuccess" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="NoSuccessextendsParsers.this.ParseResult[Nothing]"></a>
      <a id="NoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">NoSuccess</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</span>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.OnceParser" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="OnceParser[+T]extendsParsers.this.Parser[T]"></a>
      <a id="OnceParser[+T]:OnceParser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.ParseResult" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ParseResult[+T]extendsAnyRef"></a>
      <a id="ParseResult[+T]:ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">ParseResult</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.directive.DirectiveParsers.ParsedDirective" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ParsedDirectiveextendsProductwithSerializable"></a>
      <a id="ParsedDirective:ParsedDirective"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="DirectiveParsers$ParsedDirective.html"><span class="name">ParsedDirective</span></a><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="parts">parts: <span class="extype" name="scala.List">List</span>[<a href="DirectiveParsers$Part.html" class="extype" name="laika.directive.DirectiveParsers.Part">Part</a>]</span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <p class="comment cmt">Represents the parsed but unprocessed content of a directive.</p>
    </li><li name="scala.util.parsing.combinator.Parsers.Parser" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]"></a>
      <a id="Parser[+T]:Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends (<span class="extype" name="scala.util.parsing.combinator.Parsers.Input">Input</span>) â‡’ <span class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Parser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers.ParserOps" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ParserOps[A]extendsAnyRef"></a>
      <a id="ParserOps[A]:ParserOps[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../parse/BaseParsers$ParserOps.html"><span class="name">ParserOps</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <p class="comment cmt">Provides additional combinator methods to parsers via implicit conversion.</p>
    </li><li name="laika.directive.DirectiveParsers.Part" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="PartextendsProductwithSerializable"></a>
      <a id="Part:Part"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="DirectiveParsers$Part.html"><span class="name">Part</span></a><span class="params">(<span name="key">key: <a href="Directives$$Key.html" class="extype" name="laika.directive.Directives.Key">Key</a></span>, <span name="content">content: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <p class="comment cmt">Represents one part of a directive (an attribute or a body element).</p>
    </li><li name="laika.directive.DirectiveParsers.PartMap" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="PartMap=Map[laika.directive.Directives.Key,String]"></a>
      <a id="PartMap:PartMap"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">PartMap</span><span class="result"> = <span class="extype" name="scala.collection.immutable.Map">Map</span>[<a href="Directives$$Key.html" class="extype" name="laika.directive.Directives.Key">Key</a>, <span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      
    </li><li name="laika.parse.InlineParsers.ResultBuilder" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="ResultBuilder[Elem,+To]extendsAnyRef"></a>
      <a id="ResultBuilder[Elem,+To]:ResultBuilder[Elem,To]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="../parse/InlineParsers$ResultBuilder.html"><span class="name">ResultBuilder</span></a><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">+To</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <p class="comment cmt">Abstracts the internal process of building up the result of an inline parser.</p>
    </li><li name="laika.parse.InlineParsers.SpanBuilder" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SpanBuilderextendsInlineParsers.this.ResultBuilder[laika.tree.Elements.Span,List[laika.tree.Elements.Span]]"></a>
      <a id="SpanBuilder:SpanBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../parse/InlineParsers$SpanBuilder.html"><span class="name">SpanBuilder</span></a><span class="result"> extends <a href="../parse/InlineParsers$ResultBuilder.html" class="extype" name="laika.parse.InlineParsers.ResultBuilder">ResultBuilder</a>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>, <span class="extype" name="scala.List">List</span>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="comment cmt">ResultBuilder that produces a list of spans.</p>
    </li><li name="scala.util.parsing.combinator.Parsers.Success" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Success[+T]extendsParsers.this.ParseResult[T]withProductwithSerializable"></a>
      <a id="Success[+T]:Success[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">Success</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Success.T">T</span>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.InlineParsers.TextBuilder" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TextBuilderextendsInlineParsers.this.ResultBuilder[String,String]"></a>
      <a id="TextBuilder:TextBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../parse/InlineParsers$TextBuilder.html"><span class="name">TextBuilder</span></a><span class="result"> extends <a href="../parse/InlineParsers$ResultBuilder.html" class="extype" name="laika.parse.InlineParsers.ResultBuilder">ResultBuilder</a>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="comment cmt">ResultBuilder that produces a String.</p>
    </li><li name="laika.parse.MarkupParsers.TextParser" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TextParserextendsMarkupParsers.this.Parser[String]"></a>
      <a id="TextParser:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../parse/MarkupParsers$TextParser.html"><span class="name">TextParser</span></a><span class="result"> extends <a href="../parse/MarkupParsers.html#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.MarkupParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="comment cmt">API for specifying further constraints on the parsers provided by this base trait.</p>
    </li><li name="scala.util.parsing.combinator.Parsers.~" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~[+a,+b]extendsProductwithSerializable"></a>
      <a id="~[+a,+b]:~[a,b]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="tparams">[<span name="a">+a</span>, <span name="b">+b</span>]</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="laika.parse.InlineParsers#prepareSpanParsers" visbl="prt" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="prepareSpanParsers:Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]"></a>
      <a id="prepareSpanParsers:Map[Char,Parser[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prepareSpanParsers</span><span class="result">: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extension hook for modifying the default span parser map.</p><div class="fullcomment"><div class="comment cmt"><p>Extension hook for modifying the default span parser map.
 The default implementation returns the specified parser unchanged.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Concrete Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.NoSuccess" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NoSuccess"></a>
      <a id="NoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">NoSuccess</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#OnceParser" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OnceParser[T](f:Parsers.this.Input=&gt;Parsers.this.ParseResult[T]):Parsers.this.Parser[T]withParsers.this.OnceParser[T]"></a>
      <a id="OnceParser[T]((Input)â‡’ParseResult[T]):Parser[T]withOnceParser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<a href="#Input=scala.util.parsing.input.Reader[Parsers.this.Elem]" class="extmbr" name="laika.directive.DirectiveParsers.Input">Input</a>) â‡’ <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>] with <a href="#OnceParser[+T]extendsParsers.this.Parser[T]" class="extmbr" name="laika.directive.DirectiveParsers.OnceParser">OnceParser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#Parser" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Parser[T](f:Parsers.this.Input=&gt;Parsers.this.ParseResult[T]):Parsers.this.Parser[T]"></a>
      <a id="Parser[T]((Input)â‡’ParseResult[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<a href="#Input=scala.util.parsing.input.Reader[Parsers.this.Elem]" class="extmbr" name="laika.directive.DirectiveParsers.Input">Input</a>) â‡’ <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Parser.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Parser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="accept[U](expected:String,f:PartialFunction[Parsers.this.Elem,U]):Parsers.this.Parser[U]"></a>
      <a id="accept[U](String,PartialFunction[Elem,U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="f">f: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>, <span class="extype" name="scala.util.parsing.combinator.Parsers.accept.U">U</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.accept.U">U</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="accept[ES](es:ES)(implicitevidence$1:ES=&gt;List[Parsers.this.Elem]):Parsers.this.Parser[List[Parsers.this.Elem]]"></a>
      <a id="accept[ES](ES)((ES)â‡’List[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: <span class="extype" name="scala.util.parsing.combinator.Parsers.accept.ES">ES</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (<span class="extype" name="scala.util.parsing.combinator.Parsers.accept.ES">ES</span>) â‡’ <span class="extype" name="scala.List">List</span>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="accept(e:Parsers.this.Elem):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="accept(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="params">(<span name="e">e: <a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#acceptIf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acceptIf(p:Parsers.this.Elem=&gt;Boolean)(err:Parsers.this.Elem=&gt;String):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="acceptIf((Elem)â‡’Boolean)((Elem)â‡’String):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptIf</span><span class="params">(<span name="p">p: (<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>) â‡’ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="params">(<span name="err">err: (<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>) â‡’ <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#acceptMatch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acceptMatch[U](expected:String,f:PartialFunction[Parsers.this.Elem,U]):Parsers.this.Parser[U]"></a>
      <a id="acceptMatch[U](String,PartialFunction[Elem,U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptMatch</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="f">f: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>, <span class="extype" name="scala.util.parsing.combinator.Parsers.acceptMatch.U">U</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.acceptMatch.U">U</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#acceptSeq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acceptSeq[ES](es:ES)(implicitevidence$2:ES=&gt;Iterable[Parsers.this.Elem]):Parsers.this.Parser[List[Parsers.this.Elem]]"></a>
      <a id="acceptSeq[ES](ES)((ES)â‡’Iterable[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptSeq</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: <span class="extype" name="scala.util.parsing.combinator.Parsers.acceptSeq.ES">ES</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (<span class="extype" name="scala.util.parsing.combinator.Parsers.acceptSeq.ES">ES</span>) â‡’ <span class="extype" name="scala.Iterable">Iterable</span>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#any" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="any:MarkupParsers.this.TextParser"></a>
      <a id="any:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">any</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any kind of input, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any kind of input, always succeeds.
 This parser would consume the entire input unless a <code>max</code> constraint
 is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyBut" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyBut(chars:Char*):MarkupParsers.this.TextParser"></a>
      <a id="anyBut(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyBut</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyIn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyIn(ranges:Traversable[Char]*):MarkupParsers.this.TextParser"></a>
      <a id="anyIn(Traversable[Char]*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyIn</span><span class="params">(<span name="ranges">ranges: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are in one of the specified character ranges.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are in one of the specified character ranges.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(chars:Char*):MarkupParsers.this.TextParser"></a>
      <a id="anyOf(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyUntil(until:=&gt;MarkupParsers.this.Parser[Any]):MarkupParsers.this.TextParser"></a>
      <a id="anyUntil(â‡’Parser[Any]):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="until">until: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of characters for which the specified parser fails on the corresponding offset.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of characters for which the specified parser fails on the corresponding offset.
 This parser fails if the end of input is reached without the specified parser ever succeeding or
 if the parser causes an Error result instead of a plain Failure or Success.
 Further constraints like minimum or maximum number of required matching characters can be specified
 through the API of the returned <code>TextParser</code> instance.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyUntil(chars:Char*):MarkupParsers.this.TextParser"></a>
      <a id="anyUntil(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.</p><p> This parser is identical to the <code>anyBut</code> parser except for two differences: this parser fails
 if it reaches the end of the input without seeing any of the specified
 characters and it also consumes this final character, without adding it
 to the result. This parser is usually used when a construct like a span
 enclosed between two characters needs to be parsed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyWhile" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyWhile(p:Char=&gt;Boolean):MarkupParsers.this.TextParser"></a>
      <a id="anyWhile((Char)â‡’Boolean):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) â‡’ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters which satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters which satisfy the specified predicate.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.directive.DirectiveParsers#applyDirective" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="applyDirective[E&lt;:laika.tree.Elements.Element](builder:laika.directive.Directives.BuilderContext[E])(parseResult:DirectiveParsers.this.ParsedDirective,directives:String=&gt;Option[builder.Directive],createContext:(DirectiveParsers.this.PartMap,Option[laika.tree.Documents.DocumentContext])=&gt;builder.DirectiveContext,createPlaceholder:(laika.tree.Documents.DocumentContext=&gt;E)=&gt;E,createInvalidElement:String=&gt;E,directiveTypeDesc:String):E"></a>
      <a id="applyDirective[E&lt;:Element](BuilderContext[E])(ParsedDirective,(String)â‡’Option[Directive],(PartMap,Option[DocumentContext])â‡’DirectiveContext,((DocumentContext)â‡’E)â‡’E,(String)â‡’E,String):E"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">applyDirective</span><span class="tparams">[<span name="E">E &lt;: <a href="../tree/Elements$$Element.html" class="extype" name="laika.tree.Elements.Element">Element</a></span>]</span><span class="params">(<span name="builder">builder: <a href="Directives$$BuilderContext.html" class="extype" name="laika.directive.Directives.BuilderContext">BuilderContext</a>[<span class="extype" name="laika.directive.DirectiveParsers.applyDirective.E">E</span>]</span>)</span><span class="params">(<span name="parseResult">parseResult: <a href="DirectiveParsers$ParsedDirective.html" class="extype" name="laika.directive.DirectiveParsers.ParsedDirective">ParsedDirective</a></span>, <span name="directives">directives: (<span class="extype" name="scala.Predef.String">String</span>) â‡’ <span class="extype" name="scala.Option">Option</span>[<a href="Directives$$BuilderContext$Directive.html" class="extype" name="laika.directive.Directives.BuilderContext.Directive">Directive</a>]</span>, <span name="createContext">createContext: (<a href="#PartMap=Map[laika.directive.Directives.Key,String]" class="extmbr" name="laika.directive.DirectiveParsers.PartMap">PartMap</a>, <span class="extype" name="scala.Option">Option</span>[<a href="../tree/Documents$$DocumentContext.html" class="extype" name="laika.tree.Documents.DocumentContext">DocumentContext</a>]) â‡’ <a href="Directives$$BuilderContext$DirectiveContext.html" class="extype" name="laika.directive.Directives.BuilderContext.DirectiveContext">DirectiveContext</a></span>, <span name="createPlaceholder">createPlaceholder: ((<a href="../tree/Documents$$DocumentContext.html" class="extype" name="laika.tree.Documents.DocumentContext">DocumentContext</a>) â‡’ <span class="extype" name="laika.directive.DirectiveParsers.applyDirective.E">E</span>) â‡’ <span class="extype" name="laika.directive.DirectiveParsers.applyDirective.E">E</span></span>, <span name="createInvalidElement">createInvalidElement: (<span class="extype" name="scala.Predef.String">String</span>) â‡’ <span class="extype" name="laika.directive.DirectiveParsers.applyDirective.E">E</span></span>, <span name="directiveTypeDesc">directiveTypeDesc: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="laika.directive.DirectiveParsers.applyDirective.E">E</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#atStart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="atStart:MarkupParsers.this.Parser[MarkupParsers.this.Parser[Unit]]"></a>
      <a id="atStart:Parser[Parser[Unit]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">atStart</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the start of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the start of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainl1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="chainl1[T,U](first:=&gt;Parsers.this.Parser[T],p:=&gt;Parsers.this.Parser[U],q:=&gt;Parsers.this.Parser[(T,U)=&gt;T]):Parsers.this.Parser[T]"></a>
      <a id="chainl1[T,U](â‡’Parser[T],â‡’Parser[U],â‡’Parser[(T,U)â‡’T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="first">first: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>, <span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.U">U</span>]</span>, <span name="q">q: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.U">U</span>) â‡’ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainl1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="chainl1[T](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[(T,T)=&gt;T]):Parsers.this.Parser[T]"></a>
      <a id="chainl1[T](â‡’Parser[T],â‡’Parser[(T,T)â‡’T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>, <span name="q">q: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>) â‡’ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainr1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="chainr1[T,U](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[(T,U)=&gt;U],combine:(T,U)=&gt;U,first:U):Parsers.this.Parser[U]"></a>
      <a id="chainr1[T,U](â‡’Parser[T],â‡’Parser[(T,U)â‡’U],(T,U)â‡’U,U):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainr1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.T">T</span>]</span>, <span name="q">q: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>) â‡’ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>]</span>, <span name="combine">combine: (<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>) â‡’ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span></span>, <span name="first">first: <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#charToTraversalble" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="charToTraversalble(char:Char):Traversable[Char]"></a>
      <a id="charToTraversalble(Char):Traversable[Char]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">charToTraversalble</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#commit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="commit[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[T]"></a>
      <a id="commit[T](â‡’Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commit</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.commit.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.commit.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.directive.DirectiveParsers#declaration" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="declaration:DirectiveParsers.this.Parser[(String,List[DirectiveParsers.this.Part])]"></a>
      <a id="declaration:Parser[(String,List[Part])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">declaration</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.List">List</span>[<a href="DirectiveParsers$Part.html" class="extype" name="laika.directive.DirectiveParsers.Part">Part</a>])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full directive declaration, containing all its attributes,
 but not the body elements.</p>
    </li><li name="laika.directive.DirectiveParsers#directiveParser" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="directiveParser(bodyContent:DirectiveParsers.this.Parser[String],includeStartChar:Boolean):DirectiveParsers.this.Parser[DirectiveParsers.this.ParsedDirective]"></a>
      <a id="directiveParser(Parser[String],Boolean):Parser[ParsedDirective]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">directiveParser</span><span class="params">(<span name="bodyContent">bodyContent: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>, <span name="includeStartChar">includeStartChar: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="DirectiveParsers$ParsedDirective.html" class="extype" name="laika.directive.DirectiveParsers.ParsedDirective">ParsedDirective</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses one directive instance containing its name declaration,
 all attributes and all body elements.</p><div class="fullcomment"><div class="comment cmt"><p>Parses one directive instance containing its name declaration,
 all attributes and all body elements.
</p></div><dl class="paramcmts block"><dt class="param">bodyContent</dt><dd class="cmt"><p>the parser for the body content which is different for a block directive than for a span or template directive</p></dd><dt class="param">includeStartChar</dt><dd class="cmt"><p>indicates whether the starting '@' has to be parsed by this parser
</p></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#elem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="elem(e:Parsers.this.Elem):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="elem(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="e">e: <a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#elem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="elem(kind:String,p:Parsers.this.Elem=&gt;Boolean):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="elem(String,(Elem)â‡’Boolean):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="kind">kind: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="p">p: (<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>) â‡’ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.directive.DirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#eof" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eof:MarkupParsers.this.Parser[String]"></a>
      <a id="eof:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eof</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#eol" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eol:MarkupParsers.this.Parser[String]"></a>
      <a id="eol:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eol</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of a line, including the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of a line, including the end of the input.
 Produces an empty string as a result and consumes any new line characters.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#err" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="err(msg:String):Parsers.this.Parser[Nothing]"></a>
      <a id="err(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">err</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#failure" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="failure(msg:String):Parsers.this.Parser[Nothing]"></a>
      <a id="failure(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#guard" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="guard[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[T]"></a>
      <a id="guard[T](â‡’Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">guard</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.guard.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.guard.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#handleWhiteSpace" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="handleWhiteSpace(source:CharSequence,offset:Int):Int"></a>
      <a id="handleWhiteSpace(CharSequence,Int):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleWhiteSpace</span><span class="params">(<span name="source">source: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>, <span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="laika.parse.InlineParsers#inline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inline[Elem,To](text:=&gt;InlineParsers.this.TextParser,nested:=&gt;Map[Char,InlineParsers.this.Parser[Elem]],resultBuilder:=&gt;InlineParsers.this.ResultBuilder[Elem,To]):InlineParsers.this.Parser[To]"></a>
      <a id="inline[Elem,To](â‡’TextParser,â‡’Map[Char,Parser[Elem]],â‡’ResultBuilder[Elem,To]):Parser[To]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inline</span><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">To</span>]</span><span class="params">(<span name="text">text: â‡’ <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>, <span name="nested">nested: â‡’ <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.InlineParsers.inline.Elem">Elem</span>]]</span>, <span name="resultBuilder">resultBuilder: â‡’ <a href="#ResultBuilder[Elem,+To]extendsAnyRef" class="extmbr" name="laika.parse.InlineParsers.ResultBuilder">ResultBuilder</a>[<span class="extype" name="laika.parse.InlineParsers.inline.Elem">Elem</span>, <span class="extype" name="laika.parse.InlineParsers.inline.To">To</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.InlineParsers.inline.To">To</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Generic base parser that parses inline elements based on the specified
 helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Generic base parser that parses inline elements based on the specified
 helper parsers. Usually not used directly by parser implementations,
 this is the base parser the other inline parsers of this trait delegate to.
</p></div><dl class="paramcmts block"><dt class="tparam">Elem</dt><dd class="cmt"><p>the element type produced by a single parser for a nested span</p></dd><dt class="tparam">To</dt><dd class="cmt"><p>the type of the result this parser produces</p></dd><dt class="param">nested</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser for nested span elements</p></dd><dt class="param">resultBuilder</dt><dd class="cmt"><p>responsible for building the final result of this parser based on the results of the helper parsers</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#literal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="literal(s:String):RegexParsers.this.Parser[String]"></a>
      <a id="literal(String):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#log" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="log[T](p:=&gt;Parsers.this.Parser[T])(name:String):Parsers.this.Parser[T]"></a>
      <a id="log[T](â‡’Parser[T])(String):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">log</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.log.T">T</span>]</span>)</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.log.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers#lookBehind" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookBehind[T](offset:Int,parser:=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[T]"></a>
      <a id="lookBehind[T](Int,â‡’Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookBehind</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="parser">parser: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.lookBehind.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.lookBehind.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#mkList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mkList[T]:Parsers.this.~[T,List[T]]=&gt;List[T]"></a>
      <a id="mkList[T]:(~[T,List[T]])â‡’List[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkList</span><span class="tparams">[<span name="T">T</span>]</span><span class="result">: (<a href="#~[+a,+b]extendsProductwithSerializable" class="extmbr" name="laika.directive.DirectiveParsers.~">~</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.mkList.T">T</span>, <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.mkList.T">T</span>]]) â‡’ <span class="extype" name="scala.collection.immutable.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.mkList.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.directive.DirectiveParsers#nameDecl" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="nameDecl:DirectiveParsers.this.Parser[String]"></a>
      <a id="nameDecl:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">nameDecl</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a name declaration that start with a letter and
 continues with letters, numbers or the symbols '-' or '_'.</p>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#not" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="not[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[Unit]"></a>
      <a id="not[T](â‡’Parser[T]):Parser[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.not.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#opt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[Option[T]]"></a>
      <a id="opt[T](â‡’Parser[T]):Parser[Option[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.opt.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.opt.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#optimizedCharLookup" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optimizedCharLookup(chars:Char*):Char=&gt;Boolean"></a>
      <a id="optimizedCharLookup(Char*):(Char)â‡’Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedCharLookup</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: (<span class="extype" name="scala.Char">Char</span>) â‡’ <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#optimizedRangeLookup" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optimizedRangeLookup(ranges:Traversable[Char]*):Char=&gt;Boolean"></a>
      <a id="optimizedRangeLookup(Traversable[Char]*):(Char)â‡’Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedRangeLookup</span><span class="params">(<span name="ranges">ranges: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]*</span>)</span><span class="result">: (<span class="extype" name="scala.Char">Char</span>) â‡’ <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified ranges of characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified ranges of characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse[T](p:RegexParsers.this.Parser[T],in:java.io.Reader):RegexParsers.this.ParseResult[T]"></a>
      <a id="parse[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.io.Reader">Reader</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse[T](p:RegexParsers.this.Parser[T],in:CharSequence):RegexParsers.this.ParseResult[T]"></a>
      <a id="parse[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse[T](p:RegexParsers.this.Parser[T],in:scala.util.parsing.input.Reader[Char]):RegexParsers.this.ParseResult[T]"></a>
      <a id="parse[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>, <span name="in">in: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAll[T](p:RegexParsers.this.Parser[T],in:CharSequence):RegexParsers.this.ParseResult[T]"></a>
      <a id="parseAll[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAll[T](p:RegexParsers.this.Parser[T],in:java.io.Reader):RegexParsers.this.ParseResult[T]"></a>
      <a id="parseAll[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.io.Reader">Reader</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAll[T](p:RegexParsers.this.Parser[T],in:scala.util.parsing.input.Reader[Char]):RegexParsers.this.ParseResult[T]"></a>
      <a id="parseAll[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>, <span name="in">in: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.directive.DirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="laika.parse.InlineParsers#parseInline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseInline(source:String):List[laika.tree.Elements.Span]"></a>
      <a id="parseInline(String):List[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseInline</span><span class="params">(<span name="source">source: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input string and produces a list of spans, using the
 default span parsers returned by the <code>spanParsers</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input string and produces a list of spans, using the
 default span parsers returned by the <code>spanParsers</code> method.</p><p> This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text. Some parsers might additionally insert system message elements in case
 of markup errors.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p>the result of the parser in form of a list of spans
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#parseInline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseInline(source:String,spanParsers:Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]):List[laika.tree.Elements.Span]"></a>
      <a id="parseInline(String,Map[Char,Parser[Span]]):List[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseInline</span><span class="params">(<span name="source">source: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="spanParsers">spanParsers: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input string and produces a list of spans.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input string and produces a list of spans.</p><p> This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text. Some parsers might additionally insert system message elements in case
 of markup errors.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>the input to parse</p></dd><dt class="param">spanParsers</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser</p></dd><dt>returns</dt><dd class="cmt"><p>the result of the parser in form of a list of spans
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#parseMarkup" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseMarkup[T](parser:MarkupParsers.this.Parser[T],reader:scala.util.parsing.input.Reader[Char]):T"></a>
      <a id="parseMarkup[T](Parser[T],Reader[Char]):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span>]</span>, <span name="reader">reader: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input from the specified reader and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input from the specified reader and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#parseMarkup" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseMarkup[T](parser:MarkupParsers.this.Parser[T],source:String):T"></a>
      <a id="parseMarkup[T](Parser[T],String):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span>]</span>, <span name="source">source: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the specified input string and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the specified input string and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#phrase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="phrase[T](p:RegexParsers.this.Parser[T]):RegexParsers.this.Parser[T]"></a>
      <a id="phrase[T](Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">phrase</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.phrase.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.phrase.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers â†’ Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#positioned" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="positioned[T&lt;:scala.util.parsing.input.Positional](p:=&gt;RegexParsers.this.Parser[T]):RegexParsers.this.Parser[T]"></a>
      <a id="positioned[T&lt;:Positional](â‡’Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">positioned</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.util.parsing.input.Positional">Positional</span></span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.positioned.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.positioned.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers â†’ Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#regex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="regex(r:scala.util.matching.Regex):RegexParsers.this.Parser[String]"></a>
      <a id="regex(Regex):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">regex</span><span class="params">(<span name="r">r: <span class="extype" name="scala.util.matching.Regex">Regex</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers#rep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep[T](first:=&gt;BaseParsers.this.Parser[T],next:T=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[List[T]]"></a>
      <a id="rep[T](â‡’Parser[T],(T)â‡’Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="first">first: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>]</span>, <span name="next">next: (<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>) â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for repetitions where all subsequent parsers
 after the first depend on the result of the previous.</p><div class="fullcomment"><div class="comment cmt"><p>A parser generator for repetitions where all subsequent parsers
 after the first depend on the result of the previous.
</p></div><dl class="paramcmts block"><dt class="param">first</dt><dd class="cmt"><p>the parser to use for the first piece of input</p></dd><dt class="param">next</dt><dd class="cmt"><p>a function that determines the next parser based on the result of the previous
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep[T](â‡’Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep1[T](first:=&gt;Parsers.this.Parser[T],p0:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep1[T](â‡’Parser[T],â‡’Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="first">first: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]</span>, <span name="p0">p0: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> The <code>p0</code> call-by-name arguments is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.</p></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep1[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep1[T](â‡’Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1sep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep1sep[T](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[Any]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep1sep[T](â‡’Parser[T],â‡’Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1sep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1sep.T">T</span>]</span>, <span name="q">q: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1sep.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers#repMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repMax[T](num:Int,p:=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[List[T]]"></a>
      <a id="repMax[T](Int,â‡’Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMax</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.repMax.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.BaseParsers.repMax.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at most the specified number of repetitions, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at most the specified number of repetitions, always succeeds.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="laika.parse.BaseParsers#repMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repMin[T](num:Int,p:=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[List[T]]"></a>
      <a id="repMin[T](Int,â‡’Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMin</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.repMin.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.BaseParsers.repMin.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at least the specified number of repetitions or otherwise fails.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at least the specified number of repetitions or otherwise fails.
 Continues to apply the parser after the minimum has been reached until if fails.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#repN" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repN[T](num:Int,p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="repN[T](Int,â‡’Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repN</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repN.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repN.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#repsep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repsep[T](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[Any]):Parsers.this.Parser[List[T]]"></a>
      <a id="repsep[T](â‡’Parser[T],â‡’Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repsep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repsep.T">T</span>]</span>, <span name="q">q: â‡’ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repsep.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#skipWhitespace" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="skipWhitespace:Boolean"></a>
      <a id="skipWhitespace:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">skipWhitespace</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a> â†’ RegexParsers</dd></dl></div>
    </li><li name="laika.parse.InlineParsers#spanParsers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spanParsers:Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]"></a>
      <a id="spanParsers:Map[Char,Parser[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">spanParsers</span><span class="result">: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The mapping of markup start characters to their corresponding
 span parsers.</p><div class="fullcomment"><div class="comment cmt"><p>The mapping of markup start characters to their corresponding
 span parsers.</p><p> A parser mapped to a start character is not required
 to successfully parse the subsequent input. If it fails the
 character that triggered the parser invocation will be treated
 as normal text. The mapping is merely used as a performance
 optimization. The parser will be invoked with the input
 offset pointing to the character after the one
 specified as the key for the mapping.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#spans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spans(parser:=&gt;InlineParsers.this.TextParser,spanParsers:=&gt;Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]):InlineParsers.this.Parser[List[laika.tree.Elements.Span]]"></a>
      <a id="spans(â‡’TextParser,â‡’Map[Char,Parser[Span]]):Parser[List[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">spans</span><span class="params">(<span name="parser">parser: â‡’ <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>, <span name="spanParsers">spanParsers: â‡’ <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<a href="../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a list of spans based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a list of spans based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for the text of the current span element</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#success" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="success[T](v:T):Parsers.this.Parser[T]"></a>
      <a id="success[T](T):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: <span class="extype" name="scala.util.parsing.combinator.Parsers.success.T">T</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.success.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](â‡’T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: â‡’ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.InlineParsers#text" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text(parser:=&gt;InlineParsers.this.TextParser,nested:=&gt;Map[Char,InlineParsers.this.Parser[String]]):InlineParsers.this.Parser[String]"></a>
      <a id="text(â‡’TextParser,â‡’Map[Char,Parser[String]]):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">text</span><span class="params">(<span name="parser">parser: â‡’ <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>, <span name="nested">nested: â‡’ <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses text based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses text based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for the text of the current element</p></dd><dt class="param">nested</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser for nested span elements</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.BaseParsers#toParserOps" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toParserOps[A](parser:BaseParsers.this.Parser[A]):BaseParsers.this.ParserOps[A]"></a>
      <a id="toParserOps[A](Parser[A]):ParserOps[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toParserOps</span><span class="tparams">[<span name="A">A</span>]</span><span class="params">(<span name="parser">parser: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.toParserOps.A">A</span>]</span>)</span><span class="result">: <a href="#ParserOps[A]extendsAnyRef" class="extmbr" name="laika.parse.BaseParsers.ParserOps">ParserOps</a>[<span class="extype" name="laika.parse.BaseParsers.toParserOps.A">A</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef â†’ Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#whiteSpace" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="whiteSpace:scala.util.matching.Regex"></a>
      <a id="whiteSpace:Regex"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">whiteSpace</span><span class="result">: <span class="extype" name="scala.util.matching.Regex">Regex</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="laika.directive.DirectiveParsers#withSource" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="withSource[T](p:DirectiveParsers.this.Parser[T]):DirectiveParsers.this.Parser[(T,String)]"></a>
      <a id="withSource[T](Parser[T]):Parser[(T,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withSource</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.directive.DirectiveParsers.withSource.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.directive.DirectiveParsers.Parser">Parser</a>[(<span class="extype" name="laika.directive.DirectiveParsers.withSource.T">T</span>, <span class="extype" name="scala.Predef.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Groups the result of the parser and the source string
 that it successfully parsed into a tupled result.</p>
    </li><li name="laika.parse.MarkupParsers#ws" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ws:MarkupParsers.this.TextParser"></a>
      <a id="ws:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ws</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses horizontal whitespace (space and tab).</p><div class="fullcomment"><div class="comment cmt"><p>Parses horizontal whitespace (space and tab).
 Always succeeds, consuming all whitespace found.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.directive.DirectiveParsers#wsOrNl" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="wsOrNl:DirectiveParsers.this.TextParser"></a>
      <a id="wsOrNl:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">wsOrNl</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses horizontal whitespace or newline characters.</p>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="scala.util.parsing.combinator.Parsers#lastNoSuccess" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lastNoSuccess:Parsers.this.NoSuccess"></a>
      <a id="lastNoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.10.0) lastNoSuccess was not thread-safe and will be removed in 2.11.0">lastNoSuccess</span><span class="result">: <a href="#NoSuccessextendsParsers.this.ParseResult[Nothing]" class="extmbr" name="laika.directive.DirectiveParsers.NoSuccess">NoSuccess</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.10.0)</i> lastNoSuccess was not thread-safe and will be removed in 2.11.0</p></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#lastNoSuccess_=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lastNoSuccess_=(x:Parsers.this.NoSuccess):Unit"></a>
      <a id="lastNoSuccess_=(NoSuccess):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: lastNoSuccess_$eq. Deprecated: (Since version 2.10.0) lastNoSuccess was not thread-safe and will be removed in 2.11.0" class="name deprecated">lastNoSuccess_=</span><span class="params">(<span name="x">x: <a href="#NoSuccessextendsParsers.this.ParseResult[Nothing]" class="extmbr" name="laika.directive.DirectiveParsers.NoSuccess">NoSuccess</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.10.0)</i> lastNoSuccess was not thread-safe and will be removed in 2.11.0</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="laika.parse.InlineParsers">
              <h3>Inherited from <a href="../parse/InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></h3>
            </div><div class="parent" name="laika.parse.MarkupParsers">
              <h3>Inherited from <a href="../parse/MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></h3>
            </div><div class="parent" name="laika.parse.BaseParsers">
              <h3>Inherited from <a href="../parse/BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></h3>
            </div><div class="parent" name="scala.util.parsing.combinator.RegexParsers">
              <h3>Inherited from <span class="extype" name="scala.util.parsing.combinator.RegexParsers">RegexParsers</span></h3>
            </div><div class="parent" name="scala.util.parsing.combinator.Parsers">
              <h3>Inherited from <span class="extype" name="scala.util.parsing.combinator.Parsers">Parsers</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../lib/template.js"></script>
    </body>
      </html>