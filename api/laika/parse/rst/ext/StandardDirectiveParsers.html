<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>StandardDirectiveParsers - laika.parse.rst.ext.StandardDirectiveParsers</title>
          <meta name="description" content="StandardDirectiveParsers - laika.parse.rst.ext.StandardDirectiveParsers" />
          <meta name="keywords" content="StandardDirectiveParsers laika.parse.rst.ext.StandardDirectiveParsers" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../../index.html';
            var hash = 'laika.parse.rst.ext.StandardDirectiveParsers';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../../lib/trait_big.png" />
        <p id="owner"><a href="../../../package.html" class="extype" name="laika">laika</a>.<a href="../../package.html" class="extype" name="laika.parse">parse</a>.<a href="../package.html" class="extype" name="laika.parse.rst">rst</a>.<a href="package.html" class="extype" name="laika.parse.rst.ext">ext</a></p>
        <h1>StandardDirectiveParsers</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">StandardDirectiveParsers</span><span class="result"> extends <a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a> with <a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>Defines the custom argument and body parsers for the standard directives.
 Most of these delegate to the default block or inline parsers for <code>reStructuredText</code>,
 but often do only except one specific block type like <code>Table</code> or <code>QuotedBlock</code> whereas
 the default block parser usually accepts any of the blocks.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a>, <a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a>, <a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">parse.InlineParsers</a>, <a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a>, <a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a>, <a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a>, <a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a>, <a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">parse.BlockParsers</a>, <a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a>, <a href="../../BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a>, <span class="extype" name="scala.util.parsing.combinator.RegexParsers">RegexParsers</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers">Parsers</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="laika.parse.rst.ext.StandardDirectiveParsers"><span>StandardDirectiveParsers</span></li><li class="in" name="laika.parse.rst.InlineParsers"><span>InlineParsers</span></li><li class="in" name="laika.parse.util.URIParsers"><span>URIParsers</span></li><li class="in" name="laika.parse.InlineParsers"><span>InlineParsers</span></li><li class="in" name="laika.parse.rst.BlockParsers"><span>BlockParsers</span></li><li class="in" name="laika.parse.rst.ExplicitBlockParsers"><span>ExplicitBlockParsers</span></li><li class="in" name="laika.parse.rst.TableParsers"><span>TableParsers</span></li><li class="in" name="laika.parse.rst.ListParsers"><span>ListParsers</span></li><li class="in" name="laika.parse.BlockParsers"><span>BlockParsers</span></li><li class="in" name="laika.parse.MarkupParsers"><span>MarkupParsers</span></li><li class="in" name="laika.parse.BaseParsers"><span>BaseParsers</span></li><li class="in" name="scala.util.parsing.combinator.RegexParsers"><span>RegexParsers</span></li><li class="in" name="scala.util.parsing.combinator.Parsers"><span>Parsers</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="laika.parse.rst.TableParsers.CellBuilder" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CellBuilderextendsAnyRef"></a>
      <a id="CellBuilder:(TableParsers.this)#CellBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../TableParsers$CellBuilder.html"><span class="name">CellBuilder</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.TableParsers.CellBuilderRef" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="CellBuilderRefextendsAnyRef"></a>
      <a id="CellBuilderRef:(TableParsers.this)#CellBuilderRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../TableParsers$CellBuilderRef.html"><span class="name">CellBuilderRef</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.TableParsers.ColumnBuilder" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ColumnBuilderextendsAnyRef"></a>
      <a id="ColumnBuilder:(TableParsers.this)#ColumnBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../TableParsers$ColumnBuilder.html"><span class="name">ColumnBuilder</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers.Elem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Elem=Char"></a>
      <a id="Elem:Elem"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Elem</span><span class="result"> = <span class="extype" name="scala.Char">Char</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.Error" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ErrorextendsParsers.this.NoSuccesswithProductwithSerializable"></a>
      <a id="Error:Error"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">Error</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.NoSuccess">NoSuccess</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.Failure" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="FailureextendsParsers.this.NoSuccesswithProductwithSerializable"></a>
      <a id="Failure:Failure"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">Failure</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.NoSuccess">NoSuccess</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BlockParsers.IndentedBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="IndentedBlockextendsProductwithSerializable"></a>
      <a id="IndentedBlock:IndentedBlock"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="../../BlockParsers$IndentedBlock.html"><span class="name">IndentedBlock</span></a><span class="params">(<span name="nestLevel">nestLevel: <span class="extype" name="scala.Int">Int</span></span>, <span name="minIndent">minIndent: <span class="extype" name="scala.Int">Int</span></span>, <span name="lines">lines: <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.Input" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Input=scala.util.parsing.input.Reader[Parsers.this.Elem]"></a>
      <a id="Input:Input"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">type</span>
      </span>
      <span class="symbol">
        <span class="name">Input</span><span class="result"> = <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.rst.TableParsers.MalformedTableException" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="MalformedTableExceptionextendsRuntimeException"></a>
      <a id="MalformedTableException:(TableParsers.this)#MalformedTableException"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../TableParsers$MalformedTableException.html"><span class="name">MalformedTableException</span></a><span class="result"> extends <span class="extype" name="scala.RuntimeException">RuntimeException</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers.MarkupParserException" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="MarkupParserExceptionextendsRuntimeException"></a>
      <a id="MarkupParserException:MarkupParserException"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../../MarkupParsers$MarkupParserException.html"><span class="name">MarkupParserException</span></a><span class="result"> extends <span class="extype" name="scala.RuntimeException">RuntimeException</span></span>
      </span>
      </h4>
      <p class="comment cmt">Exception thrown when parsing a text markup document or fragment fails.</p>
    </li><li name="laika.parse.BlockParsers.NestedCharSequenceReader" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="NestedCharSequenceReaderextendsCharSequenceReader"></a>
      <a id="NestedCharSequenceReader:NestedCharSequenceReader"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../../BlockParsers$NestedCharSequenceReader.html"><span class="name">NestedCharSequenceReader</span></a><span class="result"> extends <span class="extype" name="scala.util.parsing.input.CharSequenceReader">CharSequenceReader</span></span>
      </span>
      </h4>
      <p class="comment cmt">Reader implementation that keeps the current nest level in case
 of recursive parsing of block-level elements.</p>
    </li><li name="scala.util.parsing.combinator.Parsers.NoSuccess" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="NoSuccessextendsParsers.this.ParseResult[Nothing]"></a>
      <a id="NoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">NoSuccess</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</span>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.OnceParser" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="OnceParser[+T]extendsParsers.this.Parser[T]"></a>
      <a id="OnceParser[+T]:OnceParser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.Parser">Parser</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.ParseResult" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="ParseResult[+T]extendsAnyRef"></a>
      <a id="ParseResult[+T]:ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">ParseResult</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.Parser" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]"></a>
      <a id="Parser[+T]:Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends (<span class="extype" name="scala.util.parsing.combinator.Parsers.Input">Input</span>) ⇒ <span class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Parser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers.ParserOps" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ParserOps[A]extendsAnyRef"></a>
      <a id="ParserOps[A]:ParserOps[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../../BaseParsers$ParserOps.html"><span class="name">ParserOps</span></a><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <p class="comment cmt">Provides additional combinator methods to parsers via implicit conversion.</p>
    </li><li name="laika.parse.rst.InlineParsers.ReferenceName" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="ReferenceNameextendsProductwithSerializable"></a>
      <a id="ReferenceName:ReferenceName"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="../InlineParsers$ReferenceName.html"><span class="name">ReferenceName</span></a><span class="params">(<span name="original">original: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <p class="comment cmt">Represent a reference name.</p>
    </li><li name="laika.parse.InlineParsers.ResultBuilder" visbl="pub" data-isabs="true" fullComment="no" group="Ungrouped">
      <a id="ResultBuilder[Elem,+To]extendsAnyRef"></a>
      <a id="ResultBuilder[Elem,+To]:ResultBuilder[Elem,To]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="../../InlineParsers$ResultBuilder.html"><span class="name">ResultBuilder</span></a><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">+To</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <p class="comment cmt">Abstracts the internal process of building up the result of an inline parser.</p>
    </li><li name="laika.parse.rst.InlineParsers.Reverse" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ReverseextendsElements.ElementwithElements.SpanwithProductwithSerializable"></a>
      <a id="Reverse:Reverse"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="../InlineParsers$Reverse.html"><span class="name">Reverse</span></a><span class="params">(<span name="length">length: <span class="extype" name="scala.Int">Int</span></span>, <span name="target">target: <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a></span>, <span name="fallback">fallback: <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a></span>, <span name="options">options: <a href="../../../tree/Elements$$Options.html" class="extype" name="laika.tree.Elements.Options">Options</a> = <span class="symbol">laika.tree.Elements.NoOpt</span></span>)</span><span class="result"> extends <a href="../../../tree/Elements$$Element.html" class="extype" name="laika.tree.Elements.Element">Element</a> with <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.TableParsers.RowBuilder" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="RowBuilderextendsAnyRef"></a>
      <a id="RowBuilder:(TableParsers.this)#RowBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../TableParsers$RowBuilder.html"><span class="name">RowBuilder</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers.SpanBuilder" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="SpanBuilderextendsInlineParsers.this.ResultBuilder[laika.tree.Elements.Span,List[laika.tree.Elements.Span]]"></a>
      <a id="SpanBuilder:SpanBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../../InlineParsers$SpanBuilder.html"><span class="name">SpanBuilder</span></a><span class="result"> extends <a href="../../InlineParsers$ResultBuilder.html" class="extype" name="laika.parse.InlineParsers.ResultBuilder">ResultBuilder</a>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>, <span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="comment cmt">ResultBuilder that produces a list of spans.</p>
    </li><li name="scala.util.parsing.combinator.Parsers.Success" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Success[+T]extendsParsers.this.ParseResult[T]withProductwithSerializable"></a>
      <a id="Success[+T]:Success[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span class="name">Success</span><span class="tparams">[<span name="T">+T</span>]</span><span class="result"> extends <span class="extype" name="scala.util.parsing.combinator.Parsers.ParseResult">ParseResult</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Success.T">T</span>] with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.rst.TableParsers.TableBuilder" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="TableBuilderextendsAnyRef"></a>
      <a id="TableBuilder:(TableParsers.this)#TableBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../TableParsers$TableBuilder.html"><span class="name">TableBuilder</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers.TextBuilder" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TextBuilderextendsInlineParsers.this.ResultBuilder[String,String]"></a>
      <a id="TextBuilder:TextBuilder"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../../InlineParsers$TextBuilder.html"><span class="name">TextBuilder</span></a><span class="result"> extends <a href="../../InlineParsers$ResultBuilder.html" class="extype" name="laika.parse.InlineParsers.ResultBuilder">ResultBuilder</a>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="comment cmt">ResultBuilder that produces a String.</p>
    </li><li name="laika.parse.MarkupParsers.TextParser" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TextParserextendsMarkupParsers.this.Parser[String]"></a>
      <a id="TextParser:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="../../MarkupParsers$TextParser.html"><span class="name">TextParser</span></a><span class="result"> extends <a href="../../MarkupParsers.html#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.MarkupParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="comment cmt">API for specifying further constraints on the parsers provided by this base trait.</p>
    </li><li name="scala.util.parsing.combinator.Parsers.~" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="~[+a,+b]extendsProductwithSerializable"></a>
      <a id="~[+a,+b]:~[a,b]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $tilde" class="name">~</span><span class="tparams">[<span name="a">+a</span>, <span name="b">+b</span>]</span><span class="result"> extends <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers.NoSuccess" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="NoSuccess"></a>
      <a id="NoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">NoSuccess</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#OnceParser" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="OnceParser[T](f:Parsers.this.Input=&gt;Parsers.this.ParseResult[T]):Parsers.this.Parser[T]withParsers.this.OnceParser[T]"></a>
      <a id="OnceParser[T]((Input)⇒ParseResult[T]):Parser[T]withOnceParser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">OnceParser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<a href="#Input=scala.util.parsing.input.Reader[Parsers.this.Elem]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Input">Input</a>) ⇒ <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>] with <a href="#OnceParser[+T]extendsParsers.this.Parser[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.OnceParser">OnceParser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.OnceParser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#Parser" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="Parser[T](f:Parsers.this.Input=&gt;Parsers.this.ParseResult[T]):Parsers.this.Parser[T]"></a>
      <a id="Parser[T]((Input)⇒ParseResult[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">Parser</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="f">f: (<a href="#Input=scala.util.parsing.input.Reader[Parsers.this.Elem]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Input">Input</a>) ⇒ <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Parser.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.Parser.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="accept[U](expected:String,f:PartialFunction[Parsers.this.Elem,U]):Parsers.this.Parser[U]"></a>
      <a id="accept[U](String,PartialFunction[Elem,U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="f">f: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>, <span class="extype" name="scala.util.parsing.combinator.Parsers.accept.U">U</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.accept.U">U</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="accept[ES](es:ES)(implicitevidence$1:ES=&gt;List[Parsers.this.Elem]):Parsers.this.Parser[List[Parsers.this.Elem]]"></a>
      <a id="accept[ES](ES)((ES)⇒List[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: <span class="extype" name="scala.util.parsing.combinator.Parsers.accept.ES">ES</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (<span class="extype" name="scala.util.parsing.combinator.Parsers.accept.ES">ES</span>) ⇒ <span class="extype" name="scala.List">List</span>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#accept" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="accept(e:Parsers.this.Elem):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="accept(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">accept</span><span class="params">(<span name="e">e: <a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#acceptIf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acceptIf(p:Parsers.this.Elem=&gt;Boolean)(err:Parsers.this.Elem=&gt;String):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="acceptIf((Elem)⇒Boolean)((Elem)⇒String):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptIf</span><span class="params">(<span name="p">p: (<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="params">(<span name="err">err: (<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>) ⇒ <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#acceptMatch" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acceptMatch[U](expected:String,f:PartialFunction[Parsers.this.Elem,U]):Parsers.this.Parser[U]"></a>
      <a id="acceptMatch[U](String,PartialFunction[Elem,U]):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptMatch</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="expected">expected: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="f">f: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>, <span class="extype" name="scala.util.parsing.combinator.Parsers.acceptMatch.U">U</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.acceptMatch.U">U</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#acceptSeq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acceptSeq[ES](es:ES)(implicitevidence$2:ES=&gt;Iterable[Parsers.this.Elem]):Parsers.this.Parser[List[Parsers.this.Elem]]"></a>
      <a id="acceptSeq[ES](ES)((ES)⇒Iterable[Elem]):Parser[List[Elem]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acceptSeq</span><span class="tparams">[<span name="ES">ES</span>]</span><span class="params">(<span name="es">es: <span class="extype" name="scala.util.parsing.combinator.Parsers.acceptSeq.ES">ES</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: (<span class="extype" name="scala.util.parsing.combinator.Parsers.acceptSeq.ES">ES</span>) ⇒ <span class="extype" name="scala.Iterable">Iterable</span>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#addrSpec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="addrSpec:URIParsers.this.Parser[String]"></a>
      <a id="addrSpec:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">addrSpec</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single email address as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single email address as defined in RFC 6068.</p><pre>addr-spec = local-part <span class="lit">"@"</span> domain</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#alpha" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="alpha:URIParsers.this.TextParser"></a>
      <a id="alpha:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">alpha</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses letters according to RFC 2234.</p><div class="fullcomment"><div class="comment cmt"><p>Parses letters according to RFC 2234.</p><pre>ALPHA =  %x41-<span class="num">5</span>A / %x61-<span class="num">7</span>A ; A-Z / a-z</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#any" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="any:MarkupParsers.this.TextParser"></a>
      <a id="any:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">any</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any kind of input, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any kind of input, always succeeds.
 This parser would consume the entire input unless a <code>max</code> constraint
 is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyBut" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyBut(chars:Char*):MarkupParsers.this.TextParser"></a>
      <a id="anyBut(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyBut</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyIn" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyIn(ranges:Traversable[Char]*):MarkupParsers.this.TextParser"></a>
      <a id="anyIn(Traversable[Char]*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyIn</span><span class="params">(<span name="ranges">ranges: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are in one of the specified character ranges.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are in one of the specified character ranges.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyOf(chars:Char*):MarkupParsers.this.TextParser"></a>
      <a id="anyOf(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyOf</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive occurrences of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive occurrences of the specified characters.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyUntil(until:=&gt;MarkupParsers.this.Parser[Any]):MarkupParsers.this.TextParser"></a>
      <a id="anyUntil(⇒Parser[Any]):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="until">until: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of characters for which the specified parser fails on the corresponding offset.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of characters for which the specified parser fails on the corresponding offset.
 This parser fails if the end of input is reached without the specified parser ever succeeding or
 if the parser causes an Error result instead of a plain Failure or Success.
 Further constraints like minimum or maximum number of required matching characters can be specified
 through the API of the returned <code>TextParser</code> instance.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyUntil(chars:Char*):MarkupParsers.this.TextParser"></a>
      <a id="anyUntil(Char*):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyUntil</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters that are not one of the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters that are not one of the specified characters.</p><p> This parser is identical to the <code>anyBut</code> parser except for two differences: this parser fails
 if it reaches the end of the input without seeing any of the specified
 characters and it also consumes this final character, without adding it
 to the result. This parser is usually used when a construct like a span
 enclosed between two characters needs to be parsed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#anyWhile" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="anyWhile(p:Char=&gt;Boolean):MarkupParsers.this.TextParser"></a>
      <a id="anyWhile((Char)⇒Boolean):TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">anyWhile</span><span class="params">(<span name="p">p: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Consumes any number of consecutive characters which satisfy the specified predicate.</p><div class="fullcomment"><div class="comment cmt"><p>Consumes any number of consecutive characters which satisfy the specified predicate.
 Always succeeds unless a minimum number of required matches is specified.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#atStart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="atStart:MarkupParsers.this.Parser[MarkupParsers.this.Parser[Unit]]"></a>
      <a id="atStart:Parser[Parser[Unit]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">atStart</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the start of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the start of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#authority" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="authority:URIParsers.this.Parser[String]"></a>
      <a id="authority:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">authority</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the authority part of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the authority part of a URI as defined in RFC 3986.</p><pre>authority = [ userinfo <span class="lit">"@"</span> ] host [ <span class="lit">":"</span> port ]</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#blankLine" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blankLine:BlockParsers.this.Parser[String]"></a>
      <a id="blankLine:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLine</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a blank line from the current input offset (which may not be at the
 start of the line).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a blank line from the current input offset (which may not be at the
 start of the line). Fails for lines that contain any non-whitespace character.
 Does always produce an empty string as the result, discarding any whitespace
 characters found in the line.</p><p> Since it also succeeds at the end of the input
 it should never be used in the form of <code>(blankLine *)</code> or <code>(blankLine +)</code>. Use
 the <code>blankLines</code> parser instead in these cases.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#blankLines" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blankLines:BlockParsers.this.Parser[List[String]]"></a>
      <a id="blankLines:Parser[List[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">blankLines</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses one or more blanklines, producing a list of empty strings corresponding
 to the number of blank lines consumed.</p><div class="fullcomment"><div class="comment cmt"><p>Parses one or more blanklines, producing a list of empty strings corresponding
 to the number of blank lines consumed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#block" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="block(firstLinePrefix:BlockParsers.this.Parser[Any],linePrefix:=&gt;BlockParsers.this.Parser[Any],nextBlockPrefix:=&gt;BlockParsers.this.Parser[Any]):BlockParsers.this.Parser[List[String]]"></a>
      <a id="block(Parser[Any],⇒Parser[Any],⇒Parser[Any]):Parser[List[String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">block</span><span class="params">(<span name="firstLinePrefix">firstLinePrefix: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="linePrefix">linePrefix: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="nextBlockPrefix">nextBlockPrefix: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full block based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full block based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">firstLinePrefix</dt><dd class="cmt"><p>parser that recognizes the start of the first line of this block</p></dd><dt class="param">linePrefix</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">nextBlockPrefix</dt><dd class="cmt"><p>parser that recognizes whether a line after one or more blank lines still belongs to the same block
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#blockDirective" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockDirective(name:String):Option[laika.parse.rst.Directives.DirectivePart[laika.tree.Elements.Block]]"></a>
      <a id="blockDirective(String):Option[DirectivePart[Block]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockDirective</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="../Directives$$DirectivePart.html" class="extype" name="laika.parse.rst.Directives.DirectivePart">DirectivePart</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retrieves the block directive with the specified name.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves the block directive with the specified name.</p><p> See <a href="../Directives$.html" class="extype" name="laika.parse.rst.Directives">laika.parse.rst.Directives</a> for details on how to implement directives.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="laika.parse.rst.ext.StandardDirectiveParsers">StandardDirectiveParsers</a> → <a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#blockDirective" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockDirective:ExplicitBlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="blockDirective:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockDirective</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a block-level directive.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a block-level directive.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#directives</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#blockList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockList(parser:=&gt;BlockParsers.this.Parser[laika.tree.Elements.Block]):BlockParsers.this.Parser[List[laika.tree.Elements.Block]]"></a>
      <a id="blockList(⇒Parser[Block]):Parser[List[Block]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockList</span><span class="params">(<span name="parser">parser: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Builds a parser for a list of blocks based on the parser for a single block.</p><div class="fullcomment"><div class="comment cmt"><p>Builds a parser for a list of blocks based on the parser for a single block.</p><p> Overridden to add the processing required for cases where a block has influence
 on the parsing or processing of the subsequent block.</p><p> This includes checking each Paragraph for a double colon ending which turns
 the following block into a literal block as well as processing internal
 link targets and section headers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for a single block element</p></dd><dt>returns</dt><dd class="cmt"><p>a parser for a list of blocks
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a> → <a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#blockQuote" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="blockQuote:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="blockQuote:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">blockQuote</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a block quote with an optional attribution.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a block quote with an optional attribution.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#block-quotes" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#block-quotes</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ListParsers#bulletList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="bulletList:ListParsers.this.Parser[laika.tree.Elements.BulletList]"></a>
      <a id="bulletList:Parser[BulletList]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">bulletList</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$BulletList.html" class="extype" name="laika.tree.Elements.BulletList">BulletList</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a bullet list with any of the supported bullet characters.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a bullet list with any of the supported bullet characters.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#bullet-lists" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#bullet-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#captionAndLegend" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="captionAndLegend(p:laika.parse.rst.BlockParsers)(input:String):Either[String,(Seq[laika.tree.Elements.Span],List[laika.tree.Elements.Block])]"></a>
      <a id="captionAndLegend(BlockParsers)(String):Either[String,(Seq[Span],List[Block])]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">captionAndLegend</span><span class="params">(<span name="p">p: <a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></span>)</span><span class="params">(<span name="input">input: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, (<span class="extype" name="scala.Seq">Seq</span>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>], <span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>])]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a caption (a single paragraph) and a legend (one or more blocks), both being optional.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a caption (a single paragraph) and a legend (one or more blocks), both being optional.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the standard block parsers including all registered directives for recursive use</p></dd><dt class="param">input</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right</code> in case of parser success and <code>Left</code> in case of failure, to adjust to the Directive API
</p></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainl1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="chainl1[T,U](first:=&gt;Parsers.this.Parser[T],p:=&gt;Parsers.this.Parser[U],q:=&gt;Parsers.this.Parser[(T,U)=&gt;T]):Parsers.this.Parser[T]"></a>
      <a id="chainl1[T,U](⇒Parser[T],⇒Parser[U],⇒Parser[(T,U)⇒T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="first">first: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>, <span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.U">U</span>]</span>, <span name="q">q: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.U">U</span>) ⇒ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainl1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="chainl1[T](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[(T,T)=&gt;T]):Parsers.this.Parser[T]"></a>
      <a id="chainl1[T](⇒Parser[T],⇒Parser[(T,T)⇒T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainl1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>, <span name="q">q: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>) ⇒ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainl1.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#chainr1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="chainr1[T,U](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[(T,U)=&gt;U],combine:(T,U)=&gt;U,first:U):Parsers.this.Parser[U]"></a>
      <a id="chainr1[T,U](⇒Parser[T],⇒Parser[(T,U)⇒U],(T,U)⇒U,U):Parser[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">chainr1</span><span class="tparams">[<span name="T">T</span>, <span name="U">U</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.T">T</span>]</span>, <span name="q">q: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>) ⇒ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>]</span>, <span name="combine">combine: (<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.T">T</span>, <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>) ⇒ <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span></span>, <span name="first">first: <span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.chainr1.U">U</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#charToTraversalble" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="charToTraversalble(char:Char):Traversable[Char]"></a>
      <a id="charToTraversalble(Char):Traversable[Char]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">charToTraversalble</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span></span>)</span><span class="result">: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.</p><div class="fullcomment"><div class="comment cmt"><p>Implicit conversion that allows to pass a single
 character to the range-based <code>anyIn</code> parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#citation" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="citation:ExplicitBlockParsers.this.Parser[laika.tree.Elements.Citation]"></a>
      <a id="citation:Parser[Citation]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">citation</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Citation.html" class="extype" name="laika.tree.Elements.Citation">Citation</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a citation.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a citation.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citations" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citations</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#citationRef" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="citationRef:InlineParsers.this.Parser[laika.tree.Elements.CitationReference]"></a>
      <a id="citationRef:Parser[CitationReference]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">citationRef</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$CitationReference.html" class="extype" name="laika.tree.Elements.CitationReference">CitationReference</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a citation reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a citation reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citation-references" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#citation-references</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#comment" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="comment:ExplicitBlockParsers.this.Parser[laika.tree.Elements.Comment]"></a>
      <a id="comment:Parser[Comment]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">comment</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Comment.html" class="extype" name="laika.tree.Elements.Comment">Comment</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a comment.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a comment.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#comments" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#comments</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#commit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="commit[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[T]"></a>
      <a id="commit[T](⇒Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">commit</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.commit.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.commit.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BlockParsers#config" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="config(path:laika.tree.Documents.Path):BlockParsers.this.Parser[Either[laika.tree.Elements.InvalidBlock,com.typesafe.config.Config]]"></a>
      <a id="config(Path):Parser[Either[InvalidBlock,Config]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">config</span><span class="params">(<span name="path">path: <a href="../../../tree/Documents$$Path.html" class="extype" name="laika.tree.Documents.Path">Path</a></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Either">Either</span>[<a href="../../../tree/Elements$$InvalidBlock.html" class="extype" name="laika.tree.Elements.InvalidBlock">InvalidBlock</a>, <span class="extype" name="com.typesafe.config.Config">Config</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#defaultTextRole" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="defaultTextRole:String"></a>
      <a id="defaultTextRole:String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">defaultTextRole</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The default text role to use when no role is specified in an interpreted text element.</p><div class="fullcomment"><div class="comment cmt"><p>The default text role to use when no role is specified in an interpreted text element.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ListParsers#definitionList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="definitionList:ListParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="definitionList:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">definitionList</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a definition list.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a definition list.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#definition-lists" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#definition-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#digit" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="digit:URIParsers.this.TextParser"></a>
      <a id="digit:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">digit</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses digits according to RFC 2234.</p><div class="fullcomment"><div class="comment cmt"><p>Parses digits according to RFC 2234.</p><pre>DIGIT =  %x30-<span class="num">39</span>; <span class="num">0</span>-<span class="num">9</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#doctest" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="doctest:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="doctest:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">doctest</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a doctest block.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a doctest block. This is a feature which is very specific to the
 world of Python where reStructuredText originates. Therefore the resulting
 <code>DoctestBlock</code> tree element is not part of the standard Laika tree model.
 When this block type is used the corresponding special renderers must
 be enabled (e.g. the <code>ExtendedHTML</code> renderer for HTML).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#doctest-blocks" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#doctest-blocks</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#domain" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="domain:URIParsers.this.Parser[String]"></a>
      <a id="domain:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">domain</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the domain portion of an email address as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the domain portion of an email address as defined in RFC 6068.</p><pre>domain       = dot-atom-text / <span class="lit">"["</span> *dtext-no-obs <span class="lit">"]"</span>
dtext-no-obs = %d33-<span class="num">90</span> / ; Printable US-ASCII
               %d94-<span class="num">126</span>  ; characters not including
                         ; <span class="lit">"["</span>, <span class="lit">"]"</span>, or <span class="lit">"\"</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#dotAtomText" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="dotAtomText:URIParsers.this.Parser[String]"></a>
      <a id="dotAtomText:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">dotAtomText</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a <code>dot-atom-text</code> sequence as defined in RFC 5322.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a <code>dot-atom-text</code> sequence as defined in RFC 5322.</p><pre>dot-atom-text   =   <span class="num">1</span>*atext *(<span class="lit">"."</span> <span class="num">1</span>*atext)

atext           =   ALPHA / DIGIT /    ; Printable US-ASCII
                 <span class="lit">"!"</span> / <span class="lit">"#"</span> /        ;  characters not including
                 <span class="lit">"$"</span> / <span class="lit">"%"</span> /        ;  specials.  Used <span class="kw">for</span> atoms.
                 <span class="lit">"&"</span> / <span class="lit">"'"</span> /
                 <span class="lit">"*"</span> / <span class="lit">"+"</span> /
                 <span class="lit">"-"</span> / <span class="lit">"/"</span> /
                 <span class="lit">"="</span> / <span class="lit">"?"</span> /
                 <span class="lit">"^"</span> / <span class="lit">"_"</span> /
                 <span class="lit">"`"</span> / <span class="lit">"{"</span> /
                 <span class="lit">"|"</span> / <span class="lit">"}"</span> /
                 <span class="lit">"~"</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#elem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="elem(e:Parsers.this.Elem):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="elem(Elem):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="e">e: <a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#elem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="elem(kind:String,p:Parsers.this.Elem=&gt;Boolean):Parsers.this.Parser[Parsers.this.Elem]"></a>
      <a id="elem(String,(Elem)⇒Boolean):Parser[Elem]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">elem</span><span class="params">(<span name="kind">kind: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="p">p: (<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#em" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="em:InlineParsers.this.Parser[laika.tree.Elements.Emphasized]"></a>
      <a id="em:Parser[Emphasized]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">em</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Emphasized.html" class="extype" name="laika.tree.Elements.Emphasized">Emphasized</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a span of emphasized text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a span of emphasized text.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#emphasis" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#emphasis</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#email" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="email:InlineParsers.this.Parser[(String,String,String)]"></a>
      <a id="email:Parser[(String,String,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">email</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="java.lang.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a standalone email address (with no surrounding markup).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a standalone email address (with no surrounding markup).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#emailAddress" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="emailAddress:URIParsers.this.Parser[String]"></a>
      <a id="emailAddress:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">emailAddress</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a mailto URI without the scheme part as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a mailto URI without the scheme part as defined in RFC 6068.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#emailURI" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="emailURI:URIParsers.this.Parser[String]"></a>
      <a id="emailURI:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">emailURI</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full mailto URI as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full mailto URI as defined in RFC 6068.</p><pre>mailtoURI = <span class="lit">"mailto:"</span> [ to ] [ hfields ]</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ListParsers#enumList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="enumList:ListParsers.this.Parser[laika.tree.Elements.EnumList]"></a>
      <a id="enumList:Parser[EnumList]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">enumList</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$EnumList.html" class="extype" name="laika.tree.Elements.EnumList">EnumList</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an enumerated list in any of the supported combinations of enumeration style and formatting.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an enumerated list in any of the supported combinations of enumeration style and formatting.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#enumerated-lists" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#enumerated-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#eof" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eof:MarkupParsers.this.Parser[String]"></a>
      <a id="eof:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eof</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of the input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#eol" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eol:MarkupParsers.this.Parser[String]"></a>
      <a id="eol:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eol</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Succeeds at the end of a line, including the end of the input.</p><div class="fullcomment"><div class="comment cmt"><p>Succeeds at the end of a line, including the end of the input.
 Produces an empty string as a result and consumes any new line characters.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#err" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="err(msg:String):Parsers.this.Parser[Nothing]"></a>
      <a id="err(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">err</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#escapedChar" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="escapedChar:InlineParsers.this.Parser[String]"></a>
      <a id="escapedChar:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">escapedChar</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an escaped character.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an escaped character. For most characters it produces the character
 itself as the result with the only exception being an escaped space character
 which is removed from the output in reStructuredText.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#escaping-mechanism" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#escaping-mechanism</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a> → <a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#escapedText" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="escapedText(p:InlineParsers.this.TextParser):InlineParsers.this.Parser[String]"></a>
      <a id="escapedText(TextParser):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">escapedText</span><span class="params">(<span name="p">p: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Adds support for escape sequences to the specified text parser.</p><div class="fullcomment"><div class="comment cmt"><p>Adds support for escape sequences to the specified text parser.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the parser to add support for escape sequences to</p></dd><dt>returns</dt><dd class="cmt"><p>a parser for a text span that supports escape sequences
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#escapedUntil" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="escapedUntil(char:Char*):InlineParsers.this.Parser[String]"></a>
      <a id="escapedUntil(Char*):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">escapedUntil</span><span class="params">(<span name="char">char: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a span of text until one of the specified characters is seen
 (unless it is escaped),
 while also processing escaped characters, but no other nested
 spans.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a span of text until one of the specified characters is seen
 (unless it is escaped),
 while also processing escaped characters, but no other nested
 spans. The final character is not included in the result.
</p></div><dl class="paramcmts block"><dt class="param">char</dt><dd class="cmt"><p>the character that signals the end of the text span</p></dd><dt>returns</dt><dd class="cmt"><p>a parser for a text span that supports escape sequences
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#explicitBlockItem" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="explicitBlockItem:ExplicitBlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="explicitBlockItem:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">explicitBlockItem</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all types of explicit block items.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all types of explicit block items.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#explicit-markup-blocks" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#explicit-markup-blocks</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#failure" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="failure(msg:String):Parsers.this.Parser[Nothing]"></a>
      <a id="failure(String):Parser[Nothing]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">failure</span><span class="params">(<span name="msg">msg: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Nothing">Nothing</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.rst.ListParsers#fieldList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fieldList:ListParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="fieldList:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">fieldList</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a field list.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a field list.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#field-lists" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#field-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#flatten" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatten(result:Any):String"></a>
      <a id="flatten(Any):String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatten</span><span class="params">(<span name="result">result: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Predef.String">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Flattens the result from various combinators,
 including the <code>repX</code> variants and <code>~</code> into
 a single string.</p><div class="fullcomment"><div class="comment cmt"><p>Flattens the result from various combinators,
 including the <code>repX</code> variants and <code>~</code> into
 a single string.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#footnote" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="footnote:ExplicitBlockParsers.this.Parser[laika.tree.Elements.FootnoteDefinition]"></a>
      <a id="footnote:Parser[FootnoteDefinition]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">footnote</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$FootnoteDefinition.html" class="extype" name="laika.tree.Elements.FootnoteDefinition">FootnoteDefinition</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a footnote.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a footnote.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnotes" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnotes</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#footnoteLabel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="footnoteLabel:InlineParsers.this.Parser[ProductwithSerializablewithlaika.tree.Elements.FootnoteLabel]"></a>
      <a id="footnoteLabel:Parser[ProductwithSerializablewithFootnoteLabel]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">footnoteLabel</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span> with <a href="../../../tree/Elements$$FootnoteLabel.html" class="extype" name="laika.tree.Elements.FootnoteLabel">FootnoteLabel</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses any of the four supported types of footnote labels.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any of the four supported types of footnote labels.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#footnoteRef" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="footnoteRef:InlineParsers.this.Parser[laika.tree.Elements.FootnoteReference]"></a>
      <a id="footnoteRef:Parser[FootnoteReference]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">footnoteRef</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$FootnoteReference.html" class="extype" name="laika.tree.Elements.FootnoteReference">FootnoteReference</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a footnote reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a footnote reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#footnote-references</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#fragment" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="fragment:URIParsers.this.Parser[String]"></a>
      <a id="fragment:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">fragment</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the fragment part of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the fragment part of a URI as defined in RFC 3986.</p><pre>fragment = *( pchar / <span class="lit">"/"</span> / <span class="lit">"?"</span> )</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.rst.TableParsers#gridTable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="gridTable:TableParsers.this.Parser[laika.tree.Elements.Table]"></a>
      <a id="gridTable:Parser[Table]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">gridTable</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Table.html" class="extype" name="laika.tree.Elements.Table">Table</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a grid table.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a grid table.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#grid-tables" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#grid-tables</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#guard" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="guard[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[T]"></a>
      <a id="guard[T](⇒Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">guard</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.guard.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.guard.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#handleWhiteSpace" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="handleWhiteSpace(source:CharSequence,offset:Int):Int"></a>
      <a id="handleWhiteSpace(CharSequence,Int):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">handleWhiteSpace</span><span class="params">(<span name="source">source: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>, <span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#headerWithOverline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="headerWithOverline:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="headerWithOverline:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headerWithOverline</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a section header with both overline and underline.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a section header with both overline and underline.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#headerWithUnderline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="headerWithUnderline:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="headerWithUnderline:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">headerWithUnderline</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a section header with an underline, but no overline.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a section header with an underline, but no overline.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#hexdig" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hexdig:URIParsers.this.TextParser"></a>
      <a id="hexdig:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">hexdig</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a hexadecimal value according to RFC 2234.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a hexadecimal value according to RFC 2234.</p><pre>HEXDIG = DIGIT / <span class="lit">"A"</span> / <span class="lit">"B"</span> / <span class="lit">"C"</span> / <span class="lit">"D"</span> / <span class="lit">"E"</span> / <span class="lit">"F"</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#hfields" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hfields:URIParsers.this.Parser[String]"></a>
      <a id="hfields:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">hfields</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses header fields of an email address as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses header fields of an email address as defined in RFC 6068.</p><pre>hfields      = <span class="lit">"?"</span> hfield *( <span class="lit">"&"</span> hfield )
hfield       = hfname <span class="lit">"="</span> hfvalue
hfname       = *qchar
hfvalue      = *qchar

qchar        = unreserved / pct-encoded / some-delims
some-delims  = <span class="lit">"!"</span> / <span class="lit">"$"</span> / <span class="lit">"'"</span> / <span class="lit">"("</span> / <span class="lit">")"</span> / <span class="lit">"*"</span>
             / <span class="lit">"+"</span> / <span class="lit">","</span> / <span class="lit">";"</span> / <span class="lit">":"</span> / <span class="lit">"@"</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#hierPart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hierPart:URIParsers.this.Parser[String]"></a>
      <a id="hierPart:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">hierPart</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the hierarchical part of a URI with an authority component as defined in RFC 3986,
 but only the variant including an authority component.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the hierarchical part of a URI with an authority component as defined in RFC 3986,
 but only the variant including an authority component.</p><pre>hier-part     = <span class="lit">"//"</span> authority path-abempty
/ path-absolute ; excluded
/ path-rootless ; excluded
/ path-empty    ; excluded</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#host" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="host:URIParsers.this.Parser[String]"></a>
      <a id="host:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">host</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a host as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a host as defined in RFC 3986.</p><pre>host = IP-literal / IPv4address / reg-name</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#httpUri" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="httpUri:URIParsers.this.Parser[String]"></a>
      <a id="httpUri:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">httpUri</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full HTTP URI including the scheme part and an authority component
 as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full HTTP URI including the scheme part and an authority component
 as defined in RFC 3986.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#httpUriNoScheme" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="httpUriNoScheme:URIParsers.this.Parser[String]"></a>
      <a id="httpUriNoScheme:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">httpUriNoScheme</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an HTTP or HTTPS URI with an authority component, but without the scheme part
 (therefore starting with &quot;//&quot;) as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an HTTP or HTTPS URI with an authority component, but without the scheme part
 (therefore starting with &quot;//&quot;) as defined in RFC 3986.</p><pre>URI = scheme <span class="lit">":"</span> hier-part [ <span class="lit">"?"</span> query ] [ <span class="lit">"#"</span> fragment ]</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#httpsUri" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="httpsUri:URIParsers.this.Parser[String]"></a>
      <a id="httpsUri:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">httpsUri</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full HTTPS URI including the scheme part and an authority component
 as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full HTTPS URI including the scheme part and an authority component
 as defined in RFC 3986.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#indentedBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="indentedBlock(minIndent:Int,linePredicate:=&gt;BlockParsers.this.Parser[Any],endsOnBlankLine:Boolean,firstLineIndented:Boolean,maxIndent:Int):BlockParsers.this.Parser[BlockParsers.this.IndentedBlock]"></a>
      <a id="indentedBlock(Int,⇒Parser[Any],Boolean,Boolean,Int):Parser[IndentedBlock]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">indentedBlock</span><span class="params">(<span name="minIndent">minIndent: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">1</span></span>, <span name="linePredicate">linePredicate: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>] = <span class="symbol">success()</span></span>, <span name="endsOnBlankLine">endsOnBlankLine: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="firstLineIndented">firstLineIndented: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="maxIndent">maxIndent: <span class="extype" name="scala.Int">Int</span> = <span class="symbol">Int.MaxValue</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#IndentedBlockextendsProductwithSerializable" class="extmbr" name="laika.parse.BlockParsers.IndentedBlock">IndentedBlock</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full block based on the specified helper parsers, expecting an indentation for
 all lines except the first. The indentation may vary between the parts of the indented
 block, so that this parser only cuts off the minimum indentation shared by all lines,
 but each line must have at least the specified minimum indentation.
</p></div><dl class="paramcmts block"><dt class="param">minIndent</dt><dd class="cmt"><p>the minimum indentation that each line in this block must have</p></dd><dt class="param">linePredicate</dt><dd class="cmt"><p>parser that recognizes the start of subsequent lines that still belong to the same block</p></dd><dt class="param">endsOnBlankLine</dt><dd class="cmt"><p>indicates whether parsing should end on the first blank line</p></dd><dt class="param">firstLineIndented</dt><dd class="cmt"><p>indicates whether the first line is expected to be indented, too</p></dd><dt class="param">maxIndent</dt><dd class="cmt"><p>the maximum indentation that will get dropped from the start of each line of the result</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that produces an instance of IndentedBlock
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#inline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inline[Elem,To](text:=&gt;InlineParsers.this.TextParser,nested:=&gt;Map[Char,InlineParsers.this.Parser[Elem]],resultBuilder:=&gt;InlineParsers.this.ResultBuilder[Elem,To]):InlineParsers.this.Parser[To]"></a>
      <a id="inline[Elem,To](⇒TextParser,⇒Map[Char,Parser[Elem]],⇒ResultBuilder[Elem,To]):Parser[To]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">inline</span><span class="tparams">[<span name="Elem">Elem</span>, <span name="To">To</span>]</span><span class="params">(<span name="text">text: ⇒ <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>, <span name="nested">nested: ⇒ <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.InlineParsers.inline.Elem">Elem</span>]]</span>, <span name="resultBuilder">resultBuilder: ⇒ <a href="#ResultBuilder[Elem,+To]extendsAnyRef" class="extmbr" name="laika.parse.InlineParsers.ResultBuilder">ResultBuilder</a>[<span class="extype" name="laika.parse.InlineParsers.inline.Elem">Elem</span>, <span class="extype" name="laika.parse.InlineParsers.inline.To">To</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.InlineParsers.inline.To">To</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Generic base parser that parses inline elements based on the specified
 helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Generic base parser that parses inline elements based on the specified
 helper parsers. Usually not used directly by parser implementations,
 this is the base parser the other inline parsers of this trait delegate to.
</p></div><dl class="paramcmts block"><dt class="tparam">Elem</dt><dd class="cmt"><p>the element type produced by a single parser for a nested span</p></dd><dt class="tparam">To</dt><dd class="cmt"><p>the type of the result this parser produces</p></dd><dt class="param">nested</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser for nested span elements</p></dd><dt class="param">resultBuilder</dt><dd class="cmt"><p>responsible for building the final result of this parser based on the results of the helper parsers</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#inlineLiteral" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="inlineLiteral:InlineParsers.this.Parser[laika.tree.Elements.Literal]"></a>
      <a id="inlineLiteral:Parser[Literal]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">inlineLiteral</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Literal.html" class="extype" name="laika.tree.Elements.Literal">Literal</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an inline literal element.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an inline literal element.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-literals" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-literals</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#internalTarget" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="internalTarget:InlineParsers.this.Parser[laika.tree.Elements.Text]"></a>
      <a id="internalTarget:Parser[Text]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">internalTarget</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Text.html" class="extype" name="laika.tree.Elements.Text">Text</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an inline internal link target.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an inline internal link target.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-internal-targets" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-internal-targets</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#interpretedTextWithRolePrefix" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="interpretedTextWithRolePrefix:InlineParsers.this.Parser[laika.parse.rst.Elements.InterpretedText]"></a>
      <a id="interpretedTextWithRolePrefix:Parser[InterpretedText]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">interpretedTextWithRolePrefix</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../Elements$$InterpretedText.html" class="extype" name="laika.parse.rst.Elements.InterpretedText">InterpretedText</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an interpreted text element with the role name as a prefix.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an interpreted text element with the role name as a prefix.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#interpretedTextWithRoleSuffix" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="interpretedTextWithRoleSuffix:InlineParsers.this.Parser[laika.parse.rst.Elements.InterpretedText]"></a>
      <a id="interpretedTextWithRoleSuffix:Parser[InterpretedText]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">interpretedTextWithRoleSuffix</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../Elements$$InterpretedText.html" class="extype" name="laika.parse.rst.Elements.InterpretedText">InterpretedText</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an interpreted text element with the role name as a suffix.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an interpreted text element with the role name as a suffix.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#interpreted-text</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#ipLiteral" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ipLiteral:URIParsers.this.Parser[String]"></a>
      <a id="ipLiteral:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipLiteral</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an ip literal as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an ip literal as defined in RFC 3986.</p><pre>IP-literal = <span class="lit">"["</span> ( IPv6address / IPvFuture  ) <span class="lit">"]"</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#ipv4address" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ipv4address:URIParsers.this.Parser[String]"></a>
      <a id="ipv4address:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipv4address</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an IPv4 address as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an IPv4 address as defined in RFC 3986.</p><pre>IPv4address   = dec-octet <span class="lit">"."</span> dec-octet <span class="lit">"."</span> dec-octet <span class="lit">"."</span> dec-octet

dec-octet     = DIGIT                 ; <span class="num">0</span>-<span class="num">9</span>
              / %x31-<span class="num">39</span> DIGIT         ; <span class="num">10</span>-<span class="num">99</span>
              / <span class="lit">"1"</span> <span class="num">2</span>DIGIT            ; <span class="num">100</span>-<span class="num">199</span>
              / <span class="lit">"2"</span> %x30-<span class="num">34</span> DIGIT     ; <span class="num">200</span>-<span class="num">249</span>
              / <span class="lit">"25"</span> %x30-<span class="num">35</span>          ; <span class="num">250</span>-<span class="num">255</span></pre><p> The implementation has been simplified to parse a 3-digit number and
 check its value.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#ipv6address" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ipv6address:URIParsers.this.Parser[URIParsers.this.~[Product,java.io.Serializable]]"></a>
      <a id="ipv6address:Parser[~[Product,Serializable]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipv6address</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#~[+a,+b]extendsProductwithSerializable" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.~">~</a>[<span class="extype" name="scala.Product">Product</span>, <span class="extype" name="java.io.Serializable">Serializable</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an IPv6 address as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an IPv6 address as defined in RFC 3986.</p><pre>IPv6address  =                            <span class="num">6</span>( h16 <span class="lit">":"</span> ) ls32
             /                       <span class="lit">"::"</span> <span class="num">5</span>( h16 <span class="lit">":"</span> ) ls32
             / [               h16 ] <span class="lit">"::"</span> <span class="num">4</span>( h16 <span class="lit">":"</span> ) ls32
             / [ *<span class="num">1</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span> <span class="num">3</span>( h16 <span class="lit">":"</span> ) ls32
             / [ *<span class="num">2</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span> <span class="num">2</span>( h16 <span class="lit">":"</span> ) ls32
             / [ *<span class="num">3</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>    h16 <span class="lit">":"</span>   ls32
             / [ *<span class="num">4</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>              ls32
             / [ *<span class="num">5</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>              h16
             / [ *<span class="num">6</span>( h16 <span class="lit">":"</span> ) h16 ] <span class="lit">"::"</span>

h16          = <span class="num">1</span>*<span class="num">4</span>HEXDIG

ls32         = ( h16 <span class="lit">":"</span> h16 ) / IPv4address</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#ipvFuture" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ipvFuture:URIParsers.this.Parser[URIParsers.this.~[URIParsers.this.~[URIParsers.this.~[URIParsers.this.Elem,String],URIParsers.this.Elem],List[Any]]]"></a>
      <a id="ipvFuture:Parser[~[~[~[Elem,String],Elem],List[Any]]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">ipvFuture</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#~[+a,+b]extendsProductwithSerializable" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.~">~</a>[<a href="#~[+a,+b]extendsProductwithSerializable" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.~">~</a>[<a href="#~[+a,+b]extendsProductwithSerializable" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.~">~</a>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>, <span class="extype" name="scala.Predef.String">String</span>], <a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>], <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Any">Any</span>]]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a future IP address as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a future IP address as defined in RFC 3986.</p><pre>IPvFuture = <span class="lit">"v"</span> <span class="num">1</span>*HEXDIG <span class="lit">"."</span> <span class="num">1</span>*( unreserved / sub-delims / <span class="lit">":"</span> )</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="laika.parse.rst.ListParsers#lineBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lineBlock:ListParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="lineBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lineBlock</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a block of lines with line breaks preserved.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a block of lines with line breaks preserved.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#line-blocks" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#line-blocks</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#linkTarget" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="linkTarget:ExplicitBlockParsers.this.Parser[laika.tree.Elements.Blockwithlaika.tree.Elements.SpanwithSerializable]"></a>
      <a id="linkTarget:Parser[BlockwithSpanwithSerializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">linkTarget</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a> with <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a> with <span class="extype" name="scala.Serializable">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a link definition, either an internal, external or indirect link.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a link definition, either an internal, external or indirect link.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-targets" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-targets</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#literal" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="literal(s:String):RegexParsers.this.Parser[String]"></a>
      <a id="literal(String):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literal</span><span class="params">(<span name="s">s: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#literalBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="literalBlock:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="literalBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">literalBlock</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a literal block, either quoted or indented.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a literal block, either quoted or indented.
 Only used when the preceding block ends with a double colon (<code>::</code>).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#literal-blocks</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#localPart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="localPart:URIParsers.this.Parser[String]"></a>
      <a id="localPart:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">localPart</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the local part of an email address (before the @), with one
 deviation from RFC 6068: a quoted string is not allowed.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the local part of an email address (before the @), with one
 deviation from RFC 6068: a quoted string is not allowed. It is rarely
 used, not supported by the reStructuredText reference parser and would
 be hard to combine within text markup as it allows for whitespace and
 line break characters.</p><pre>local-part = dot-atom-text / quoted-string ; quoted-string omitted</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#log" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="log[T](p:=&gt;Parsers.this.Parser[T])(name:String):Parsers.this.Parser[T]"></a>
      <a id="log[T](⇒Parser[T])(String):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">log</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.log.T">T</span>]</span>)</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.log.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers#lookBehind" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lookBehind[T](offset:Int,parser:=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[T]"></a>
      <a id="lookBehind[T](Int,⇒Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">lookBehind</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="offset">offset: <span class="extype" name="scala.Int">Int</span></span>, <span name="parser">parser: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.lookBehind.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.lookBehind.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the specified parser at the specified offset behind the current
 position.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the specified parser at the specified offset behind the current
 position. Never consumes any input.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#markupEnd" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markupEnd(end:InlineParsers.this.Parser[String]):InlineParsers.this.Parser[String]"></a>
      <a id="markupEnd(Parser[String]):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">markupEnd</span><span class="params">(<span name="end">end: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the end of an inline element  according to reStructuredText markup recognition rules.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the end of an inline element  according to reStructuredText markup recognition rules.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules</a>.
</p></div><dl class="paramcmts block"><dt class="param">end</dt><dd class="cmt"><p>the parser that recognizes the markup at the end of an inline element</p></dd><dt>returns</dt><dd class="cmt"><p>a parser that produces the same result as the parser passed as an argument
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#markupStart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markupStart(end:InlineParsers.this.Parser[String]):InlineParsers.this.Parser[Any]"></a>
      <a id="markupStart(Parser[String]):Parser[Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">markupStart</span><span class="params">(<span name="end">end: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the start of an inline element without specific start markup
 according to reStructuredText markup recognition rules.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the start of an inline element without specific start markup
 according to reStructuredText markup recognition rules.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules</a>.
</p></div><dl class="paramcmts block"><dt class="param">end</dt><dd class="cmt"><p>the parser that recognizes the markup at the end of an inline element, needed to verify
 the start sequence is not immediately followed by an end sequence as empty elements are not allowed.</p></dd><dt>returns</dt><dd class="cmt"><p>a parser without a useful result, as it is only needed to verify it succeeds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#markupStart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="markupStart(start:InlineParsers.this.Parser[Any],end:InlineParsers.this.Parser[String]):InlineParsers.this.Parser[Any]"></a>
      <a id="markupStart(Parser[Any],Parser[String]):Parser[Any]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">markupStart</span><span class="params">(<span name="start">start: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>, <span name="end">end: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the markup at the start of an inline element according to reStructuredText markup recognition rules.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the markup at the start of an inline element according to reStructuredText markup recognition rules.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup-recognition-rules</a>.
</p></div><dl class="paramcmts block"><dt class="param">start</dt><dd class="cmt"><p>the parser that recognizes the markup at the start of an inline element</p></dd><dt class="param">end</dt><dd class="cmt"><p>the parser that recognizes the markup at the end of an inline element, needed to verify
 the start sequence is not immediately followed by an end sequence as empty elements are not allowed.</p></dd><dt>returns</dt><dd class="cmt"><p>a parser without a useful result, as it is only needed to verify it succeeds
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#maxNestLevel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="maxNestLevel:Int"></a>
      <a id="maxNestLevel:Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">maxNestLevel</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The maximum level of block nesting.</p><div class="fullcomment"><div class="comment cmt"><p>The maximum level of block nesting. Some block types like lists
 and blockquotes contain nested blocks. To protect against malicious
 input or accidentally broken markup, the level of nesting is restricted.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#mkList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mkList[T]:Parsers.this.~[T,List[T]]=&gt;List[T]"></a>
      <a id="mkList[T]:(~[T,List[T]])⇒List[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mkList</span><span class="tparams">[<span name="T">T</span>]</span><span class="result">: (<a href="#~[+a,+b]extendsProductwithSerializable" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.~">~</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.mkList.T">T</span>, <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.mkList.T">T</span>]]) ⇒ <span class="extype" name="scala.collection.immutable.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.mkList.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.BlockParsers#nestLevel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nestLevel(reader:BlockParsers.this.Input):Int"></a>
      <a id="nestLevel(Input):Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nestLevel</span><span class="params">(<span name="reader">reader: <a href="#Input=scala.util.parsing.input.Reader[Parsers.this.Elem]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Input">Input</a></span>)</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the current nest level from the specified input or 0 if it cannot be determined.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the current nest level from the specified input or 0 if it cannot be determined.</p><p> The nest level is usually only used to prevent endless recursion of nested blocks.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#nestedBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nestedBlock:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="nestedBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">nestedBlock</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses any kind of nested block supported by a concrete markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any kind of nested block supported by a concrete markup language.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#nonRecursiveBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="nonRecursiveBlock:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="nonRecursiveBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">nonRecursiveBlock</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses reStructuredText blocks, except for blocks that allow nesting of blocks.</p><div class="fullcomment"><div class="comment cmt"><p>Parses reStructuredText blocks, except for blocks that allow nesting of blocks.
 Only used in rare cases when the maximum nest level allowed had been reached
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a> → <a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#not" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="not[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[Unit]"></a>
      <a id="not[T](⇒Parser[T]):Parser[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">not</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.not.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#opt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[Option[T]]"></a>
      <a id="opt[T](⇒Parser[T]):Parser[Option[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.opt.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.opt.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#optimizedCharLookup" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optimizedCharLookup(chars:Char*):Char=&gt;Boolean"></a>
      <a id="optimizedCharLookup(Char*):(Char)⇒Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedCharLookup</span><span class="params">(<span name="chars">chars: <span class="extype" name="scala.Char">Char</span>*</span>)</span><span class="result">: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#optimizedRangeLookup" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optimizedRangeLookup(ranges:Traversable[Char]*):Char=&gt;Boolean"></a>
      <a id="optimizedRangeLookup(Traversable[Char]*):(Char)⇒Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optimizedRangeLookup</span><span class="params">(<span name="ranges">ranges: <span class="extype" name="scala.Traversable">Traversable</span>[<span class="extype" name="scala.Char">Char</span>]*</span>)</span><span class="result">: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns an optimized, Array-based lookup function
 for the specified ranges of characters.</p><div class="fullcomment"><div class="comment cmt"><p>Returns an optimized, Array-based lookup function
 for the specified ranges of characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ListParsers#optionList" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="optionList:ListParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="optionList:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">optionList</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses an option list.</p><div class="fullcomment"><div class="comment cmt"><p>Parses an option list.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#option-lists" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#option-lists</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#pChar" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pChar:URIParsers.this.Parser[java.io.Serializable]"></a>
      <a id="pChar:Parser[Serializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">pChar</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="java.io.Serializable">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses one path character as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses one path character as defined in RFC 3986.</p><pre>pchar = unreserved / pct-encoded / sub-delims / <span class="lit">":"</span> / <span class="lit">"@"</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#paragraph" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="paragraph:BlockParsers.this.Parser[laika.tree.Elements.Paragraph]"></a>
      <a id="paragraph:Parser[Paragraph]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">paragraph</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Paragraph.html" class="extype" name="laika.tree.Elements.Paragraph">Paragraph</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single paragraph.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single paragraph. Everything between two blank lines that is not
 recognized as a special reStructuredText block type will be parsed as a regular paragraph.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse[T](p:RegexParsers.this.Parser[T],in:java.io.Reader):RegexParsers.this.ParseResult[T]"></a>
      <a id="parse[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.io.Reader">Reader</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse[T](p:RegexParsers.this.Parser[T],in:CharSequence):RegexParsers.this.ParseResult[T]"></a>
      <a id="parse[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parse" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parse[T](p:RegexParsers.this.Parser[T],in:scala.util.parsing.input.Reader[Char]):RegexParsers.this.ParseResult[T]"></a>
      <a id="parse[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parse</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>, <span name="in">in: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parse.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAll[T](p:RegexParsers.this.Parser[T],in:CharSequence):RegexParsers.this.ParseResult[T]"></a>
      <a id="parseAll[T](Parser[T],CharSequence):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.lang.CharSequence">CharSequence</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAll[T](p:RegexParsers.this.Parser[T],in:java.io.Reader):RegexParsers.this.ParseResult[T]"></a>
      <a id="parseAll[T](Parser[T],Reader):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>, <span name="in">in: <span class="extype" name="java.io.Reader">Reader</span></span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#parseAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseAll[T](p:RegexParsers.this.Parser[T],in:scala.util.parsing.input.Reader[Char]):RegexParsers.this.ParseResult[T]"></a>
      <a id="parseAll[T](Parser[T],Reader[Char]):ParseResult[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseAll</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>, <span name="in">in: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <a href="#ParseResult[+T]extendsAnyRef" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.ParseResult">ParseResult</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.parseAll.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="laika.parse.BlockParsers#parseConfigAndRoot" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseConfigAndRoot(reader:scala.util.parsing.input.Reader[Char],path:laika.tree.Documents.Path):(com.typesafe.config.Config,laika.tree.Elements.RootElement)"></a>
      <a id="parseConfigAndRoot(Reader[Char],Path):(Config,RootElement)"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseConfigAndRoot</span><span class="params">(<span name="reader">reader: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>, <span name="path">path: <a href="../../../tree/Documents$$Path.html" class="extype" name="laika.tree.Documents.Path">Path</a></span>)</span><span class="result">: (<span class="extype" name="com.typesafe.config.Config">Config</span>, <a href="../../../tree/Elements$$RootElement.html" class="extype" name="laika.tree.Elements.RootElement">RootElement</a>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input from the specified reader and returns the configuration and root element.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input from the specified reader and returns the configuration and root element.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#parseDirectivePart" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseDirectivePart[T](parser:ExplicitBlockParsers.this.Parser[T],source:String):Either[String,T]"></a>
      <a id="parseDirectivePart[T](Parser[T],String):Either[String,T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseDirectivePart</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.rst.ExplicitBlockParsers.parseDirectivePart.T">T</span>]</span>, <span name="source">source: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="laika.parse.rst.ExplicitBlockParsers.parseDirectivePart.T">T</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Utility method to be used by custom parsers for directive argument or body.</p><div class="fullcomment"><div class="comment cmt"><p>Utility method to be used by custom parsers for directive argument or body.
 It translates a <code>Success</code> into a <code>Right</code> and a <code>NoSuccess</code> into a <code>Left</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#parseDocument" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseDocument(reader:scala.util.parsing.input.Reader[Char],path:laika.tree.Documents.Path):laika.tree.Documents.Document"></a>
      <a id="parseDocument(Reader[Char],Path):Document"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseDocument</span><span class="params">(<span name="reader">reader: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>, <span name="path">path: <a href="../../../tree/Documents$$Path.html" class="extype" name="laika.tree.Documents.Path">Path</a></span>)</span><span class="result">: <a href="../../../tree/Documents$$Document.html" class="extype" name="laika.tree.Documents.Document">Document</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input from the specified reader and returns the document tree.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input from the specified reader and returns the document tree.
 This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a> → <a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#parseInline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseInline(source:String,spanParsers:Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]):List[laika.tree.Elements.Span]"></a>
      <a id="parseInline(String,Map[Char,Parser[Span]]):List[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseInline</span><span class="params">(<span name="source">source: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="spanParsers">spanParsers: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input string and produces a list of spans.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input string and produces a list of spans.</p><p> This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text. Some parsers might additionally insert system message elements in case
 of markup errors.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>the input to parse</p></dd><dt class="param">spanParsers</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser</p></dd><dt>returns</dt><dd class="cmt"><p>the result of the parser in form of a list of spans
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a> → <a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#parseInline" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseInline(source:String):List[laika.tree.Elements.Span]"></a>
      <a id="parseInline(String):List[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseInline</span><span class="params">(<span name="source">source: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input string and produces a list of spans, using the
 default span parsers returned by the <code>spanParsers</code> method.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input string and produces a list of spans, using the
 default span parsers returned by the <code>spanParsers</code> method.</p><p> This function is expected to always succeed, errors would be considered a bug
 of this library, as the parsers treat all unknown or malformed markup as regular
 text. Some parsers might additionally insert system message elements in case
 of markup errors.
</p></div><dl class="paramcmts block"><dt class="param">source</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p>the result of the parser in form of a list of spans
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#parseMarkup" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseMarkup[T](parser:MarkupParsers.this.Parser[T],reader:scala.util.parsing.input.Reader[Char]):T"></a>
      <a id="parseMarkup[T](Parser[T],Reader[Char]):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span>]</span>, <span name="reader">reader: <span class="extype" name="scala.util.parsing.input.Reader">Reader</span>[<span class="extype" name="scala.Char">Char</span>]</span>)</span><span class="result">: <span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the input from the specified reader and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the input from the specified reader and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#parseMarkup" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseMarkup[T](parser:MarkupParsers.this.Parser[T],source:String):T"></a>
      <a id="parseMarkup[T](Parser[T],String):T"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseMarkup</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="parser">parser: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span>]</span>, <span name="source">source: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="laika.parse.MarkupParsers.parseMarkup.T">T</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Fully parses the specified input string and returns the result.</p><div class="fullcomment"><div class="comment cmt"><p>Fully parses the specified input string and returns the result.
 This function is expected to always succeed, errors would be considered a bug
 in this library, as the parsers treat all unknown or malformed markup as regular
 text.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#parseNestedBlocks" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseNestedBlocks(block:BlockParsers.this.IndentedBlock):List[laika.tree.Elements.Block]"></a>
      <a id="parseNestedBlocks(IndentedBlock):List[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseNestedBlocks</span><span class="params">(<span name="block">block: <a href="#IndentedBlockextendsProductwithSerializable" class="extmbr" name="laika.parse.BlockParsers.IndentedBlock">IndentedBlock</a></span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all nested blocks inside the specified indented block.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all nested blocks inside the specified indented block.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#parseNestedBlocks" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseNestedBlocks(input:String,nestLevel:Int):List[laika.tree.Elements.Block]"></a>
      <a id="parseNestedBlocks(String,Int):List[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseNestedBlocks</span><span class="params">(<span name="input">input: <span class="extype" name="scala.Predef.String">String</span></span>, <span name="nestLevel">nestLevel: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all nested blocks for the specified input and nest level.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all nested blocks for the specified input and nest level.
 Delegates to the abstract <code>nestedBlock</code> parser that sub-traits need to define.
 The nest level is primarily used as a protection against malicious
 input that forces endless recursion.
</p></div><dl class="paramcmts block"><dt class="param">input</dt><dd class="cmt"><p>the input to parse</p></dd><dt class="param">nestLevel</dt><dd class="cmt"><p>the level of nesting with 0 being the outermost level</p></dd><dt>returns</dt><dd class="cmt"><p>the parser result as a list of blocks
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#parseNestedBlocks" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="parseNestedBlocks(lines:List[String],nestLevel:Int):List[laika.tree.Elements.Block]"></a>
      <a id="parseNestedBlocks(List[String],Int):List[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">parseNestedBlocks</span><span class="params">(<span name="lines">lines: <span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.Predef.String">String</span>]</span>, <span name="nestLevel">nestLevel: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all nested blocks for the specified input and nest level.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all nested blocks for the specified input and nest level.
 Delegates to the abstract <code>nestedBlock</code> parser that sub-traits need to define.
 The nest level is primarily used as a protection against malicious
 input that forces endless recursion.
</p></div><dl class="paramcmts block"><dt class="param">lines</dt><dd class="cmt"><p>the input to parse</p></dd><dt class="param">nestLevel</dt><dd class="cmt"><p>the level of nesting with 0 being the outermost level</p></dd><dt>returns</dt><dd class="cmt"><p>the parser result as a list of blocks
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#path" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="path:URIParsers.this.Parser[String]"></a>
      <a id="path:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">path</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the path of a URI as defined in RFC 3986, but only the path
 variant following an authority component.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the path of a URI as defined in RFC 3986, but only the path
 variant following an authority component.</p><pre>path-abempty  = *( <span class="lit">"/"</span> segment )

segment       = *pchar</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#pctEncoded" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="pctEncoded:URIParsers.this.Parser[URIParsers.this.~[URIParsers.this.Elem,String]]"></a>
      <a id="pctEncoded:Parser[~[Elem,String]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">pctEncoded</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="#~[+a,+b]extendsProductwithSerializable" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.~">~</a>[<a href="#Elem=Char" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Elem">Elem</a>, <span class="extype" name="scala.Predef.String">String</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a percent-encoded character as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a percent-encoded character as defined in RFC 3986.</p><pre>pct-encoded = <span class="lit">"%"</span> HEXDIG HEXDIG</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#phrase" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="phrase[T](p:RegexParsers.this.Parser[T]):RegexParsers.this.Parser[T]"></a>
      <a id="phrase[T](Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">phrase</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.phrase.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.phrase.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#phraseLinkRef" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="phraseLinkRef:InlineParsers.this.Parser[laika.tree.Elements.SpanContainer[_&gt;:laika.tree.Elements.SpanSequencewithlaika.tree.Elements.ExternalLinkwithlaika.tree.Elements.LinkReference&lt;:laika.tree.Elements.SpanContainer[_&gt;:laika.tree.Elements.SpanSequencewithlaika.tree.Elements.ExternalLinkwithlaika.tree.Elements.LinkReference&lt;:laika.tree.Elements.SpanContainer[_&gt;:laika.tree.Elements.SpanSequencewithlaika.tree.Elements.ExternalLinkwithlaika.tree.Elements.LinkReference&lt;:laika.tree.Elements.Spanwithlaika.tree.Elements.Container[Seq[laika.tree.Elements.Span]]withSerializable]withlaika.tree.Elements.SpanwithSerializable]withlaika.tree.Elements.SpanwithSerializable]withlaika.tree.Elements.SpanwithSerializable]"></a>
      <a id="phraseLinkRef:Parser[SpanContainer[_&gt;:SpanSequencewithExternalLinkwithLinkReference&lt;:SpanContainer[_&gt;:SpanSequencewithExternalLinkwithLinkReference&lt;:SpanContainer[_&gt;:SpanSequencewithExternalLinkwithLinkReference&lt;:SpanwithContainer[Seq[Span]]withSerializable]withSpanwithSerializable]withSpanwithSerializable]withSpanwithSerializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">phraseLinkRef</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$SpanContainer.html" class="extype" name="laika.tree.Elements.SpanContainer">SpanContainer</a>[_ &gt;: <a href="../../../tree/Elements$$SpanSequence.html" class="extype" name="laika.tree.Elements.SpanSequence">SpanSequence</a> with <a href="../../../tree/Elements$$ExternalLink.html" class="extype" name="laika.tree.Elements.ExternalLink">ExternalLink</a> with <a href="../../../tree/Elements$$LinkReference.html" class="extype" name="laika.tree.Elements.LinkReference">LinkReference</a> &lt;: <a href="../../../tree/Elements$$SpanContainer.html" class="extype" name="laika.tree.Elements.SpanContainer">SpanContainer</a>[_ &gt;: <a href="../../../tree/Elements$$SpanSequence.html" class="extype" name="laika.tree.Elements.SpanSequence">SpanSequence</a> with <a href="../../../tree/Elements$$ExternalLink.html" class="extype" name="laika.tree.Elements.ExternalLink">ExternalLink</a> with <a href="../../../tree/Elements$$LinkReference.html" class="extype" name="laika.tree.Elements.LinkReference">LinkReference</a> &lt;: <a href="../../../tree/Elements$$SpanContainer.html" class="extype" name="laika.tree.Elements.SpanContainer">SpanContainer</a>[_ &gt;: <a href="../../../tree/Elements$$SpanSequence.html" class="extype" name="laika.tree.Elements.SpanSequence">SpanSequence</a> with <a href="../../../tree/Elements$$ExternalLink.html" class="extype" name="laika.tree.Elements.ExternalLink">ExternalLink</a> with <a href="../../../tree/Elements$$LinkReference.html" class="extype" name="laika.tree.Elements.LinkReference">LinkReference</a> &lt;: <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a> with <a href="../../../tree/Elements$$Container.html" class="extype" name="laika.tree.Elements.Container">Container</a>[<span class="extype" name="scala.Seq">Seq</span>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]] with <span class="extype" name="scala.Serializable">Serializable</span>] with <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a> with <span class="extype" name="scala.Serializable">Serializable</span>] with <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a> with <span class="extype" name="scala.Serializable">Serializable</span>] with <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a> with <span class="extype" name="scala.Serializable">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a phrase link reference (enclosed in back ticks).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a phrase link reference (enclosed in back ticks).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#phraseRef" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="phraseRef:InlineParsers.this.Parser[String]"></a>
      <a id="phraseRef:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">phraseRef</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a phrase reference name enclosed in back ticks.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a phrase reference name enclosed in back ticks.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#port" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="port:URIParsers.this.TextParser"></a>
      <a id="port:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">port</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a port as defined in RFC 3986, except for requiring at least one digit;
 instead the port is defined as optional in a higher level combinator.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a port as defined in RFC 3986, except for requiring at least one digit;
 instead the port is defined as optional in a higher level combinator.</p><pre>port = *DIGIT</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#positioned" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="positioned[T&lt;:scala.util.parsing.input.Positional](p:=&gt;RegexParsers.this.Parser[T]):RegexParsers.this.Parser[T]"></a>
      <a id="positioned[T&lt;:Positional](⇒Parser[T]):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">positioned</span><span class="tparams">[<span name="T">T &lt;: <span class="extype" name="scala.util.parsing.input.Positional">Positional</span></span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.positioned.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.RegexParsers.positioned.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers → Parsers</dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#prepareBlockParsers" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prepareBlockParsers(nested:Boolean):List[BlockParsers.this.Parser[laika.tree.Elements.Block]]"></a>
      <a id="prepareBlockParsers(Boolean):List[Parser[Block]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prepareBlockParsers</span><span class="params">(<span name="nested">nested: <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.collection.immutable.List">List</span>[<a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Extension hook for assembling the block parsers for a particular markup format.</p><div class="fullcomment"><div class="comment cmt"><p>Extension hook for assembling the block parsers for a particular markup format.
</p></div><dl class="paramcmts block"><dt class="param">nested</dt><dd class="cmt"><p>true if these are parsers for nested blocks, false if they are for top level blocks</p></dd><dt>returns</dt><dd class="cmt"><p>a list of block parsers which later will be interpreted as choices in the specified order
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a> → <a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#prepareSpanParsers" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="prepareSpanParsers:scala.collection.immutable.Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]"></a>
      <a id="prepareSpanParsers:Map[Char,Parser[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">prepareSpanParsers</span><span class="result">: <span class="extype" name="scala.collection.immutable.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A mapping of the start character of an inline element to the corresponding parser.</p><div class="fullcomment"><div class="comment cmt"><p>A mapping of the start character of an inline element to the corresponding parser.
 The mapping is used to provide a fast implementation of an inline parser that
 only stops at known special characters.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a> → <a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#punctuationChar" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="punctuationChar:BlockParsers.this.TextParser"></a>
      <a id="punctuationChar:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">punctuationChar</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses punctuation characters as supported by transitions (rules) and
 overlines and underlines for header sections.</p><div class="fullcomment"><div class="comment cmt"><p>Parses punctuation characters as supported by transitions (rules) and
 overlines and underlines for header sections.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a> → <a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#query" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="query:URIParsers.this.Parser[String]"></a>
      <a id="query:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">query</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the query part of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the query part of a URI as defined in RFC 3986.</p><pre>query = *( pchar / <span class="lit">"/"</span> / <span class="lit">"?"</span> )</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#quotedBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="quotedBlock(p:laika.parse.rst.BlockParsers,style:String)(input:String):SerializablewithProductwithscala.util.Either[String,laika.tree.Elements.QuotedBlock]"></a>
      <a id="quotedBlock(BlockParsers,String)(String):SerializablewithProductwithEither[String,QuotedBlock]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">quotedBlock</span><span class="params">(<span name="p">p: <a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></span>, <span name="style">style: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="params">(<span name="input">input: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Serializable">Serializable</span> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.util.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <a href="../../../tree/Elements$$QuotedBlock.html" class="extype" name="laika.tree.Elements.QuotedBlock">QuotedBlock</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a quoted block with nested blocks.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a quoted block with nested blocks.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the standard block parsers including all registered directives for recursive use</p></dd><dt class="param">input</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right</code> in case of parser success and <code>Left</code> in case of failure, to adjust to the Directive API
</p></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#refName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="refName:MarkupParsers.this.Parser[String]"></a>
      <a id="refName:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">refName</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a simple reference name that only allows alphanumerical characters
 and the punctuation characters <code>-</code>, <code>_</code>, <code>.</code>, <code>:</code>, <code>+</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a simple reference name that only allows alphanumerical characters
 and the punctuation characters <code>-</code>, <code>_</code>, <code>.</code>, <code>:</code>, <code>+</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#regName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="regName:URIParsers.this.Parser[String]"></a>
      <a id="regName:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">regName</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a server name as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a server name as defined in RFC 3986.</p><pre>reg-name = *( unreserved / pct-encoded / sub-delims )</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#regex" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="regex(r:scala.util.matching.Regex):RegexParsers.this.Parser[String]"></a>
      <a id="regex(Regex):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">implicit </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">regex</span><span class="params">(<span name="r">r: <span class="extype" name="scala.util.matching.Regex">Regex</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers#rep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep[T](first:=&gt;BaseParsers.this.Parser[T],next:T=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[List[T]]"></a>
      <a id="rep[T](⇒Parser[T],(T)⇒Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="first">first: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>]</span>, <span name="next">next: (<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>) ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.BaseParsers.rep.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">A parser generator for repetitions where all subsequent parsers
 after the first depend on the result of the previous.</p><div class="fullcomment"><div class="comment cmt"><p>A parser generator for repetitions where all subsequent parsers
 after the first depend on the result of the previous.
</p></div><dl class="paramcmts block"><dt class="param">first</dt><dd class="cmt"><p>the parser to use for the first piece of input</p></dd><dt class="param">next</dt><dd class="cmt"><p>a function that determines the next parser based on the result of the previous
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep[T](⇒Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep1[T](first:=&gt;Parsers.this.Parser[T],p0:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep1[T](⇒Parser[T],⇒Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="first">first: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]</span>, <span name="p0">p0: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@migration</span>
              
        </dd><dt>Migration</dt><dd class="cmt"><p><i>(Changed in version 2.9.0)</i> The <code>p0</code> call-by-name arguments is evaluated at most once per constructed Parser object, instead of on every need that arises during parsing.</p></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep1[T](p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep1[T](⇒Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#rep1sep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rep1sep[T](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[Any]):Parsers.this.Parser[List[T]]"></a>
      <a id="rep1sep[T](⇒Parser[T],⇒Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rep1sep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1sep.T">T</span>]</span>, <span name="q">q: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.rep1sep.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BaseParsers#repMax" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repMax[T](num:Int,p:=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[List[T]]"></a>
      <a id="repMax[T](Int,⇒Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMax</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.repMax.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.BaseParsers.repMax.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at most the specified number of repetitions, always succeeds.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at most the specified number of repetitions, always succeeds.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="laika.parse.BaseParsers#repMin" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repMin[T](num:Int,p:=&gt;BaseParsers.this.Parser[T]):BaseParsers.this.Parser[List[T]]"></a>
      <a id="repMin[T](Int,⇒Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repMin</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BaseParsers.repMin.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="laika.parse.BaseParsers.repMin.T">T</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Uses the parser for at least the specified number of repetitions or otherwise fails.</p><div class="fullcomment"><div class="comment cmt"><p>Uses the parser for at least the specified number of repetitions or otherwise fails.
 Continues to apply the parser after the minimum has been reached until if fails.
 The result is the list of results from applying the parser repeatedly.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#repN" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repN[T](num:Int,p:=&gt;Parsers.this.Parser[T]):Parsers.this.Parser[List[T]]"></a>
      <a id="repN[T](Int,⇒Parser[T]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repN</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="num">num: <span class="extype" name="scala.Int">Int</span></span>, <span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repN.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repN.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#repsep" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repsep[T](p:=&gt;Parsers.this.Parser[T],q:=&gt;Parsers.this.Parser[Any]):Parsers.this.Parser[List[T]]"></a>
      <a id="repsep[T](⇒Parser[T],⇒Parser[Any]):Parser[List[T]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repsep</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repsep.T">T</span>]</span>, <span name="q">q: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Any">Any</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<span class="extype" name="scala.util.parsing.combinator.Parsers.repsep.T">T</span>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="laika.parse.BlockParsers#restOfLine" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="restOfLine:BlockParsers.this.Parser[String]"></a>
      <a id="restOfLine:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">restOfLine</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the rest of the line from the current input offset no matter whether
 it consist of whitespace only or some text. Does not include the eol character(s).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#roleDirective" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="roleDirective:ExplicitBlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="roleDirective:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">roleDirective</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a role directive.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a role directive.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/directives.html#custom-interpreted-text-roles</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#rootElement" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="rootElement:BlockParsers.this.Parser[laika.tree.Elements.RootElement]"></a>
      <a id="rootElement:Parser[RootElement]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rootElement</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$RootElement.html" class="extype" name="laika.tree.Elements.RootElement">RootElement</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a full document, delegating most of the work to the <code>topLevelBlock</code> parser.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a full document, delegating most of the work to the <code>topLevelBlock</code> parser.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#shortAnonymousLinkTarget" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="shortAnonymousLinkTarget:ExplicitBlockParsers.this.Parser[laika.tree.Elements.ExternalLinkDefinition]"></a>
      <a id="shortAnonymousLinkTarget:Parser[ExternalLinkDefinition]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">shortAnonymousLinkTarget</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$ExternalLinkDefinition.html" class="extype" name="laika.tree.Elements.ExternalLinkDefinition">ExternalLinkDefinition</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the short variant of an anonymous link definition
 (that starts with <code><u><code> instead of </code>.. </u>:</code>)</p><div class="fullcomment"><div class="comment cmt"><p>Parses the short variant of an anonymous link definition
 (that starts with <code><u><code> instead of </code>.. </u>:</code>)</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#anonymous-hyperlinks" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#anonymous-hyperlinks</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#simpleLinkRef" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="simpleLinkRef:InlineParsers.this.Parser[laika.tree.Elements.Span]"></a>
      <a id="simpleLinkRef:Parser[Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">simpleLinkRef</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a simple link reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a simple link reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#hyperlink-references</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#simpleRefName" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="simpleRefName:InlineParsers.this.Parser[String]"></a>
      <a id="simpleRefName:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">simpleRefName</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="java.lang.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a simple reference name that only allows alphanumerical characters
 and the punctuation characters <code>-</code>, <code>_</code>, <code>.</code>, <code>:</code>, <code>+</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a simple reference name that only allows alphanumerical characters
 and the punctuation characters <code>-</code>, <code>_</code>, <code>.</code>, <code>:</code>, <code>+</code>.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#reference-names</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.TableParsers#simpleTable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="simpleTable:TableParsers.this.Parser[laika.tree.Elements.Table]"></a>
      <a id="simpleTable:Parser[Table]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">simpleTable</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Table.html" class="extype" name="laika.tree.Elements.Table">Table</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a simple table.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a simple table.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#simple-tables" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#simple-tables</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></dd></dl></div>
    </li><li name="laika.parse.MarkupParsers#skipWhitespace" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="skipWhitespace:Boolean"></a>
      <a id="skipWhitespace:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">skipWhitespace</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a> → RegexParsers</dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#spanDirective" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spanDirective(name:String):Option[laika.parse.rst.Directives.DirectivePart[laika.tree.Elements.Span]]"></a>
      <a id="spanDirective(String):Option[DirectivePart[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">spanDirective</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="../Directives$$DirectivePart.html" class="extype" name="laika.parse.rst.Directives.DirectivePart">DirectivePart</a>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retrieves the span directive with the specified name.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves the span directive with the specified name.</p><p> See <a href="../Directives$.html" class="extype" name="laika.parse.rst.Directives">laika.parse.rst.Directives</a> for details on how to implement directives.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="laika.parse.rst.ext.StandardDirectiveParsers">StandardDirectiveParsers</a> → <a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#spanParsers" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spanParsers:Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]"></a>
      <a id="spanParsers:Map[Char,Parser[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">spanParsers</span><span class="result">: <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The mapping of markup start characters to their corresponding
 span parsers.</p><div class="fullcomment"><div class="comment cmt"><p>The mapping of markup start characters to their corresponding
 span parsers.</p><p> A parser mapped to a start character is not required
 to successfully parse the subsequent input. If it fails the
 character that triggered the parser invocation will be treated
 as normal text. The mapping is merely used as a performance
 optimization. The parser will be invoked with the input
 offset pointing to the character after the one
 specified as the key for the mapping.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#spans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="spans(parser:=&gt;InlineParsers.this.TextParser,spanParsers:=&gt;Map[Char,InlineParsers.this.Parser[laika.tree.Elements.Span]]):InlineParsers.this.Parser[List[laika.tree.Elements.Span]]"></a>
      <a id="spans(⇒TextParser,⇒Map[Char,Parser[Span]]):Parser[List[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">spans</span><span class="params">(<span name="parser">parser: ⇒ <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>, <span name="spanParsers">spanParsers: ⇒ <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.List">List</span>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a list of spans based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a list of spans based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for the text of the current span element</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#standardSpans" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="standardSpans(p:laika.parse.rst.InlineParsers)(input:String):Either[String,Seq[laika.tree.Elements.Span]]"></a>
      <a id="standardSpans(InlineParsers)(String):Either[String,Seq[Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">standardSpans</span><span class="params">(<span name="p">p: <a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></span>)</span><span class="params">(<span name="input">input: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Seq">Seq</span>[<a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses all standard inline markup supported by <code>reStructuredText</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Parses all standard inline markup supported by <code>reStructuredText</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the standard inline parsers including all registered directives for recursive use</p></dd><dt class="param">input</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right</code> in case of parser success and <code>Left</code> in case of failure, to adjust to the Directive API
</p></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#strong" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="strong:InlineParsers.this.Parser[laika.tree.Elements.Strong]"></a>
      <a id="strong:Parser[Strong]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">strong</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Strong.html" class="extype" name="laika.tree.Elements.Strong">Strong</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a span of text with strong emphasis.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a span of text with strong emphasis.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#strong-emphasis" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#strong-emphasis</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#subDelims" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="subDelims:URIParsers.this.TextParser"></a>
      <a id="subDelims:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">subDelims</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single sub-delimiter as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single sub-delimiter as defined in RFC 3986.</p><pre>sub-delims = <span class="lit">"!"</span> / <span class="lit">"$"</span> / <span class="lit">"&"</span> / <span class="lit">"'"</span> / <span class="lit">"("</span> / <span class="lit">")"</span>
/ <span class="lit">"*"</span> / <span class="lit">"+"</span> / <span class="lit">","</span> / <span class="lit">";"</span> / <span class="lit">"="</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ExplicitBlockParsers#substitutionDefinition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="substitutionDefinition:ExplicitBlockParsers.this.Parser[laika.tree.Elements.BlockwithSerializable]"></a>
      <a id="substitutionDefinition:Parser[BlockwithSerializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">substitutionDefinition</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a> with <span class="extype" name="scala.Serializable">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a substitution definition.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a substitution definition.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-definitions" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-definitions</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#substitutionRef" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="substitutionRef:InlineParsers.this.Parser[laika.tree.Elements.ReferencewithSerializable]"></a>
      <a id="substitutionRef:Parser[ReferencewithSerializable]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">substitutionRef</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Reference.html" class="extype" name="laika.tree.Elements.Reference">Reference</a> with <span class="extype" name="scala.Serializable">Serializable</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a substitution reference.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a substitution reference.</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-references" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#substitution-references</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#success" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="success[T](v:T):Parsers.this.Parser[T]"></a>
      <a id="success[T](T):Parser[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">success</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="v">v: <span class="extype" name="scala.util.parsing.combinator.Parsers.success.T">T</span></span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.util.parsing.combinator.Parsers.success.T">T</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#table" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="table(p:laika.parse.rst.BlockParsers)(input:String):Either[String,laika.tree.Elements.Table]"></a>
      <a id="table(BlockParsers)(String):Either[String,Table]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">table</span><span class="params">(<span name="p">p: <a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></span>)</span><span class="params">(<span name="input">input: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <a href="../../../tree/Elements$$Table.html" class="extype" name="laika.tree.Elements.Table">Table</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses one of the two table types supported by <code>reStructuredText</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Parses one of the two table types supported by <code>reStructuredText</code>.
</p></div><dl class="paramcmts block"><dt class="param">p</dt><dd class="cmt"><p>the standard block parsers including all registered directives for recursive use</p></dd><dt class="param">input</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right</code> in case of parser success and <code>Left</code> in case of failure, to adjust to the Directive API
</p></dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#target" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="target(input:String):Either[String,laika.tree.Elements.Span]"></a>
      <a id="target(String):Either[String,Span]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">target</span><span class="params">(<span name="input">input: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a target which might be a simple reference, a phrase reference or an uri.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a target which might be a simple reference, a phrase reference or an uri.
</p></div><dl class="paramcmts block"><dt class="param">input</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right</code> in case of parser success and <code>Left</code> in case of failure, to adjust to the Directive API
</p></dd></dl></div>
    </li><li name="laika.parse.InlineParsers#text" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="text(parser:=&gt;InlineParsers.this.TextParser,nested:=&gt;Map[Char,InlineParsers.this.Parser[String]]):InlineParsers.this.Parser[String]"></a>
      <a id="text(⇒TextParser,⇒Map[Char,Parser[String]]):Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">text</span><span class="params">(<span name="parser">parser: ⇒ <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>, <span name="nested">nested: ⇒ <span class="extype" name="scala.Predef.Map">Map</span>[<span class="extype" name="scala.Char">Char</span>, <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses text based on the specified helper parsers.</p><div class="fullcomment"><div class="comment cmt"><p>Parses text based on the specified helper parsers.
</p></div><dl class="paramcmts block"><dt class="param">parser</dt><dd class="cmt"><p>the parser for the text of the current element</p></dd><dt class="param">nested</dt><dd class="cmt"><p>a mapping from the start character of a span to the corresponding parser for nested span elements</p></dd><dt>returns</dt><dd class="cmt"><p>the resulting parser
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.BlockParsers#textLine" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="textLine:BlockParsers.this.Parser[String]"></a>
      <a id="textLine:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">textLine</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single text line from the current input offset (which may not be at the
 start of the line.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single text line from the current input offset (which may not be at the
 start of the line. Fails for blank lines. Does not include the eol character(s).
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#textRole" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="textRole(name:String):Option[laika.parse.rst.TextRoles.RoleDirectivePart[String=&gt;laika.tree.Elements.Span]]"></a>
      <a id="textRole(String):Option[RoleDirectivePart[(String)⇒Span]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">textRole</span><span class="params">(<span name="name">name: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="../TextRoles$$RoleDirectivePart.html" class="extype" name="laika.parse.rst.TextRoles.RoleDirectivePart">RoleDirectivePart</a>[(<span class="extype" name="scala.Predef.String">String</span>) ⇒ <a href="../../../tree/Elements$$Span.html" class="extype" name="laika.tree.Elements.Span">Span</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Retrieves the text role with the specified name.</p><div class="fullcomment"><div class="comment cmt"><p>Retrieves the text role with the specified name.</p><p> See <a href="../TextRoles$.html" class="extype" name="laika.parse.rst.TextRoles">laika.parse.rst.TextRoles</a> for details on how to implement text roles.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="laika.parse.rst.ext.StandardDirectiveParsers">StandardDirectiveParsers</a> → <a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#textRoleElements" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="textRoleElements:List[laika.parse.rst.Elements.CustomizedTextRole]"></a>
      <a id="textRoleElements:List[CustomizedTextRole]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">textRoleElements</span><span class="result">: <span class="extype" name="scala.List">List</span>[<a href="../Elements$$CustomizedTextRole.html" class="extype" name="laika.parse.rst.Elements.CustomizedTextRole">CustomizedTextRole</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">All the base text roles supported by this parser not including
 any custom roles specified within document markup.</p><div class="fullcomment"><div class="comment cmt"><p>All the base text roles supported by this parser not including
 any custom roles specified within document markup.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#to" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="to:URIParsers.this.Parser[String]"></a>
      <a id="to:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">to</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a sequence of email addresses as defined in RFC 6068.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a sequence of email addresses as defined in RFC 6068.</p><pre>to = addr-spec *(<span class="lit">","</span> addr-spec )</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="laika.parse.BlockParsers#topLevelBlock" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="topLevelBlock:BlockParsers.this.Parser[laika.tree.Elements.Block]"></a>
      <a id="topLevelBlock:Parser[Block]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">topLevelBlock</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Block.html" class="extype" name="laika.tree.Elements.Block">Block</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses any kind of top-level block supported by a concrete markup language.</p><div class="fullcomment"><div class="comment cmt"><p>Parses any kind of top-level block supported by a concrete markup language.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#transition" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="transition:BlockParsers.this.Parser[laika.tree.Elements.Rule]"></a>
      <a id="transition:Parser[Rule]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">transition</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<a href="../../../tree/Elements$$Rule.html" class="extype" name="laika.tree.Elements.Rule">Rule</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a transition (rule).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a transition (rule).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#transitions" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#transitions</a>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.ext.StandardDirectiveParsers#unicode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unicode(input:String):Either[String,String]"></a>
      <a id="unicode(String):Either[String,String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">unicode</span><span class="params">(<span name="input">input: <span class="extype" name="scala.Predef.String">String</span></span>)</span><span class="result">: <span class="extype" name="scala.Either">Either</span>[<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses unicode values in various notations intertwined with normal text.</p><div class="fullcomment"><div class="comment cmt"><p>Parses unicode values in various notations intertwined with normal text.
</p></div><dl class="paramcmts block"><dt class="param">input</dt><dd class="cmt"><p>the input to parse</p></dd><dt>returns</dt><dd class="cmt"><p><code>Right</code> in case of parser success and <code>Left</code> in case of failure, to adjust to the Directive API
</p></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#unreserved" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="unreserved:URIParsers.this.Parser[String]"></a>
      <a id="unreserved:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">unreserved</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a single unreserved character as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses a single unreserved character as defined in RFC 3986.</p><pre>sub-delims = <span class="lit">"!"</span> / <span class="lit">"$"</span> / <span class="lit">"&"</span> / <span class="lit">"'"</span> / <span class="lit">"("</span> / <span class="lit">")"</span>
/ <span class="lit">"*"</span> / <span class="lit">"+"</span> / <span class="lit">","</span> / <span class="lit">";"</span> / <span class="lit">"="</span></pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.InlineParsers#uri" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="uri:InlineParsers.this.Parser[(String,String,String)]"></a>
      <a id="uri:Parser[(String,String,String)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">lazy val</span>
      </span>
      <span class="symbol">
        <span class="name">uri</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.Predef.String">String</span>, <span class="extype" name="java.lang.String">String</span>, <span class="extype" name="scala.Predef.String">String</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses a standalone HTTP or HTTPS hyperlink (with no surrounding markup).</p><div class="fullcomment"><div class="comment cmt"><p>Parses a standalone HTTP or HTTPS hyperlink (with no surrounding markup).</p><p> See <a href="http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks" target="_blank">http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#standalone-hyperlinks</a>
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></dd></dl></div>
    </li><li name="laika.parse.util.URIParsers#userInfo" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="userInfo:URIParsers.this.Parser[String]"></a>
      <a id="userInfo:Parser[String]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">userInfo</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="scala.Predef.String">String</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses the user info portion of a URI as defined in RFC 3986.</p><div class="fullcomment"><div class="comment cmt"><p>Parses the user info portion of a URI as defined in RFC 3986.</p><pre>userinfo = *( unreserved / pct-encoded / sub-delims / <span class="lit">":"</span> )</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.util.parsing.combinator.RegexParsers#whiteSpace" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="whiteSpace:scala.util.matching.Regex"></a>
      <a id="whiteSpace:Regex"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">whiteSpace</span><span class="result">: <span class="extype" name="scala.util.matching.Regex">Regex</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd>RegexParsers</dd></dl></div>
    </li><li name="laika.parse.BlockParsers#withNestLevel" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withNestLevel[T](p:=&gt;BlockParsers.this.Parser[T]):BlockParsers.this.Parser[(Int,T)]"></a>
      <a id="withNestLevel[T](⇒Parser[T]):Parser[(Int,T)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withNestLevel</span><span class="tparams">[<span name="T">T</span>]</span><span class="params">(<span name="p">p: ⇒ <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[<span class="extype" name="laika.parse.BlockParsers.withNestLevel.T">T</span>]</span>)</span><span class="result">: <a href="#Parser[+T]extendsParsers.this.Input=&gt;Parsers.this.ParseResult[T]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.Parser">Parser</a>[(<span class="extype" name="scala.Int">Int</span>, <span class="extype" name="laika.parse.BlockParsers.withNestLevel.T">T</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a new parser that produces a tuple containing the current nest
 level as well as the result from the specified parser.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a new parser that produces a tuple containing the current nest
 level as well as the result from the specified parser.</p><p> The nest level is usually only used to prevent endless recursion of nested blocks.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">BlockParsers</a></dd></dl></div>
    </li><li name="laika.parse.rst.BlockParsers#ws" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ws:BlockParsers.this.TextParser"></a>
      <a id="ws:TextParser"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ws</span><span class="result">: <a href="#TextParserextendsMarkupParsers.this.Parser[String]" class="extmbr" name="laika.parse.MarkupParsers.TextParser">TextParser</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Parses horizontal whitespace (space and tab).</p><div class="fullcomment"><div class="comment cmt"><p>Parses horizontal whitespace (space and tab).
 Always succeeds, consuming all whitespace found.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a> → <a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="scala.util.parsing.combinator.Parsers#lastNoSuccess" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lastNoSuccess:Parsers.this.NoSuccess"></a>
      <a id="lastNoSuccess:NoSuccess"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name deprecated" title="Deprecated: (Since version 2.10.0) lastNoSuccess was not thread-safe and will be removed in 2.11.0">lastNoSuccess</span><span class="result">: <a href="#NoSuccessextendsParsers.this.ParseResult[Nothing]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.NoSuccess">NoSuccess</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.10.0)</i> lastNoSuccess was not thread-safe and will be removed in 2.11.0</p></dd></dl></div>
    </li><li name="scala.util.parsing.combinator.Parsers#lastNoSuccess_=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="lastNoSuccess_=(x:Parsers.this.NoSuccess):Unit"></a>
      <a id="lastNoSuccess_=(NoSuccess):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: lastNoSuccess_$eq. Deprecated: (Since version 2.10.0) lastNoSuccess was not thread-safe and will be removed in 2.11.0" class="name deprecated">lastNoSuccess_=</span><span class="params">(<span name="x">x: <a href="#NoSuccessextendsParsers.this.ParseResult[Nothing]" class="extmbr" name="laika.parse.rst.ext.StandardDirectiveParsers.NoSuccess">NoSuccess</a></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Parsers</dd><dt>Annotations</dt><dd>
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.10.0)</i> lastNoSuccess was not thread-safe and will be removed in 2.11.0</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="laika.parse.rst.InlineParsers">
              <h3>Inherited from <a href="../InlineParsers.html" class="extype" name="laika.parse.rst.InlineParsers">InlineParsers</a></h3>
            </div><div class="parent" name="laika.parse.util.URIParsers">
              <h3>Inherited from <a href="../../util/URIParsers.html" class="extype" name="laika.parse.util.URIParsers">URIParsers</a></h3>
            </div><div class="parent" name="laika.parse.InlineParsers">
              <h3>Inherited from <a href="../../InlineParsers.html" class="extype" name="laika.parse.InlineParsers">parse.InlineParsers</a></h3>
            </div><div class="parent" name="laika.parse.rst.BlockParsers">
              <h3>Inherited from <a href="../BlockParsers.html" class="extype" name="laika.parse.rst.BlockParsers">BlockParsers</a></h3>
            </div><div class="parent" name="laika.parse.rst.ExplicitBlockParsers">
              <h3>Inherited from <a href="../ExplicitBlockParsers.html" class="extype" name="laika.parse.rst.ExplicitBlockParsers">ExplicitBlockParsers</a></h3>
            </div><div class="parent" name="laika.parse.rst.TableParsers">
              <h3>Inherited from <a href="../TableParsers.html" class="extype" name="laika.parse.rst.TableParsers">TableParsers</a></h3>
            </div><div class="parent" name="laika.parse.rst.ListParsers">
              <h3>Inherited from <a href="../ListParsers.html" class="extype" name="laika.parse.rst.ListParsers">ListParsers</a></h3>
            </div><div class="parent" name="laika.parse.BlockParsers">
              <h3>Inherited from <a href="../../BlockParsers.html" class="extype" name="laika.parse.BlockParsers">parse.BlockParsers</a></h3>
            </div><div class="parent" name="laika.parse.MarkupParsers">
              <h3>Inherited from <a href="../../MarkupParsers.html" class="extype" name="laika.parse.MarkupParsers">MarkupParsers</a></h3>
            </div><div class="parent" name="laika.parse.BaseParsers">
              <h3>Inherited from <a href="../../BaseParsers.html" class="extype" name="laika.parse.BaseParsers">BaseParsers</a></h3>
            </div><div class="parent" name="scala.util.parsing.combinator.RegexParsers">
              <h3>Inherited from <span class="extype" name="scala.util.parsing.combinator.RegexParsers">RegexParsers</span></h3>
            </div><div class="parent" name="scala.util.parsing.combinator.Parsers">
              <h3>Inherited from <span class="extype" name="scala.util.parsing.combinator.Parsers">Parsers</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../../lib/template.js"></script>
    </body>
      </html>