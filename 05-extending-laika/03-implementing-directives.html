<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link rel="stylesheet" href="../icons/icofont.min.css">
    <link href="../css/container.css" rel="stylesheet">
    <link href="../css/content.css" rel="stylesheet">
    <link href="../css/nav.css" rel="stylesheet">
    <link href="../css/code.css" rel="stylesheet">

    <script src="../js/theme.js"></script>
    <script> /* for avoiding page load transitions */ </script>

  </head>

  <body>

    <nav id="sidebar">

      <a id="close-nav-icon">
        <i class="icofont-close-circled icofont-xlg"></i>
      </a>

      <ul class="nav nav-list">

        
        <li><a href="../table-of-contents.html">Table of Contents</a></li>
        <li class="nav-header">About Laika</li>
        <li><a href="../01-about-laika/01-features.html">Features</a></li>
        <li><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
        <li class="nav-header">Running Laika</li>
        <li><a href="../02-running-laika/01-sbt-plugin.html">sbt Plugin</a></li>
        <li><a href="../02-running-laika/02-library-api.html">Library API</a></li>
        <li><a href="../02-running-laika/03-configuration.html">Configuration</a></li>
        <li class="nav-header">Preparing Content</li>
        <li><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
        <li><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
        <li><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
        <li><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
        <li class="nav-header">Customizing Laika</li>
        <li><a href="../04-customizing-laika/01-overview.html">Overview</a></li>
        <li><a href="../04-customizing-laika/03-creating-templates.html">Creating Templates</a></li>
        <li><a href="../04-customizing-laika/04-document-ast.html">The Document AST</a></li>
        <li><a href="../04-customizing-laika/05-ast-rewriting.html">AST Rewriting</a></li>
        <li><a href="../04-customizing-laika/06-overriding-renderers.html">Overriding Renderers</a></li>
        <li class="nav-header">Extending Laika</li>
        <li><a href="01-overview.html">Overview</a></li>
        <li class="active"><a href="#">Implementing Directives</a></li>
        <li><a href="04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
        <li><a href="06-adding-syntax-highlighters.html">Adding Syntax Highlighters</a></li>
        <li><a href="07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
        <li class="nav-header">Sub-Modules</li>
        <li><a href="../06-sub-modules/02-laikas-parser-combinators.html">Laika&#39;s Parser Combinators</a></li>
        <li><a href="../06-sub-modules/03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
        <li class="nav-header">Reference</li>
        <li><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
        <li><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
        <li><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
        <li><a href="../07-reference/06-release-notes.html">Release Notes</a></li>
        <li><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
        
        <li class="nav-header">Project Links</li>
        <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
        <li><a href="../api/laika/api/">API Documentation</a></li>
        <li><a href="http://planet42.org/">Demo App</a></li>
        
      </ul>

    </nav>

    <div id="container">

      <a id="open-nav-icon">
        <i class="icofont-navigation-menu icofont-xlg"></i>
      </a>

      <main class="content">

        <div class="page-header">
        <h1 id="implementing-directives" class="title">Implementing Directives</h1>
        </div>
        <p>Implementing a directive is one of two possible ways to extend the syntax of a text markup language.</p>
        <p>The second option is <a href="04-writing-parser-extensions.html#writing-parser-extensions">Writing Parser Extensions</a>, but in many cases the directive approach offers more convenience.
        It is based on a common syntax for declaring a directive and its attributes and body elements.
        Therefore directives can be implemented without writing a custom parser and without getting familiar
        with Laika&#39;s parser combinators.</p>
        <p>There are usually only two scenarios where you may prefer to write a parser extension instead:</p>
        <ul>
          <li>
            <p>You have very special requirements for the syntax. 
            If, for example, you want to design a new table markup format, 
            this is quite impossible to express with the fixed syntax of a directive.</p>
          </li>
          <li>
            <p>You want the most concise syntax for elements that are used frequently. 
            One example is to support short references to issues in a ticket system in the format <code>#123</code>.
            The shortest syntax that is possible with directives would be something like <code>@:ticket(123)</code> 
            which you may still find too verbose.</p>
          </li>
        </ul>
        
        <h2 id="anatomy-of-a-directive" class="section">Anatomy of a Directive</h2>
        <p>The following diagram shows a markup directive with all its optional elements present:</p>
        <p><img src="../img/directive-syntax.png" alt="Directive Syntax" width="602"></p>
        <p>It is quite abstract and contrived, because any real-world directive would not use all optional elements at once.</p>
        <p>Let&#39;s discuss the directive parts one by one:</p>
        <ul>
          <li>
            <p>The <strong>directive name</strong> part consists of the character sequence <code>@:</code> followed by an alphanumeric name.
            It is the only required part, and in fact some of the built-in directives of the library like <code>@:pageBreak</code>
            do not accept any attributes or body elements. The convention is that directive names are camel case.
            Their main task is to link the markup to the corresponding directive implementation.</p>
          </li>
          <li>
            <p><a href="#positional-attributes">Positional Attributes</a> can follow the name declaration. 
            They are enclosed in parentheses and contain a comma-separated list of values,
            mimicking the syntax of function invocations.</p>
            <p>They are best suited for directives that either accept a single attribute or a list of attributes of the <em>same type</em>.
            An example would be a list of style names to apply to the body.
            For multiple attributes with different types and meanings, it is recommended to use named attributes instead.</p>
          </li>
          <li>
            <p><a href="#named-attributes-hocon">Named Attributes (HOCON)</a> can follow the name declaration and the optional positional attributes.
            They are enclosed in braces <code>{</code> and <code>}</code> as HOCON is a superset of JSON.</p>
            <p>They offer the full flexibility of the HOCON standard, like nested keys, array elements and substitution references
            (<code>${...}</code>) which allow markup authors to refer to any variable in page/directory/global configuration when
            defining an attribute.</p>
          </li>
          <li>
            <p>The <a href="#directive-body">Directive Body</a> can follow the name declaration and any optional attribute blocks. 
            It is a region of regular markup content demarcated by a closing fence <code>@:@</code>.
            With block directives the closing fence has to be placed on an otherwise empty line,
            with all other directive kinds it can appear anywhere.</p>
            <p>The author of a directive implementation can decide whether the body part should be processed as a raw string,
            or as pre-parsed AST nodes. 
            In the latter case the type of the body passed to the implementation will be <code>Seq[Span]</code>, <code>Seq[Block]</code> or
            <code>Seq[TemplateSpan]</code>, depending on the type of the directive.</p>
          </li>
        </ul>
        <p>Finally, let&#39;s also examine the anatomy of a directive implementation:</p>
        <p><img src="../img/directive-dsl.png" alt="Directive DSL" width="641"></p>
        <p>We&#39;ll go through this line by line:</p>
        <ul>
          <li>
            <p>The imports you need depend on the directive type, you need to choose the matching DSL which is either
            <code>Blocks.dsl._</code>, <code>Spans.dsl._</code> or <code>Templates.dsl._</code>.
            You also need <code>cats.implicits._</code> for the convenient <code>mapN</code> method.</p>
          </li>
          <li>
            <p>The entry point for creating a directive again depends on the type, it&#39;s either
            <code>Blocks.create</code>, <code>Spans.create</code> or <code>Templates.create</code>.
            The string passed to this method is the name of the directive without the leading <code>@:</code>.</p>
          </li>
          <li>
            <p>Next you need to declare the directive parts that you expect, whether they are required or optional,
            and which type they should be converted to. There are combinators for <a href="#directive-attributes">Directive Attributes</a>,
            <a href="#directive-body">Directive Body</a>, <a href="#access-to-the-parser">Access to the Parser</a> and <a href="#access-to-the-document-cursor">Access to the Document Cursor</a>.</p>
          </li>
          <li>
            <p>Finally you pass the function the engine should invoke after validating and converting all expected directive parts.</p>
            <p>The function will not be invoked at all in case of missing required parts or type conversion errors,
            instead an invalid node will inserted into the AST which will be handled 
            depending on your <a href="../02-running-laika/03-configuration.html#error-handling">Error Handling</a> configuration.
            This makes it quite convenient for directive authors as it removes a lot of boilerplate.</p>
            <p>When the directive is valid, the parameters of the function will be of the type matching your spec,
            in our example <code>String</code> and <code>Seq[Block]</code>. 
            The value the directive function produces must be an AST node matching the type of the directive, 
            <code>Span</code>, <code>Block</code> or <code>TemplateSpan</code>.</p>
          </li>
        </ul>
        <p>Further below we&#39;ll show a <a href="#sample-directive">Sample Directive</a> based on a real world scenario.</p>
        
        <h2 id="directive-types" class="section">Directive Types</h2>
        <p>Due to differences in the node types they produce and the location they are allowed to appear in, 
        there is a distinction between seven directive types:</p>
        <ul>
          <li><strong>Template Directives</strong> that can be used anywhere in templates, which produce <code>TemplateSpan</code> elements.</li>
          <li><strong>Block Directives</strong> for block elements in markup, which produce <code>Block</code> elements.</li>
          <li><strong>Span Directives</strong> for inline elements in markup, which produce <code>Span</code> elements.</li>
          <li>3 types of <a href="#separator-directives">Separator Directives</a> which can be used to separate the body elements 
          of any of the other three directive types and can produce any kind of result type.</li>
          <li><a href="#link-directives">Link Directives</a>, a special type of span directives providing shortcuts for directives that
          produce link nodes.</li>
        </ul>
        <p>If you want to create a directive that can be used in all three locations 
        you can usually easily reuse parts of your logic.
        If your directive version for inline elements generates a simple <code>SpanLink</code> node for example,
        you can wrap that same node in a <code>Paragraph</code> block node for a block-level directive.</p>
        <p>The three main directive types for blocks, spans and templates are similar enough that we avoid
        the repetition of documenting them separately. 
        Instead the following sections <a href="#sample-directive">Sample Directive</a>, <a href="#directive-attributes">Directive Attributes</a>, <a href="#directive-body">Directive Body</a>,
        <a href="#access-to-the-parser">Access to the Parser</a> and <a href="#access-to-the-document-cursor">Access to the Document Cursor</a> apply to all of these 3 main types.</p>
        <p><a href="#separator-directives">Separator Directives</a> and <a href="#link-directives">Link Directives</a> on the other hand are quite different,
        which is why they come with their own documentation section.</p>
        
        <h2 id="directives-provided-by-laika" class="section">Directives Provided by Laika</h2>
        <p>Even though this chapter is about implementing your own directives, 
        it&#39;s worthwhile to briefly mention that Laika comes with a handful of directives out of the box.</p>
        <p>First you might want to avoid to reinvent the wheel and ensure the directive idea you had is not already covered.
        Secondly you could look at the existing directive implementations as examples and guidelines for creating your own.</p>
        <p>All available directives are documented in the chapter <a href="../07-reference/01-standard-directives.html#standard-directives">Standard Directives</a>, 
        their source code can be found <a href="https://github.com/planet42/Laika/blob/master/core/src/main/scala/laika/directive/StandardDirectives.scala">here</a></p>
        
        <h2 id="sample-directive" class="section">Sample Directive</h2>
        <p>Like in the <a href="04-writing-parser-extensions.html#writing-parser-extensions">Writing Parser Extensions</a> chapter our example implementation is going to provide a shortcut 
        for a reference to a ticket system via its number. 
        While the custom parser did this with the concise syntax <code>#123</code>,
        a directive has to stick to the standard directive syntax, for which we&#39;ll pick <code>@:ticket(123)</code>.</p>
        
        <h3 id="directive-implementation" class="section">Directive Implementation</h3>
        <p>Let&#39;s walk through the implementation of our little ticket directive:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="type-name">Spans</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">ticketDirective</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;ticket&quot;</span><span>) {
  </span><span class="identifier">attribute</span><span>(</span><span class="number-literal">0</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">map</span><span> { </span><span class="identifier">ticketNo</span><span> =&gt; 
    </span><span class="type-name">SpanLink</span><span>(</span><span class="type-name">Seq</span><span>(</span><span class="type-name">Text</span><span>(</span><span class="string-literal">&quot;#&quot;</span><span> + </span><span class="identifier">num</span><span>)), </span><span class="type-name">ExternalTarget</span><span>(</span><span class="string-literal">s&quot;http://our-tracker.com/</span><span class="substitution">$num</span><span class="string-literal">&quot;</span><span>))
  }
}</span></code></pre>
        <ul>
          <li>
            <p>With <code>Spans.create(&quot;ticket&quot;)</code> we specify the name of the directive without the leading <code>@:</code> prefix.</p>
          </li>
          <li>
            <p><code>attribute(0)</code> specifies a single, positional attribute (which has to appear between parenthesis).
            See <a href="#directive-attributes">Directive Attributes</a> for an overview of all the other options.</p>
          </li>
          <li>
            <p><code>as[Int]</code> converts the attribute to an Int before passing it to the directive. 
            When the attribute is missing or not a valid integer, the directive fails and the function passed to <code>map</code>
            will never be invoked
            There is a range of decoders that you can use out of the box, but you can also provide your own <code>ConfigDecoder</code>.</p>
          </li>
          <li>
            <p>We are not calling <code>.optional</code> on the specified attribute, which means it is mandatory by default and the
            directive will fail if the user omits it (e.g. by just typing <code>@:ticket</code>).</p>
          </li>
          <li>
            <p>We finally create a <code>SpanLink</code> node (which implements <code>Span</code>) as the result.
            We use <code># + num</code> as the link text and then build the URL as an external target.</p>
          </li>
        </ul>
        <p>This first example hard-codes the base URL. If your directive is for internal use, this may not be a problem.
        But if you require a configurable base URL, we later show an enhanced example that has access to the configuration.</p>
        
        <h3 id="directive-registration" class="section">Directive Registration</h3>
        <p>For bundling all your Laika directives, you need to extend <code>DirectiveRegistry</code>.
        This is a sub-trait of <code>ExtensionBundle</code>.</p>
        <p>For our case we only need to register our ticket directive, which is a span directive: </p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">MyDirectives</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">DirectiveRegistry</span><span> {
  </span><span class="keyword">val</span><span> </span><span class="identifier">spanDirectives</span><span> = </span><span class="type-name">Seq</span><span>(</span><span class="identifier">ticketDirective</span><span>)
  </span><span class="keyword">val</span><span> </span><span class="identifier">blockDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
  </span><span class="keyword">val</span><span> </span><span class="identifier">templateDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
  </span><span class="keyword">val</span><span> </span><span class="identifier">linkDirectives</span><span> = </span><span class="type-name">Seq</span><span>()
}</span></code></pre>
        <p>Finally we need to register our registry together with any built-in extensions you may use:</p>
        <p><strong>sbt plugin</strong></p>
        <pre><code class="nohighlight"><span class="identifier">laikaExtensions</span><span> := </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">GitHubFlavor</span><span>,
  </span><span class="type-name">MyDirectives</span><span>
)</span></code></pre>
        <p><strong>Library API</strong></p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyDirectives</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        <p>We can now use our <code>ticket</code> directive in Markdown or reStructuredText files!</p>
        
        <h3 id="access-to-configuration" class="section">Access to Configuration</h3>
        <p>This will enhance the previous example by making the base URL configurable.</p>
        <p>One of the combinators we can use when defining the directive can ask for a document cursor to be
        provided alongside the expected attribute value:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="type-name">Spans</span><span>.</span><span class="identifier">dsl</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">ticketDirective</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;ticket&quot;</span><span>) {
  (</span><span class="identifier">attribute</span><span>(</span><span class="number-literal">0</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>], </span><span class="identifier">cursor</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">ticketNo</span><span>, </span><span class="identifier">cursor</span><span>) =&gt; 
    </span><span class="identifier">cursor</span><span>.</span><span class="identifier">config</span><span>.</span><span class="identifier">get</span><span>[</span><span class="type-name">String</span><span>](</span><span class="string-literal">&quot;ticket.baseURL&quot;</span><span>).</span><span class="identifier">fold</span><span>(
      </span><span class="identifier">error</span><span> =&gt; </span><span class="type-name">InvalidElement</span><span>(</span><span class="string-literal">s&quot;Unable to read base URL: </span><span class="substitution">$error</span><span class="string-literal">&quot;</span><span>, </span><span class="string-literal">&quot;#&quot;</span><span> + </span><span class="identifier">num</span><span>).</span><span class="identifier">asSpan</span><span>,
      </span><span class="identifier">baseURL</span><span> =&gt; </span><span class="type-name">SpanLink</span><span>(</span><span class="type-name">Seq</span><span>(</span><span class="type-name">Text</span><span>(</span><span class="string-literal">&quot;#&quot;</span><span> + </span><span class="identifier">num</span><span>)), </span><span class="type-name">ExternalTarget</span><span>(</span><span class="string-literal">s&quot;</span><span class="substitution">$baseURL$num</span><span class="string-literal">&quot;</span><span>))
    )
  }
}</span></code></pre>
        <p>The <code>DocumentCursor</code> instance passed to our function provides access to the project configuration which we use
        in this example, but also to all ASTs of the input tree, including other documents. 
        It can therefore be used for advanced functionality like producing a table of contents.</p>
        <p>The API of the <code>cursor.config</code> property is documented in <a href="../api/laika/config/Config.html">Config</a>.</p>
        <p>In our case we expect a string, but we also need to handle errors now, as the access might fail
        when the value is missing or it&#39;s not a string. 
        We return an <code>InvalidElement</code> for errors, which is a useful kind of AST node as it allows the user to control the
        error handling. 
        The presence of such an element will by default cause the transformation to fail with the provided error message
        shown alongside any other errors encountered.
        But users can also switch to a &quot;visual debugging&quot; mode by rendering all errors in place. 
        See <a href="../02-running-laika/03-configuration.html#error-handling">Error Handling</a> for details. </p>
        <p>With this change in place, the user can now provide the base URL in the builder of the <code>Transformer</code>:</p>
        <p><strong>sbt plugin</strong></p>
        <pre><code class="nohighlight"><span class="identifier">laikaConfig</span><span> := </span><span class="type-name">LaikaConfig</span><span>.</span><span class="identifier">defaults</span><span>
  .</span><span class="identifier">withConfigValue</span><span>(</span><span class="string-literal">&quot;ticket.baseURL&quot;</span><span>, </span><span class="string-literal">&quot;https://example.com/issues&quot;</span><span>)</span></code></pre>
        <p><strong>Library API</strong></p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">withConfigValue</span><span>(</span><span class="string-literal">&quot;ticket.baseURL&quot;</span><span>, </span><span class="string-literal">&quot;https://example.com/issues&quot;</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        <p>The registration steps are identical to the previous example.</p>
        
        <h2 id="directive-attributes" class="section">Directive Attributes</h2>
        <p>You can use two types of attributes: 
        positional attributes between parenthesis, and named attributes in the HOCON format between curly braces.</p>
        <p>See <a href="#anatomy-of-a-directive">Anatomy of a Directive</a> for an overview and a full syntax example.</p>
        
        <h3 id="positional-attributes" class="section">Positional Attributes</h3>
        <p>Positional attributes can follow the name declaration. 
        They are enclosed in parentheses and contain a comma-separated list of values,
        mimicking the syntax of function invocations.</p>
        <p>They are best suited for directives that either accept a single attribute or a list of attributes of the <em>same type</em>.
        An example would be a list of style names to apply to the body.
        For multiple attributes with different types and meanings, it is recommended to use named attributes instead.</p>
        <p>Markup example:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">format</span><span>(</span><span class="string-literal">html, epub</span><span>)</span></code></pre>
        <p>Combinators:</p>
        <ul>
          <li>
            <p><code>attribute(Int)</code> for accessing a single attribute, e.g. <code>attribute(0)</code> for the first.
            Like with named attributes, you can turn them into <a href="#optional-attributes">Optional Attributes</a> or apply <a href="#type-conversions">Type Conversions</a>.</p>
          </li>
          <li>
            <p><code>positionalAttributes</code> for accessing all positional attributes as a list of values.
            Applying a type conversion like <code>.as[Int]</code> in this case changes the result to be <code>Seq[Int]</code>.</p>
          </li>
        </ul>
        <p>Combinator Example:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">ticketDirective</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;directive-name&quot;</span><span>) {
  </span><span class="identifier">attribute</span><span>(</span><span class="number-literal">0</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">map</span><span> { </span><span class="identifier">ticketNo</span><span> =&gt; 
    ??? </span><span class="comment">// produce AST span node
</span><span>  }
}</span></code></pre>
        
        <h3 id="named-attributes-hocon" class="section">Named Attributes (HOCON)</h3>
        <p>Named Attributes in HOCON format can follow the name declaration and the optional positional attributes.
        They are enclosed in braces <code>{</code> and <code>}</code> as HOCON is a superset of JSON.</p>
        <p>They offer the full flexibility of the HOCON standard, like nested keys, array elements and substitution references
        (<code>${...}</code>) which allow markup authors to refer to any variable in page/directory/global configuration when
        defining an attribute.</p>
        <p>Markup example:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">image</span><span> { </span><span class="attribute-name">width</span><span> = </span><span class="string-literal">280px</span><span>, </span><span class="attribute-name">height</span><span> = </span><span class="string-literal">220px</span><span> }</span></code></pre>
        <p>Combinators:</p>
        <ul>
          <li>
            <p><code>attribute(String)</code> for accessing a single attribute by name, e.g. <code>attribute(&quot;width&quot;)</code> for the <code>width</code> attribute 
            in our example.
            Like with positional attributes, you can turn them into <a href="#optional-attributes">Optional Attributes</a> or apply <a href="#type-conversions">Type Conversions</a>.</p>
          </li>
          <li>
            <p><code>allAttributes</code> for accessing all attributes as a HOCON <code>Config</code> instance, Laika&#39;s configuration API.
            This way you can manually inspect the values it contains. 
            This naturally leaves the burden of validation and error handling (e.g. for required values or type conversions)
            with the implementor of the directive. 
            It should therefore only be used when this level of flexibility is really required.
            See <a href="../api/laika/config/Config.html">Config</a> for the API documentation.</p>
          </li>
        </ul>
        <p>Combinator Example:</p>
        <p>We&#39;ll use the <code>allAttributes</code> combinator together with the one for accessing body elements:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;custom&quot;</span><span>) {
  (</span><span class="identifier">allAttributes</span><span>, </span><span class="identifier">parsedBody</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">attributes</span><span>, </span><span class="identifier">bodyContent</span><span>) =&gt; 
    </span><span class="keyword">val</span><span> </span><span class="identifier">path</span><span> = </span><span class="identifier">attributes</span><span>.</span><span class="identifier">getOpt</span><span>[</span><span class="type-name">Path</span><span>](</span><span class="string-literal">&quot;filePath&quot;</span><span>)
    </span><span class="keyword">val</span><span> </span><span class="identifier">index</span><span> = </span><span class="identifier">attributes</span><span>.</span><span class="identifier">getOpt</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="string-literal">&quot;index&quot;</span><span>)
    ??? </span><span class="comment">// produce AST span node
</span><span>  }
}</span></code></pre>
        
        <h3 id="optional-attributes" class="section">Optional Attributes</h3>
        <p>Positional and named attributes can be marked as optional.</p>
        <p>Combinator Example:</p>
        <pre><code class="nohighlight"><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;width&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">optional</span></code></pre>
        <p>The parameter type of your directive function changes accordingly,
        from <code>T</code> to <code>Option[T]</code> where <code>T</code> is either the type returned by your converter (see below) or the default type.</p>
        
        <h3 id="type-conversions" class="section">Type Conversions</h3>
        <p>You can specify a decoder for all attributes with the <code>as[T]</code> method:</p>
        <pre><code class="nohighlight"><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;depth&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">optional</span></code></pre>
        <p>Without a decoder the result type would be <code>ConfigValue</code> which is a data structure similar to those 
        of popular JSON libraries.
        But that type is rarely the most convenient type, which is why Laika defines some basic decoders out of the box, 
        for <code>String</code>, <code>Int</code>, <code>Double</code>, <code>Boolean</code>, <code>Date</code> and <code>Path</code> as well as <code>Seq</code> and <code>Map</code> of containing these types.</p>
        <p>The decoders will cause a directive to fail in case a type conversion does not succeed.</p>
        <p>You can define your own by implementing <code>ConfigDecoder[T]</code>.</p>
        
        <h3 id="inheritance" class="section">Inheritance</h3>
        <p>By default directives only accept attributes defined right in the attribute section of the directive 
        to avoid name clashes with attributes in other scopes. 
        If you want to explicitly enable inheritance, so that a user can define default values for attributes 
        either programmatically in the global configuration or in headers of the markup or template files,
        you can set the <code>inherited</code> flag:</p>
        <p>Combinator Example:</p>
        <pre><code class="nohighlight"><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;width&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Int</span><span>].</span><span class="identifier">inherited</span></code></pre>
        <p>With this flag set, the <code>width</code> attribute can be inherited from other scopes 
        if it is not defined in the directive itself.</p>
        
        <h2 id="directive-body" class="section">Directive Body</h2>
        <p>A directive body can follow the name declaration and any optional attribute blocks. 
        It is a region of regular markup content demarcated by a closing fence <code>@:@</code>.
        With block directives the closing fence has to be placed on an otherwise empty line,
        with all other directive kinds it can appear anywhere.</p>
        <p>Markup example:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">callout</span><span>(</span><span class="string-literal">warning</span><span>)

This is the content of the body.
It is just regular markup. 

</span><span class="keyword">@:@</span></code></pre>
        <p>Combinators:</p>
        <ul>
          <li>
            <p><code>parsedBody</code>: provides the body content as pre-parsed AST nodes.
            The type of the body passed to the implementation will be <code>Seq[Span]</code>, <code>Seq[Block]</code> or
            <code>Seq[TemplateSpan]</code>, depending on the type of the directive.</p>
          </li>
          <li>
            <p><code>rawBody</code>: provides the body content as a raw, unparsed <code>String</code>.</p>
          </li>
        </ul>
        <p>Combinator Example:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;custom&quot;</span><span>) {
  (</span><span class="identifier">attribute</span><span>(</span><span class="string-literal">&quot;name&quot;</span><span>), </span><span class="identifier">parsedBody</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">nameAttribute</span><span>, </span><span class="identifier">bodyContent</span><span>) =&gt; 
    ??? </span><span class="comment">// produce AST span node, bodyContent will be Seq[Span] here
</span><span>  }
}</span></code></pre>
        
        <h2 id="access-to-the-parser" class="section">Access to the Parser</h2>
        <p>You can request access to the parser of the host language with all extensions the user had installed
        with the <code>parser</code> combinator:</p>
        <pre><code class="nohighlight"><span>(</span><span class="identifier">defaultAttribute</span><span>, </span><span class="identifier">parser</span><span>).</span><span class="identifier">mapN</span><span> { (</span><span class="identifier">attrValue</span><span>, </span><span class="identifier">parser</span><span>) =&gt;
  </span><span class="keyword">val</span><span> </span><span class="identifier">parsedSpans</span><span> = </span><span class="identifier">parser</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span>+</span><span class="identifier">attrValue</span><span>+</span><span class="string-literal">&quot;]&quot;</span><span>)
  </span><span class="type-name">SpanSequence</span><span>(</span><span class="identifier">parsedSpans</span><span>)
}</span></code></pre>
        <p>This is a rare requirement, as in most cases you can just use the <code>parsedBody</code> combinator which will give you the
        entire body segment as a list of AST nodes. </p>
        <p>But in scenarios where you need to pre-process or split a raw input string before passing it to the parser,
        this combinator may come in handy. </p>
        
        <h2 id="access-to-the-document-cursor" class="section">Access to the Document Cursor</h2>
        <p>Finally you can also request access to the document cursor with the <code>cursor</code> combinator. </p>
        <p>A <code>DocumentCursor</code> instance provides access to the project configuration and to all ASTs of the input tree, 
        including those from other documents. 
        It can therefore be used for advanced functionality like producing a table of contents.</p>
        <p>Our sample directive implementation showed a complete example of using this combinator
        in @:(Access to Configuration)</p>
        
        <h2 id="link-directives" class="section">Link Directives</h2>
        <p>A link directive is a shortcut for creating span directives that always produce links.
        It skips some of the boilerplate of regular directives.</p>
        <p>An example for a built-in link directive is the <code>@:api</code> directive.
        A link directive always receives exactly one attribute in the form of a string,
        e.g. <code>@:api(laika.api.Transformer)</code></p>
        <p>The directive implementation you need to provide is then merely a simple function
        <code>(String, DocumentCursor) =&gt; SpanLink</code>, where the String argument is the value of the single attribute. </p>
        <p>Example:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Links</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;github&quot;</span><span>) { (</span><span class="identifier">path</span><span>, </span><span class="identifier">_</span><span>) =&gt;
  </span><span class="keyword">val</span><span> </span><span class="identifier">url</span><span> = </span><span class="string-literal">s&quot;https://github.com/our-project/</span><span class="substitution">$path</span><span class="string-literal">&quot;</span><span>
  </span><span class="type-name">SpanLink</span><span>(</span><span class="type-name">Seq</span><span>(</span><span class="type-name">Text</span><span>(</span><span class="string-literal">s&quot;GitHub (</span><span class="substitution">$path</span><span class="string-literal">)&quot;</span><span>)), </span><span class="type-name">ExternalTarget</span><span>(</span><span class="identifier">url</span><span>))
}</span></code></pre>
        <p>We use the string attribute for creating both, the link text and the URL.</p>
        <p>This shortcut can then be used in markup: <code>@:github(com/example/Hello.py)</code>.
        It mostly achieves a reduction in verbosity you&#39;d otherwise need to repeat the same base URL everywhere.</p>
        <p>We ignore the second argument, the <code>DocumentCursor</code> instance in this case. 
        Like with other directives it gives you access to the configuration and the document AST.
        You can examine the <a href="#sample-directive">Sample Directive</a> for an implementation that avoids the hard-coding of the base URL
        with the help of the cursor.</p>
        <p>Finally, a special feature of link directives is that they can also be used within native link syntax in such a way
        that the user can override the default link text while the directive is merely used to construct the URL:</p>
        <pre><code class="nohighlight"><span>Just check our </span><span class="markup-link-text">[Hello Example]</span><span class="markup-link-target">(@:github(com/example/Hello.py)</span><span>)</span></code></pre>
        
        <h2 id="separator-directives" class="section">Separator Directives</h2>
        <p>Body elements can get divided into multiple sub-sections by a special kind of directive, called a separator directive. </p>
        <p>For an example from the built-in standard directives, let&#39;s have a look at the <code>@:if</code> directive:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">if</span><span>(</span><span class="string-literal">showSidebar</span><span>)
</span><span class="tag-punctuation">&lt;</span><span class="tag-name">div</span><span class="tag-punctuation"> </span><span class="attribute-name">class</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;sidebar&quot;</span><span class="tag-punctuation">&gt;</span><span>...</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">div</span><span class="tag-punctuation">&gt;</span><span>

</span><span class="keyword">@:</span><span class="identifier">elseIf</span><span>(</span><span class="string-literal">showInfobox</span><span>)
</span><span class="tag-punctuation">&lt;</span><span class="tag-name">div</span><span class="tag-punctuation"> </span><span class="attribute-name">class</span><span class="tag-punctuation">=</span><span class="string-literal">&quot;infobox&quot;</span><span class="tag-punctuation">&gt;</span><span>...</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">div</span><span class="tag-punctuation">&gt;</span><span>

</span><span class="keyword">@:</span><span class="identifier">else</span><span>
</span><span class="tag-punctuation">&lt;</span><span class="tag-name">p</span><span class="tag-punctuation">&gt;</span><span>This document does not have any sections</span><span class="tag-punctuation">&lt;/</span><span class="tag-name">p</span><span class="tag-punctuation">&gt;</span><span>

</span><span class="keyword">@:@</span></code></pre>
        <p>The root <code>@if</code> directive is the parent directive in this case, and both the <code>@:elseIf</code> and <code>@:else</code>
        directives are separator directives that partition the body. 
        Separator directives are different than normal directives in that they do not need to produce an AST element
        as they will be passed to the parent directive for processing which then will produce the target AST element.</p>
        <p>If you want to see a full example of such a directive, have a look at the implementation of the <code>@:if</code> directive
        in the <code>StandardDirectives</code> source.</p>
        <p>In this section we&#39;ll just show a very small, contrived example. 
        Declaring a separator directive looks just like declaring a normal directive, 
        only that you call <code>separator</code> instead of <code>create</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Child</span><span> (</span><span class="identifier">content</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">Span</span><span>])

</span><span class="keyword">val</span><span> </span><span class="identifier">sepDir</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">separator</span><span>(</span><span class="string-literal">&quot;child&quot;</span><span>, </span><span class="identifier">min</span><span> = </span><span class="number-literal">1</span><span>) { </span><span class="identifier">parsedBody</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Child</span><span>) }   </span></code></pre>
        <p>Here you specify the name of the directive <code>child</code>, as well as that it has to be present in 
        the body of the parent directive at least once.
        Next you use the regular combinators to declare the expected directive parts, 
        in this case only the <code>parsedBody</code> that you map to the <code>Child</code> type.</p>
        <p>Now you can use this directive in the parent:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">directive</span><span> = </span><span class="type-name">Spans</span><span>.</span><span class="identifier">create</span><span>(</span><span class="string-literal">&quot;parent&quot;</span><span>) { 
  </span><span class="identifier">separatedBody</span><span>(</span><span class="type-name">Seq</span><span>(</span><span class="identifier">sepDir</span><span>)) </span><span class="identifier">map</span><span> { </span><span class="identifier">multipart</span><span> =&gt;
    </span><span class="keyword">val</span><span> </span><span class="identifier">seps</span><span> = </span><span class="identifier">multipart</span><span>.</span><span class="identifier">children</span><span>.</span><span class="identifier">flatMap</span><span> { </span><span class="identifier">sep</span><span> =&gt; 
      </span><span class="type-name">Text</span><span>(</span><span class="string-literal">&quot;Child: &quot;</span><span>) +: </span><span class="identifier">sep</span><span>.</span><span class="identifier">content</span><span> 
    }
    </span><span class="type-name">SpanSequence</span><span>(</span><span class="identifier">multipart</span><span>.</span><span class="identifier">mainBody</span><span> ++ </span><span class="identifier">seps</span><span>)
  }
}</span></code></pre>
        <p>You can use the <code>separatedBody</code> combinator where you pass all expected child directives (in this case only one) 
        and then map the resulting <code>Multipart</code> instance to an AST element. 
        The <code>Multipart</code> gives you access to the main body as well as all processed separator directives in <code>multipart.children</code>.</p>
        <p>This entire directive can then be used like this:</p>
        <pre><code class="nohighlight"><span class="keyword">@:</span><span class="identifier">parent</span><span>
This is the main body

</span><span class="keyword">@:</span><span class="identifier">child</span><span>
This is the body of the separator

</span><span class="keyword">@:@</span></code></pre>
        
      </main>
      
    </div>

  </body>
</html>
