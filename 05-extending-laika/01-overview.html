<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">

    <title>Laika</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Customizable and extensible toolkit for transforming lightweight markup languages to various types of output formats, written in Scala" />
    <meta name="keywords" content="scala, text, markup, markdown, restructuredtext, parser, transformer, html, template engine, site generation, open-source" />

    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/tonsky/FiraCode@1.207/distr/fira_code.css">
    <link rel="stylesheet" href="../icons/icofont.min.css">
    <link href="../css/container.css" rel="stylesheet">
    <link href="../css/content.css" rel="stylesheet">
    <link href="../css/nav.css" rel="stylesheet">
    <link href="../css/code.css" rel="stylesheet">

    <script src="../js/theme.js"></script>
    <script> /* for avoiding page load transitions */ </script>

  </head>

  <body>

    <nav id="sidebar">

      <a id="close-nav-icon">
        <i class="icofont-close-circled icofont-xlg"></i>
      </a>

      <ul class="nav nav-list">

        
        <li><a href="../table-of-contents.html">Table of Contents</a></li>
        <li class="nav-header">About Laika</li>
        <li><a href="../01-about-laika/01-features.html">Features</a></li>
        <li><a href="../01-about-laika/02-design-goals.html">Design Goals</a></li>
        <li class="nav-header">Running Laika</li>
        <li><a href="../02-running-laika/01-sbt-plugin.html">sbt Plugin</a></li>
        <li><a href="../02-running-laika/02-library-api.html">Library API</a></li>
        <li><a href="../02-running-laika/03-configuration.html">Configuration</a></li>
        <li class="nav-header">Preparing Content</li>
        <li><a href="../03-preparing-content/01-directory-structure.html">Directory Structure</a></li>
        <li><a href="../03-preparing-content/02-navigation.html">Navigation</a></li>
        <li><a href="../03-preparing-content/04-ebooks.html">E-Books (EPUB &amp; PDF)</a></li>
        <li><a href="../03-preparing-content/05-syntax-highlighting.html">Syntax Highlighting</a></li>
        <li class="nav-header">Customizing Laika</li>
        <li><a href="../04-customizing-laika/01-overview.html">Overview</a></li>
        <li><a href="../04-customizing-laika/03-creating-templates.html">Creating Templates</a></li>
        <li><a href="../04-customizing-laika/04-document-ast.html">The Document AST</a></li>
        <li><a href="../04-customizing-laika/05-ast-rewriting.html">AST Rewriting</a></li>
        <li><a href="../04-customizing-laika/06-overriding-renderers.html">Overriding Renderers</a></li>
        <li class="nav-header">Extending Laika</li>
        <li class="active"><a href="#">Overview</a></li>
        <li><a href="03-implementing-directives.html">Implementing Directives</a></li>
        <li><a href="04-writing-parser-extensions.html">Writing Parser Extensions</a></li>
        <li><a href="06-adding-syntax-highlighters.html">Adding Syntax Highlighters</a></li>
        <li><a href="07-new-markup-output-formats.html">New Markup or Output Formats</a></li>
        <li class="nav-header">Sub-Modules</li>
        <li><a href="../06-sub-modules/02-laikas-parser-combinators.html">Laika&#39;s Parser Combinators</a></li>
        <li><a href="../06-sub-modules/03-laikas-hocon-api.html">Laika&#39;s HOCON API</a></li>
        <li class="nav-header">Reference</li>
        <li><a href="../07-reference/01-standard-directives.html">Standard Directives</a></li>
        <li><a href="../07-reference/02-substitution-variables.html">Substitution Variables</a></li>
        <li><a href="../07-reference/03-spec-compliance.html">Spec Compliance</a></li>
        <li><a href="../07-reference/06-release-notes.html">Release Notes</a></li>
        <li><a href="../07-reference/07-migration-guide.html">Migration Guide</a></li>
        
        <li class="nav-header">Project Links</li>
        <li><a href="http://github.com/planet42/Laika">Source Code</a></li>
        <li><a href="../api/laika/api/">API Documentation</a></li>
        <li><a href="http://planet42.org/">Demo App</a></li>
        
      </ul>

    </nav>

    <div id="container">

      <a id="open-nav-icon">
        <i class="icofont-navigation-menu icofont-xlg"></i>
      </a>

      <main class="content">

        <div class="page-header">
        <h1 id="overview" class="title">Overview</h1>
        </div>
        <p>Laika&#39;s Documentation comes with separate sections for &quot;Customizing&quot; and &quot;Extending&quot; Laika.
        While the line between the two is naturally quite blurry, 
        the distinction is mostly meant to be between these two scenarios:</p>
        <ul>
          <li>
            <p>Customizing Laika refers to the things you most like want to tweak and adjust in your own project.</p>
          </li>
          <li>
            <p>Extending Laika refers to the kind of re-usable extensions you might want to write as an in-house
            library or a 3rd-party open source extension.</p>
          </li>
        </ul>
        <p>This section deals with the latter scenario.</p>
        
        <h2 id="transformation-phases" class="section">Transformation Phases</h2>
        <p>For a better understanding of the extension points listed below it is good to a have a rough idea about how
        a transformation in Laika is performed. It can be divided into 4 phases:</p>
        <p>1) <strong>The parsing step</strong>. Text markup and template documents get parsed and translated into an internal AST.
           The AST is a generic abstraction of the document&#39;s structure and is not tied to any specific semantics
           of a particular input or output format.</p>
        <p>2) <strong>The AST transformation</strong>. The original AST is only what each parser for the corresponding block or inline
           element can process locally, without access to other nodes or even other documents. 
           One of the advantages of this design, apart from separation of concerns, is that parsers can run in parallel.
           As a consequence nodes like internal references or auto-numbered footnotes require further processing with access to
           a <code>DocumentCursor</code> that allows to access content from anywhere in the input tree.</p>
        <p>3) <strong>Applying templates to markup documents</strong>. 
           Since both are just AST structures, this step is merely a second AST transformation.
           The AST representing the markup document will be inserted into the node of the template AST that holds
           a reference to the content.</p>
        <p>4) <strong>Rendering</strong>. As the last step the final AST obtained from the two previous transformation steps will get rendered
           to one or more output format. 
           This is the only step specific to a particular output format, meaning the same AST structure obtained in 3) will
           get used as the input for the renderers of all formats.</p>
        
        <h2 id="the-extensionbundle-api" class="section">The ExtensionBundle API</h2>
        <p>Hooks into the 4 transformation phases described above as well as other customization hooks
        can be used by implementing an <code>ExtensionBundle</code>.
        See <a href="../api/laika/bundle/ExtensionBundle.html">ExtensionBundle</a> for its API documentation.</p>
        <p>The trait comes with empty default implementations for most of its properties,
        so that you only need to override the ones you intend to use.</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">MyExtensions</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ExtensionBundle</span><span> {

  </span><span class="keyword">override</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">docTypeMatcher</span><span>: </span><span class="type-name">PartialFunction</span><span>[</span><span class="type-name">Path</span><span>, </span><span class="type-name">DocumentType</span><span>] = ???

  </span><span class="comment">// ... optionally other customizations
</span><span>}</span></code></pre>
        <p>Such a bundle can then be passed to the transformer:</p>
        <p><strong>sbt plugin</strong></p>
        <pre><code class="nohighlight"><span class="identifier">laikaExtensions</span><span> := </span><span class="type-name">Seq</span><span>(
  </span><span class="type-name">GitHubFlavor</span><span>,
  </span><span class="type-name">MyExtensions</span><span>
)</span></code></pre>
        <p><strong>Library API</strong></p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">transformer</span><span> = </span><span class="type-name">Transformer</span><span>
  .</span><span class="identifier">from</span><span>(</span><span class="type-name">Markdown</span><span>)
  .</span><span class="identifier">to</span><span>(</span><span class="type-name">HTML</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">GitHubFlavor</span><span>)
  .</span><span class="identifier">using</span><span>(</span><span class="type-name">MyExtensions</span><span>)
  .</span><span class="identifier">build</span></code></pre>
        <p>You&#39;ve probably already seen examples for specifying <code>GitHubFlavor</code> or <code>SyntaxHighlighting</code> extensions in this way.
        These are implementations of <code>ExtensionBundle</code>, too, and come bundled with the <code>laika-core</code> module.</p>
        
        <h3 id="extending-markup-syntax" class="section">Extending Markup Syntax</h3>
        <p>Laika offers two major options for extending the native syntax of a text markup language:</p>
        <ul>
          <li>
            <p><a href="03-implementing-directives.html#implementing-directives">Implementing Directives</a> is an option that allows to quickly add custom functionality without 
            implementing a custom parser.
            Laika comes bundled with a handful of directives which are documented in <a href="../07-reference/01-standard-directives.html#standard-directives">Standard Directives</a>.</p>
          </li>
          <li>
            <p><a href="04-writing-parser-extensions.html#writing-parser-extensions">Writing Parser Extensions</a> is the alternative for cases where you have special requirements for the syntax
            so that the convenient path of writing a directive is not feasible.
            In this case you also need to become familiar with <a href="../06-sub-modules/02-laikas-parser-combinators.html#laika-s-parser-combinators">Laika&#39;s Parser Combinators</a>.</p>
          </li>
        </ul>
        <p>Technically directives hook into phase 2 of a transformation while parser extensions live in phase 1. 
        Parsing of directives is performed by Laika&#39;s built-in parsers as they all have a common syntax.
        A directive implementation is then invoked during AST transformation, 
        receiving all the attributes and body elements the user specified to produce a new AST node to insert.</p>
        
        <h3 id="additional-syntax-highlighters" class="section">Additional Syntax Highlighters</h3>
        <p>Laika has its own built-in syntax highlighters (based on its parser combinators).
        See <a href="../03-preparing-content/05-syntax-highlighting.html#syntax-highlighting">Syntax Highlighting</a> for a list of languages supported out of the box.</p>
        <p>If you want to use a language that is not supported yet, you can either decide to use an external tool like
        <code>highlight.js</code> for this task (Laika renders code elements with attributes compatible with that tool)
        or write your own implementation for Laika&#39;s highlighters.</p>
        <p>If you look at the existing implementations, you&#39;ll notice that some of them are almost purely declarative,
        as the library provides a set of building blocks for parsing the most common literal formats or comments.</p>
        <p>But in most cases you&#39;d also need to get familiar with <a href="../06-sub-modules/02-laikas-parser-combinators.html#laika-s-parser-combinators">Laika&#39;s Parser Combinators</a>.
        See <a href="06-adding-syntax-highlighters.html#adding-syntax-highlighters">Adding Syntax Highlighters</a> for more details.</p>
        
        <h3 id="additional-markup-or-output-formats" class="section">Additional Markup or Output Formats</h3>
        <p>Apart from extending or customizing existing markup or output formats, you can also add support for additional formats.
        If you want to support a different text markup language like ASCIIDoc or Textile, 
        or if you want to produce Word output or slide formats, 
        you can implement a <code>MarkupFormat</code> or <code>RenderFormat</code> as shown in <a href="07-new-markup-output-formats.html#new-markup-or-output-formats">New Markup or Output Formats</a>.</p>
        
        <h3 id="customization-hooks" class="section">Customization Hooks</h3>
        <p>Two of the most commonly used hooks in the <code>ExtensionBundle</code> API are described in the 
        &quot;Customizing Laika&quot; section of the manual:</p>
        <ul>
          <li>
            <p><a href="../04-customizing-laika/05-ast-rewriting.html#ast-rewriting">AST Rewriting</a>, a hook into phase 2 that allows to replace or remove nodes from the AST model 
            between parsing and rendering.</p>
          </li>
          <li>
            <p><a href="../04-customizing-laika/06-overriding-renderers.html#overriding-renderers">Overriding Renderers</a>, a hook into phase 4 that allows to override the rendered output for specific
            AST nodes.</p>
          </li>
        </ul>
        <p>There are two further hooks that drive more low-level functionality:</p>
        <ul>
          <li>
            <p>The <code>docTypeMatcher</code> property in <code>ExtensionBundle</code> controls how a virtual path is used to determine the document type
            (e.g. markup document vs. template vs. configuration file).</p>
          </li>
          <li>
            <p>The <code>slugBuilder</code> property in <code>ExtensionBundle</code> controls how the text from a section headline is translated
            to a slug for element ids. 
            It is a simple function <code>String =&gt; String</code>.</p>
          </li>
        </ul>
        
        <h3 id="replacing-internal-parsers" class="section">Replacing Internal Parsers</h3>
        <p>Laika does not only come with parsers for supported text markup languages.
        It uses additional parsers for its HOCON configuration support, for parsing templates
        and for its &quot;CSS for PDF&quot; functionality.</p>
        <p>Although probably the least likely extension point you need to use, 
        these three parsers can all be replaced by implementing the respective properties in the 
        ParserBundle API: <code>configProvider</code>, <code>templateParser</code> and <code>styleSheetParser</code>.
        Such a bundle can then be declared in an <code>ExtensionBundle</code> with the <code>parsers</code> property.</p>
        
      </main>
      
    </div>

  </body>
</html>
